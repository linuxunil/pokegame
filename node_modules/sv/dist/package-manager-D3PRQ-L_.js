import { createRequire } from "module";
import fs, { existsSync } from "node:fs";
import path, { dirname, isAbsolute, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import process$1, { stdin, stdout } from "node:process";
import * as readline$1 from "node:readline";
import readline from "node:readline";
import { WriteStream } from "node:tty";
import { createRequire as createRequire$1 } from "node:module";
import { spawn } from "child_process";
import { delimiter, dirname as dirname$1, normalize, resolve as resolve$1 } from "path";
import { cwd } from "process";
import { PassThrough } from "stream";
import me from "readline";

//#region rolldown:runtime
var __create$3 = Object.create;
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$3 = Object.getOwnPropertyNames;
var __getProtoOf$3 = Object.getPrototypeOf;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __commonJS$3 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$3 = (to, from$1, except, desc) => {
	if (from$1 && typeof from$1 === "object" || typeof from$1 === "function") for (var keys$1 = __getOwnPropNames$3(from$1), i$1 = 0, n$1 = keys$1.length, key; i$1 < n$1; i$1++) {
		key = keys$1[i$1];
		if (!__hasOwnProp$3.call(to, key) && key !== except) __defProp$3(to, key, {
			get: ((k) => from$1[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$3(from$1, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$3 = (mod, isNodeMode, target) => (target = mod != null ? __create$3(__getProtoOf$3(mod)) : {}, __copyProps$3(isNodeMode || !mod || !mod.__esModule ? __defProp$3(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require$1 = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region packages/create/dist/index.js
function mkdirp(dir) {
	try {
		fs.mkdirSync(dir, { recursive: true });
	} catch (err) {
		const e = err;
		if (e.code === "EEXIST") return;
		throw e;
	}
}
function identity(x$1) {
	return x$1;
}
function copy(from$1, to, rename = identity) {
	if (!fs.existsSync(from$1)) return;
	const stats = fs.statSync(from$1);
	if (stats.isDirectory()) fs.readdirSync(from$1).forEach((file) => {
		copy(path.join(from$1, file), path.join(to, rename(file)));
	});
else {
		mkdirp(path.dirname(to));
		fs.copyFileSync(from$1, to);
	}
}
function dist(path$1$1) {
	const insideDistFolder = import.meta.url.includes("dist");
	return fileURLToPath(new URL(`./${!insideDistFolder ? "dist/" : ""}${path$1$1}`, import.meta.url).href);
}
const templateTypes = [
	"minimal",
	"demo",
	"library"
];
const languageTypes = [
	"typescript",
	"checkjs",
	"none"
];
function create(cwd$1, options) {
	mkdirp(cwd$1);
	write_template_files(options.template, options.types, options.name, cwd$1);
	write_common_files(cwd$1, options, options.name);
}
const templates = templateTypes.map((dir) => {
	const meta_file = dist(`templates/${dir}/meta.json`);
	const { title, description } = JSON.parse(fs.readFileSync(meta_file, "utf8"));
	return {
		name: dir,
		title,
		description
	};
});
function write_template_files(template, types$2, name, cwd$1) {
	const dir = dist(`templates/${template}`);
	copy(`${dir}/assets`, cwd$1, (name$1) => name$1.replace("DOT-", "."));
	copy(`${dir}/package.json`, `${cwd$1}/package.json`);
	const manifest = `${dir}/files.types=${types$2}.json`;
	const files = JSON.parse(fs.readFileSync(manifest, "utf-8"));
	files.forEach((file) => {
		const dest = path.join(cwd$1, file.name);
		mkdirp(path.dirname(dest));
		fs.writeFileSync(dest, file.contents.replace(/~TODO~/g, name));
	});
}
function write_common_files(cwd$1, options, name) {
	const shared$1 = dist("shared.json");
	const { files } = JSON.parse(fs.readFileSync(shared$1, "utf-8"));
	const pkg_file = path.join(cwd$1, "package.json");
	const pkg = JSON.parse(fs.readFileSync(pkg_file, "utf-8"));
	sort_files(files).forEach((file) => {
		const include = file.include.every((condition) => matches_condition(condition, options));
		const exclude = file.exclude.some((condition) => matches_condition(condition, options));
		if (exclude || !include) return;
		if (file.name === "package.json") {
			const new_pkg = JSON.parse(file.contents);
			merge(pkg, new_pkg);
		} else {
			const dest = path.join(cwd$1, file.name);
			mkdirp(path.dirname(dest));
			fs.writeFileSync(dest, file.contents);
		}
	});
	pkg.dependencies = sort_keys(pkg.dependencies);
	pkg.devDependencies = sort_keys(pkg.devDependencies);
	pkg.name = to_valid_package_name(name);
	fs.writeFileSync(pkg_file, JSON.stringify(pkg, null, "	") + "\n");
}
function matches_condition(condition, options) {
	if (templateTypes.includes(condition)) return options.template === condition;
	if (languageTypes.includes(condition)) return options.types === condition;
	return Boolean(options[condition]);
}
function merge(target, source) {
	for (const key in source) if (key in target) {
		const target_value = target[key];
		const source_value = source[key];
		if (typeof source_value !== typeof target_value || Array.isArray(source_value) !== Array.isArray(target_value)) throw new Error("Mismatched values");
		if (typeof source_value === "object") merge(target_value, source_value);
else target[key] = source_value;
	} else target[key] = source[key];
}
function sort_keys(obj) {
	if (!obj) return;
	const sorted = {};
	Object.keys(obj).sort().forEach((key) => {
		sorted[key] = obj[key];
	});
	return sorted;
}
/**
* Sort files so that those which apply more generically come first so they
* can be overwritten by files for more precise cases later.
*/
function sort_files(files) {
	return files.sort((f1, f2) => {
		const f1_more_generic = f1.include.every((include) => f2.include.includes(include)) && f1.exclude.every((exclude) => f2.exclude.includes(exclude));
		const f2_more_generic = f2.include.every((include) => f1.include.includes(include)) && f2.exclude.every((exclude) => f1.exclude.includes(exclude));
		const same = f1_more_generic && f2_more_generic;
		const different = !f1_more_generic && !f2_more_generic;
		return same || different ? 0 : f1_more_generic ? -1 : 1;
	});
}
function to_valid_package_name(name) {
	return name.trim().toLowerCase().replace(/\s+/g, "-").replace(/^[._]/, "").replace(/[^a-z0-9~.-]+/g, "-");
}

//#endregion
//#region packages/clack-prompts/dist/index.js
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from$1, except, desc) => {
	if (from$1 && typeof from$1 === "object" || typeof from$1 === "function") for (var keys$1 = __getOwnPropNames$1(from$1), i$1 = 0, n$1 = keys$1.length, key; i$1 < n$1; i$1++) {
		key = keys$1[i$1];
		if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: ((k) => from$1[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$1(from$1, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __getProtoOf$2 = Object.getPrototypeOf;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __commonJS$2 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$2 = (to, from$1, except, desc) => {
	if (from$1 && typeof from$1 === "object" || typeof from$1 === "function") for (var keys$1 = __getOwnPropNames$2(from$1), i$1 = 0, n$1 = keys$1.length, key; i$1 < n$1; i$1++) {
		key = keys$1[i$1];
		if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
			get: ((k) => from$1[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$2(from$1, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create$2(__getProtoOf$2(mod)) : {}, __copyProps$2(isNodeMode || !mod || !mod.__esModule ? __defProp$2(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var require_src$1 = __commonJS$2({ "node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js"(exports$1, module$1) {
	const ESC$1 = "\x1B";
	const CSI$1 = `${ESC$1}[`;
	const beep$1 = "\x07";
	const cursor$3 = {
		to(x$1, y) {
			if (!y) return `${CSI$1}${x$1 + 1}G`;
			return `${CSI$1}${y + 1};${x$1 + 1}H`;
		},
		move(x$1, y) {
			let ret = "";
			if (x$1 < 0) ret += `${CSI$1}${-x$1}D`;
else if (x$1 > 0) ret += `${CSI$1}${x$1}C`;
			if (y < 0) ret += `${CSI$1}${-y}A`;
else if (y > 0) ret += `${CSI$1}${y}B`;
			return ret;
		},
		up: (count = 1) => `${CSI$1}${count}A`,
		down: (count = 1) => `${CSI$1}${count}B`,
		forward: (count = 1) => `${CSI$1}${count}C`,
		backward: (count = 1) => `${CSI$1}${count}D`,
		nextLine: (count = 1) => `${CSI$1}E`.repeat(count),
		prevLine: (count = 1) => `${CSI$1}F`.repeat(count),
		left: `${CSI$1}G`,
		hide: `${CSI$1}?25l`,
		show: `${CSI$1}?25h`,
		save: `${ESC$1}7`,
		restore: `${ESC$1}8`
	};
	const scroll$1 = {
		up: (count = 1) => `${CSI$1}S`.repeat(count),
		down: (count = 1) => `${CSI$1}T`.repeat(count)
	};
	const erase$1$1 = {
		screen: `${CSI$1}2J`,
		up: (count = 1) => `${CSI$1}1J`.repeat(count),
		down: (count = 1) => `${CSI$1}J`.repeat(count),
		line: `${CSI$1}2K`,
		lineEnd: `${CSI$1}K`,
		lineStart: `${CSI$1}1K`,
		lines(count) {
			let clear = "";
			for (let i$1 = 0; i$1 < count; i$1++) clear += this.line + (i$1 < count - 1 ? cursor$3.up() : "");
			if (count) clear += cursor$3.left;
			return clear;
		}
	};
	module$1.exports = {
		cursor: cursor$3,
		scroll: scroll$1,
		erase: erase$1$1,
		beep: beep$1
	};
} });
function ansiRegex$1({ onlyFirst = false } = {}) {
	const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
	const pattern = [`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`, "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
	return new RegExp(pattern, onlyFirst ? undefined : "g");
}
const regex = ansiRegex$1();
function stripAnsi(string) {
	if (typeof string !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	return string.replace(regex, "");
}
var require_eastasianwidth = __commonJS$2({ "node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js"(exports$1, module$1) {
	var eaw = {};
	if ("undefined" == typeof module$1) window.eastasianwidth = eaw;
else module$1.exports = eaw;
	eaw.eastAsianWidth = function(character) {
		var x$1 = character.charCodeAt(0);
		var y = character.length == 2 ? character.charCodeAt(1) : 0;
		var codePoint = x$1;
		if (55296 <= x$1 && x$1 <= 56319 && 56320 <= y && y <= 57343) {
			x$1 &= 1023;
			y &= 1023;
			codePoint = x$1 << 10 | y;
			codePoint += 65536;
		}
		if (12288 == codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) return "F";
		if (8361 == codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518) return "H";
		if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) return "W";
		if (32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 == codePoint || 175 == codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630) return "Na";
		if (161 == codePoint || 164 == codePoint || 167 <= codePoint && codePoint <= 168 || 170 == codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 == codePoint || 208 == codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 == codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 == codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 == codePoint || 254 == codePoint || 257 == codePoint || 273 == codePoint || 275 == codePoint || 283 == codePoint || 294 <= codePoint && codePoint <= 295 || 299 == codePoint || 305 <= codePoint && codePoint <= 307 || 312 == codePoint || 319 <= codePoint && codePoint <= 322 || 324 == codePoint || 328 <= codePoint && codePoint <= 331 || 333 == codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 == codePoint || 462 == codePoint || 464 == codePoint || 466 == codePoint || 468 == codePoint || 470 == codePoint || 472 == codePoint || 474 == codePoint || 476 == codePoint || 593 == codePoint || 609 == codePoint || 708 == codePoint || 711 == codePoint || 713 <= codePoint && codePoint <= 715 || 717 == codePoint || 720 == codePoint || 728 <= codePoint && codePoint <= 731 || 733 == codePoint || 735 == codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 == codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 == codePoint || 8208 == codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 == codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 == codePoint || 8251 == codePoint || 8254 == codePoint || 8308 == codePoint || 8319 == codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 == codePoint || 8451 == codePoint || 8453 == codePoint || 8457 == codePoint || 8467 == codePoint || 8470 == codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 == codePoint || 8491 == codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 == codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 == codePoint || 8660 == codePoint || 8679 == codePoint || 8704 == codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 == codePoint || 8719 == codePoint || 8721 == codePoint || 8725 == codePoint || 8730 == codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 == codePoint || 8741 == codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 == codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 == codePoint || 8780 == codePoint || 8786 == codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 == codePoint || 8857 == codePoint || 8869 == codePoint || 8895 == codePoint || 8978 == codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 == codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 == codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 == codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 == codePoint || 9758 == codePoint || 9792 == codePoint || 9794 == codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 == codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 == codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 == codePoint || 10071 == codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 == codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109) return "A";
		return "N";
	};
	eaw.characterLength = function(character) {
		var code = this.eastAsianWidth(character);
		if (code == "F" || code == "W" || code == "A") return 2;
else return 1;
	};
	function stringToArray(string) {
		return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
	}
	eaw.length = function(string) {
		var characters = stringToArray(string);
		var len = 0;
		for (var i$1 = 0; i$1 < characters.length; i$1++) len = len + this.characterLength(characters[i$1]);
		return len;
	};
	eaw.slice = function(text$1, start, end) {
		textLen = eaw.length(text$1);
		start = start ? start : 0;
		end = end ? end : 1;
		if (start < 0) start = textLen + start;
		if (end < 0) end = textLen + end;
		var result = "";
		var eawLen = 0;
		var chars$1 = stringToArray(text$1);
		for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
			var char = chars$1[i$1];
			var charLen = eaw.length(char);
			if (eawLen >= start - (charLen == 2 ? 1 : 0)) if (eawLen + charLen <= end) result += char;
else break;
			eawLen += charLen;
		}
		return result;
	};
} });
var require_emoji_regex = __commonJS$2({ "node_modules/.pnpm/emoji-regex@9.2.2/node_modules/emoji-regex/index.js"(exports$1, module$1) {
	module$1.exports = function() {
		return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
	};
} });
var import_eastasianwidth = __toESM$2(require_eastasianwidth(), 1);
var import_emoji_regex = __toESM$2(require_emoji_regex(), 1);
function stringWidth(string, options = {}) {
	if (typeof string !== "string" || string.length === 0) return 0;
	options = {
		ambiguousIsNarrow: true,
		...options
	};
	string = stripAnsi(string);
	if (string.length === 0) return 0;
	string = string.replace((0, import_emoji_regex.default)(), "  ");
	const ambiguousCharacterWidth = options.ambiguousIsNarrow ? 1 : 2;
	let width = 0;
	for (const character of string) {
		const codePoint = character.codePointAt(0);
		if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) continue;
		if (codePoint >= 768 && codePoint <= 879) continue;
		const code = import_eastasianwidth.default.eastAsianWidth(character);
		switch (code) {
			case "F":
			case "W":
				width += 2;
				break;
			case "A":
				width += ambiguousCharacterWidth;
				break;
			default: width += 1;
		}
	}
	return width;
}
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
	const codes = new Map();
	for (const [groupName, group$1] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group$1)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group$1[styleName] = styles[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles, groupName, {
			value: group$1,
			enumerable: false
		});
	}
	Object.defineProperty(styles, "codes", {
		value: codes,
		enumerable: false
	});
	styles.color.close = "\x1B[39m";
	styles.bgColor.close = "\x1B[49m";
	styles.color.ansi = wrapAnsi16();
	styles.color.ansi256 = wrapAnsi256();
	styles.color.ansi16m = wrapAnsi16m();
	styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles, {
		rgbToAnsi256: {
			value: (red, green, blue) => {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value: (hex) => {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value: (code) => {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles;
}
const ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;
const ESCAPES = new Set(["\x1B", ""]);
const END_CODE = 39;
const ANSI_ESCAPE_BELL = "\x07";
const ANSI_CSI = "[";
const ANSI_OSC = "]";
const ANSI_SGR_TERMINATOR = "m";
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
const wrapAnsiCode = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
const wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
const wrapWord = (rows, word, columns) => {
	const characters = [...word];
	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);
		if (visible + characterLength <= columns) rows[rows.length - 1] += character;
else {
			rows.push(character);
			visible = 0;
		}
		if (ESCAPES.has(character)) {
			isInsideEscape = true;
			isInsideLinkEscape = characters.slice(index + 1).join("").startsWith(ANSI_ESCAPE_LINK);
		}
		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) isInsideEscape = false;
			continue;
		}
		visible += characterLength;
		if (visible === columns && index < characters.length - 1) {
			rows.push("");
			visible = 0;
		}
	}
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) rows[rows.length - 2] += rows.pop();
};
const stringVisibleTrimSpacesRight = (string) => {
	const words = string.split(" ");
	let last = words.length;
	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) break;
		last--;
	}
	if (last === words.length) return string;
	return words.slice(0, last).join(" ") + words.slice(last).join("");
};
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === "") return "";
	let returnValue = "";
	let escapeCode;
	let escapeUrl;
	const lengths = wordLengths(string);
	let rows = [""];
	for (const [index, word] of string.split(" ").entries()) {
		if (options.trim !== false) rows[rows.length - 1] = rows[rows.length - 1].trimStart();
		let rowLength = stringWidth(rows[rows.length - 1]);
		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				rows.push("");
				rowLength = 0;
			}
			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += " ";
				rowLength++;
			}
		}
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = columns - rowLength;
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) rows.push("");
			wrapWord(rows, word, columns);
			continue;
		}
		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}
			rows.push("");
		}
		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}
		rows[rows.length - 1] += word;
	}
	if (options.trim !== false) rows = rows.map((row) => stringVisibleTrimSpacesRight(row));
	const pre = [...rows.join("\n")];
	for (const [index, character] of pre.entries()) {
		returnValue += character;
		if (ESCAPES.has(character)) {
			const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join("")) || { groups: {} };
			if (groups.code !== undefined) {
				const code$1 = Number.parseFloat(groups.code);
				escapeCode = code$1 === END_CODE ? undefined : code$1;
			} else if (groups.uri !== undefined) escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
		}
		const code = ansi_styles_default.codes.get(Number(escapeCode));
		if (pre[index + 1] === "\n") {
			if (escapeUrl) returnValue += wrapAnsiHyperlink("");
			if (escapeCode && code) returnValue += wrapAnsiCode(code);
		} else if (character === "\n") {
			if (escapeCode && code) returnValue += wrapAnsiCode(escapeCode);
			if (escapeUrl) returnValue += wrapAnsiHyperlink(escapeUrl);
		}
	}
	return returnValue;
};
function wrapAnsi(string, columns, options) {
	return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
}
var import_src$2 = __toESM$2(require_src$1(), 1);
function diffLines(a, b) {
	if (a === b) return;
	const aLines = a.split("\n");
	const bLines = b.split("\n");
	const diff = [];
	for (let i$1 = 0; i$1 < Math.max(aLines.length, bLines.length); i$1++) if (aLines[i$1] !== bLines[i$1]) diff.push(i$1);
	return diff;
}
const cancel$1 = Symbol("clack:cancel");
function isCancel(value) {
	return value === cancel$1;
}
function setRawMode(input, value) {
	if (input.isTTY) input.setRawMode(value);
}
const aliases = new Map([
	["k", "up"],
	["j", "down"],
	["h", "left"],
	["l", "right"]
]);
const keys = new Set([
	"up",
	"down",
	"left",
	"right",
	"space",
	"enter"
]);
var Prompt = class {
	input;
	output;
	rl;
	opts;
	_track = false;
	_render;
	_cursor = 0;
	state = "initial";
	value;
	error = "";
	constructor({ render: render$1, input = stdin, output = stdout,...opts }, trackValue = true) {
		this.opts = opts;
		this.onKeypress = this.onKeypress.bind(this);
		this.close = this.close.bind(this);
		this.render = this.render.bind(this);
		this._render = render$1.bind(this);
		this._track = trackValue;
		this.input = input;
		this.output = output;
	}
	prompt() {
		const sink = new WriteStream(0);
		sink._write = (chunk, encoding, done) => {
			if (this._track) {
				this.value = this.rl.line.replace(/\t/g, "");
				this._cursor = this.rl.cursor;
				this.emit("value", this.value);
			}
			done();
		};
		this.input.pipe(sink);
		this.rl = readline.createInterface({
			input: this.input,
			output: sink,
			tabSize: 2,
			prompt: "",
			escapeCodeTimeout: 50
		});
		readline.emitKeypressEvents(this.input, this.rl);
		this.rl.prompt();
		if (this.opts.initialValue !== undefined && this._track) this.rl.write(this.opts.initialValue);
		this.input.on("keypress", this.onKeypress);
		setRawMode(this.input, true);
		this.output.on("resize", this.render);
		this.render();
		return new Promise((resolve$2) => {
			this.once("submit", () => {
				this.output.write(import_src$2.cursor.show);
				this.output.off("resize", this.render);
				setRawMode(this.input, false);
				resolve$2(this.value);
			});
			this.once("cancel", () => {
				this.output.write(import_src$2.cursor.show);
				this.output.off("resize", this.render);
				setRawMode(this.input, false);
				resolve$2(cancel$1);
			});
		});
	}
	subscribers = new Map();
	on(event, cb) {
		const arr = this.subscribers.get(event) ?? [];
		arr.push({ cb });
		this.subscribers.set(event, arr);
	}
	once(event, cb) {
		const arr = this.subscribers.get(event) ?? [];
		arr.push({
			cb,
			once: true
		});
		this.subscribers.set(event, arr);
	}
	emit(event, ...data$1) {
		const cbs = this.subscribers.get(event) ?? [];
		const cleanup = [];
		for (const subscriber of cbs) {
			subscriber.cb(...data$1);
			if (subscriber.once) cleanup.push(() => cbs.splice(cbs.indexOf(subscriber), 1));
		}
		for (const cb of cleanup) cb();
	}
	unsubscribe() {
		this.subscribers.clear();
	}
	onKeypress(char, key) {
		if (this.state === "error") this.state = "active";
		if (key?.name && !this._track && aliases.has(key.name)) this.emit("cursor", aliases.get(key.name));
		if (key?.name && keys.has(key.name)) this.emit("cursor", key.name);
		if (char && (char.toLowerCase() === "y" || char.toLowerCase() === "n")) this.emit("confirm", char.toLowerCase() === "y");
		if (char === "	" && this.opts.placeholder) {
			if (!this.value) {
				this.rl.write(this.opts.placeholder);
				this.emit("value", this.opts.placeholder);
			}
		}
		if (char) this.emit("key", char.toLowerCase());
		if (key?.name === "return") {
			if (this.opts.validate) {
				const problem = this.opts.validate(this.value);
				if (problem) {
					this.error = problem;
					this.state = "error";
					this.rl.write(this.value);
				}
			}
			if (this.state !== "error") this.state = "submit";
		}
		if (char === "") this.state = "cancel";
		if (this.state === "submit" || this.state === "cancel") this.emit("finalize");
		this.render();
		if (this.state === "submit" || this.state === "cancel") this.close();
	}
	close() {
		this.input.unpipe();
		this.input.removeListener("keypress", this.onKeypress);
		this.output.write("\n");
		setRawMode(this.input, false);
		this.rl.close();
		this.emit(this.state, this.value);
		this.unsubscribe();
	}
	restoreCursor() {
		const lines = wrapAnsi(this._prevFrame, process$1.stdout.columns, { hard: true }).split("\n").length - 1;
		this.output.write(import_src$2.cursor.move(-999, lines * -1));
	}
	_prevFrame = "";
	render() {
		const frame = wrapAnsi(this._render(this) ?? "", process$1.stdout.columns, { hard: true });
		if (frame === this._prevFrame) return;
		if (this.state === "initial") this.output.write(import_src$2.cursor.hide);
		const diff = diffLines(this._prevFrame, frame);
		this.restoreCursor();
		if (diff) {
			const diffLine = diff[0];
			const lines = frame.split("\n");
			let newLines = [];
			if (lines.length > process$1.stdout.rows) {
				const OFFSET = 3;
				const PAGE_SIZE = process$1.stdout.rows - OFFSET;
				const pos = this.cursor;
				const start = pos <= OFFSET ? OFFSET : pos;
				const end = start + PAGE_SIZE;
				this.output.write(import_src$2.erase.down());
				const header = lines.slice(0, OFFSET);
				const content = lines.slice(start, end);
				newLines = newLines.concat(header, content);
			} else {
				this.output.write(import_src$2.cursor.move(0, diffLine));
				this.output.write(import_src$2.erase.down());
				newLines = lines.slice(diffLine);
			}
			this.output.write(newLines.join("\n"));
			this._prevFrame = frame;
			return;
		}
		this.output.write(frame);
		if (this.state === "initial") this.state = "active";
		this._prevFrame = frame;
	}
};
var import_src$1 = __toESM$2(require_src$1(), 1);
var ConfirmPrompt = class extends Prompt {
	get cursor() {
		return this.value ? 0 : 1;
	}
	get _value() {
		return this.cursor === 0;
	}
	constructor(opts) {
		super(opts, false);
		this.value = opts.initialValue ? true : false;
		this.on("value", () => {
			this.value = this._value;
		});
		this.on("confirm", (confirm$1) => {
			this.output.write(import_src$1.cursor.move(0, -1));
			this.value = confirm$1;
			this.state = "submit";
			this.close();
		});
		this.on("cursor", () => {
			this.value = !this.value;
		});
	}
};
var MultiSelectPrompt = class extends Prompt {
	options;
	cursor = 0;
	get _value() {
		return this.options[this.cursor].value;
	}
	toggleAll() {
		const allSelected = this.value.length === this.options.length;
		this.value = allSelected ? [] : this.options.map((v) => v.value);
	}
	toggleValue() {
		const selected = this.value.includes(this._value);
		this.value = selected ? this.value.filter((value) => value !== this._value) : [...this.value, this._value];
	}
	constructor(opts) {
		super(opts, false);
		this.options = opts.options;
		this.value = [...opts.initialValues ?? []];
		this.cursor = Math.max(this.options.findIndex(({ value }) => value === opts.cursorAt), 0);
		this.on("key", (char) => {
			if (char === "a") this.toggleAll();
		});
		this.on("cursor", (key) => {
			switch (key) {
				case "left":
				case "up":
					this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
					break;
				case "down":
				case "right":
					this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
					break;
				case "space":
					this.toggleValue();
					break;
			}
		});
	}
};
var require_picocolors$1 = __commonJS$2({ "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports$1, module$1) {
	let p$1 = process || {}, argv$1 = p$1.argv || [], env$1 = p$1.env || {};
	let isColorSupported$1 = !(!!env$1.NO_COLOR || argv$1.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv$1.includes("--color") || p$1.platform === "win32" || (p$1.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI);
	let formatter$1 = (open, close, replace = open) => (input) => {
		let string = "" + input, index = string.indexOf(close, open.length);
		return ~index ? open + replaceClose$1(string, close, replace, index) + close : open + string + close;
	};
	let replaceClose$1 = (string, close, replace, index) => {
		let result = "", cursor$4 = 0;
		do {
			result += string.substring(cursor$4, index) + replace;
			cursor$4 = index + close.length;
			index = string.indexOf(close, cursor$4);
		} while (~index);
		return result + string.substring(cursor$4);
	};
	let createColors$1 = (enabled = isColorSupported$1) => {
		let f = enabled ? formatter$1 : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m")
		};
	};
	module$1.exports = createColors$1();
	module$1.exports.createColors = createColors$1;
} });
var import_picocolors$1 = __toESM$2(require_picocolors$1(), 1);
var SelectPrompt = class extends Prompt {
	options;
	cursor = 0;
	get _value() {
		return this.options[this.cursor];
	}
	changeValue() {
		this.value = this._value.value;
	}
	constructor(opts) {
		super(opts, false);
		this.options = opts.options;
		this.cursor = this.options.findIndex(({ value }) => value === opts.initialValue);
		if (this.cursor === -1) this.cursor = 0;
		this.changeValue();
		this.on("cursor", (key) => {
			switch (key) {
				case "left":
				case "up":
					this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
					break;
				case "down":
				case "right":
					this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
					break;
			}
			this.changeValue();
		});
	}
};
var import_picocolors$2 = __toESM$2(require_picocolors$1(), 1);
var TextPrompt = class extends Prompt {
	valueWithCursor = "";
	get cursor() {
		return this._cursor;
	}
	constructor(opts) {
		super(opts);
		this.on("finalize", () => {
			if (!this.value) this.value = opts.defaultValue;
			this.valueWithCursor = this.value;
		});
		this.on("value", () => {
			if (this.cursor >= this.value.length) this.valueWithCursor = `${this.value}${import_picocolors$2.default.inverse(import_picocolors$2.default.hidden("_"))}`;
else {
				const s1 = this.value.slice(0, this.cursor);
				const s2 = this.value.slice(this.cursor);
				this.valueWithCursor = `${s1}${import_picocolors$2.default.inverse(s2[0])}${s2.slice(1)}`;
			}
		});
	}
};
var import_src$3 = __toESM$2(require_src$1(), 1);
const isWindows = process$1.platform.startsWith("win");
function block({ input = stdin, output = stdout, overwrite = true, hideCursor = true } = {}) {
	const rl = readline$1.createInterface({
		input,
		output,
		prompt: "",
		tabSize: 1
	});
	readline$1.emitKeypressEvents(input, rl);
	if (input.isTTY) input.setRawMode(true);
	const clear = (data$1, { name }) => {
		const str = String(data$1);
		if (str === "") process$1.exit(0);
		if (!overwrite) return;
		const dx = name === "return" ? 0 : -1;
		const dy = name === "return" ? -1 : 0;
		readline$1.moveCursor(output, dx, dy, () => {
			readline$1.clearLine(output, 1, () => {
				input.once("keypress", clear);
			});
		});
	};
	if (hideCursor) process$1.stdout.write(import_src$3.cursor.hide);
	input.once("keypress", clear);
	return () => {
		input.off("keypress", clear);
		if (hideCursor) process$1.stdout.write(import_src$3.cursor.show);
		if (input.isTTY && !isWindows) input.setRawMode(false);
		rl.terminal = false;
		rl.close();
	};
}
function isUnicodeSupported() {
	if (process$1.platform !== "win32") return process$1.env.TERM !== "linux";
	return Boolean(process$1.env.CI) || Boolean(process$1.env.WT_SESSION) || Boolean(process$1.env.TERMINUS_SUBLIME) || process$1.env.ConEmuTask === "{cmd::Cmder}" || process$1.env.TERM_PROGRAM === "Terminus-Sublime" || process$1.env.TERM_PROGRAM === "vscode" || process$1.env.TERM === "xterm-256color" || process$1.env.TERM === "alacritty" || process$1.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var require_picocolors$2 = __commonJS$1({ "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports$1, module) {
	let p = process || {}, argv = p.argv || [], env$1 = p.env || {};
	let isColorSupported = !(!!env$1.NO_COLOR || argv.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI);
	let formatter = (open, close, replace = open) => (input) => {
		let string = "" + input, index = string.indexOf(close, open.length);
		return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	};
	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor$2 = 0;
		do {
			result += string.substring(cursor$2, index) + replace;
			cursor$2 = index + close.length;
			index = string.indexOf(close, cursor$2);
		} while (~index);
		return result + string.substring(cursor$2);
	};
	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m")
		};
	};
	module.exports = createColors();
	module.exports.createColors = createColors;
} });
var require_src = __commonJS$1({ "node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js"(exports$1, module) {
	const ESC = "\x1B";
	const CSI = `${ESC}[`;
	const beep = "\x07";
	const cursor$1 = {
		to(x$1, y) {
			if (!y) return `${CSI}${x$1 + 1}G`;
			return `${CSI}${y + 1};${x$1 + 1}H`;
		},
		move(x$1, y) {
			let ret = "";
			if (x$1 < 0) ret += `${CSI}${-x$1}D`;
else if (x$1 > 0) ret += `${CSI}${x$1}C`;
			if (y < 0) ret += `${CSI}${-y}A`;
else if (y > 0) ret += `${CSI}${y}B`;
			return ret;
		},
		up: (count = 1) => `${CSI}${count}A`,
		down: (count = 1) => `${CSI}${count}B`,
		forward: (count = 1) => `${CSI}${count}C`,
		backward: (count = 1) => `${CSI}${count}D`,
		nextLine: (count = 1) => `${CSI}E`.repeat(count),
		prevLine: (count = 1) => `${CSI}F`.repeat(count),
		left: `${CSI}G`,
		hide: `${CSI}?25l`,
		show: `${CSI}?25h`,
		save: `${ESC}7`,
		restore: `${ESC}8`
	};
	const scroll = {
		up: (count = 1) => `${CSI}S`.repeat(count),
		down: (count = 1) => `${CSI}T`.repeat(count)
	};
	const erase$1 = {
		screen: `${CSI}2J`,
		up: (count = 1) => `${CSI}1J`.repeat(count),
		down: (count = 1) => `${CSI}J`.repeat(count),
		line: `${CSI}2K`,
		lineEnd: `${CSI}K`,
		lineStart: `${CSI}1K`,
		lines(count) {
			let clear = "";
			for (let i$1 = 0; i$1 < count; i$1++) clear += this.line + (i$1 < count - 1 ? cursor$1.up() : "");
			if (count) clear += cursor$1.left;
			return clear;
		}
	};
	module.exports = {
		cursor: cursor$1,
		scroll,
		erase: erase$1,
		beep
	};
} });
var import_picocolors = __toESM$1(require_picocolors$2(), 1);
var import_src = __toESM$1(require_src(), 1);
const unicode = isUnicodeSupported();
const s = (c$1, fallback) => unicode ? c$1 : fallback;
const S_STEP_ACTIVE = s("◆", "*");
const S_STEP_CANCEL = s("■", "x");
const S_STEP_ERROR = s("▲", "x");
const S_STEP_SUBMIT = s("◇", "o");
const S_BAR_START = s("┌", "T");
const S_BAR = s("│", "|");
const S_BAR_END = s("└", "—");
const S_RADIO_ACTIVE = s("●", ">");
const S_RADIO_INACTIVE = s("○", " ");
const S_CHECKBOX_ACTIVE = s("◻", "[•]");
const S_CHECKBOX_SELECTED = s("◼", "[+]");
const S_CHECKBOX_INACTIVE = s("◻", "[ ]");
const S_PASSWORD_MASK = s("▪", "•");
const S_BAR_H = s("─", "-");
const S_CORNER_TOP_RIGHT = s("╮", "+");
const S_CONNECT_LEFT = s("├", "+");
const S_CORNER_BOTTOM_RIGHT = s("╯", "+");
const S_INFO = s("●", "•");
const S_SUCCESS = s("◆", "*");
const S_WARN = s("▲", "!");
const S_ERROR = s("■", "x");
const symbol = (state) => {
	switch (state) {
		case "initial":
		case "active": return import_picocolors.default.cyan(S_STEP_ACTIVE);
		case "cancel": return import_picocolors.default.red(S_STEP_CANCEL);
		case "error": return import_picocolors.default.yellow(S_STEP_ERROR);
		case "submit": return import_picocolors.default.green(S_STEP_SUBMIT);
	}
};
const limitOptions = (params) => {
	const { cursor: cursor$2, options, style } = params;
	const paramMaxItems = params.maxItems ?? Infinity;
	const outputMaxItems = Math.max(process$1.stdout.rows - 4, 0);
	const maxItems = Math.min(outputMaxItems, Math.max(paramMaxItems, 5));
	let slidingWindowLocation = 0;
	if (cursor$2 >= slidingWindowLocation + maxItems - 3) slidingWindowLocation = Math.max(Math.min(cursor$2 - maxItems + 3, options.length - maxItems), 0);
else if (cursor$2 < slidingWindowLocation + 2) slidingWindowLocation = Math.max(cursor$2 - 2, 0);
	const shouldRenderTopEllipsis = maxItems < options.length && slidingWindowLocation > 0;
	const shouldRenderBottomEllipsis = maxItems < options.length && slidingWindowLocation + maxItems < options.length;
	return options.slice(slidingWindowLocation, slidingWindowLocation + maxItems).map((option, i$1, arr) => {
		const isTopLimit = i$1 === 0 && shouldRenderTopEllipsis;
		const isBottomLimit = i$1 === arr.length - 1 && shouldRenderBottomEllipsis;
		return isTopLimit || isBottomLimit ? import_picocolors.default.dim("...") : style(option, i$1 + slidingWindowLocation === cursor$2);
	});
};
const text = (opts) => {
	return new TextPrompt({
		validate: opts.validate,
		placeholder: opts.placeholder,
		defaultValue: opts.defaultValue,
		initialValue: opts.initialValue,
		render() {
			const title = `${import_picocolors.default.gray(S_BAR)}\n${symbol(this.state)}  ${opts.message}\n`;
			const placeholder = opts.placeholder ? import_picocolors.default.inverse(opts.placeholder[0]) + import_picocolors.default.dim(opts.placeholder.slice(1)) : import_picocolors.default.inverse(import_picocolors.default.hidden("_"));
			const value = !this.value ? placeholder : this.valueWithCursor;
			switch (this.state) {
				case "error": return `${title.trim()}\n${import_picocolors.default.yellow(S_BAR)}  ${value}\n${import_picocolors.default.yellow(S_BAR_END)}  ${import_picocolors.default.yellow(this.error)}\n`;
				case "submit": return `${title}${import_picocolors.default.gray(S_BAR)}  ${import_picocolors.default.dim(this.value || opts.placeholder)}`;
				case "cancel": return `${title}${import_picocolors.default.gray(S_BAR)}  ${import_picocolors.default.strikethrough(import_picocolors.default.dim(this.value ?? ""))}${this.value?.trim() ? "\n" + import_picocolors.default.gray(S_BAR) : ""}`;
				default: return `${title}${import_picocolors.default.cyan(S_BAR)}  ${value}\n${import_picocolors.default.cyan(S_BAR_END)}\n`;
			}
		}
	}).prompt();
};
const confirm = (opts) => {
	const active = opts.active ?? "Yes";
	const inactive = opts.inactive ?? "No";
	return new ConfirmPrompt({
		active,
		inactive,
		initialValue: opts.initialValue ?? true,
		render() {
			const title = `${import_picocolors.default.gray(S_BAR)}\n${symbol(this.state)}  ${opts.message}\n`;
			const value = this.value ? active : inactive;
			switch (this.state) {
				case "submit": return `${title}${import_picocolors.default.gray(S_BAR)}  ${import_picocolors.default.dim(value)}`;
				case "cancel": return `${title}${import_picocolors.default.gray(S_BAR)}  ${import_picocolors.default.strikethrough(import_picocolors.default.dim(value))}\n${import_picocolors.default.gray(S_BAR)}`;
				default: return `${title}${import_picocolors.default.cyan(S_BAR)}  ${this.value ? `${import_picocolors.default.green(S_RADIO_ACTIVE)} ${active}` : `${import_picocolors.default.dim(S_RADIO_INACTIVE)} ${import_picocolors.default.dim(active)}`} ${import_picocolors.default.dim("/")} ${!this.value ? `${import_picocolors.default.green(S_RADIO_ACTIVE)} ${inactive}` : `${import_picocolors.default.dim(S_RADIO_INACTIVE)} ${import_picocolors.default.dim(inactive)}`}\n${import_picocolors.default.cyan(S_BAR_END)}\n`;
			}
		}
	}).prompt();
};
const select = (opts) => {
	const opt = (option, state) => {
		const label = option.label ?? String(option.value);
		switch (state) {
			case "selected": return import_picocolors.default.dim(label);
			case "active": return `${import_picocolors.default.green(S_RADIO_ACTIVE)} ${label} ${option.hint ? import_picocolors.default.dim(`(${option.hint})`) : ""}`;
			case "cancelled": return import_picocolors.default.strikethrough(import_picocolors.default.dim(label));
			default: return `${import_picocolors.default.dim(S_RADIO_INACTIVE)} ${import_picocolors.default.dim(label)}`;
		}
	};
	return new SelectPrompt({
		options: opts.options,
		initialValue: opts.initialValue,
		render() {
			const title = `${import_picocolors.default.gray(S_BAR)}\n${symbol(this.state)}  ${opts.message}\n`;
			switch (this.state) {
				case "submit": return `${title}${import_picocolors.default.gray(S_BAR)}  ${opt(this.options[this.cursor], "selected")}`;
				case "cancel": return `${title}${import_picocolors.default.gray(S_BAR)}  ${opt(this.options[this.cursor], "cancelled")}\n${import_picocolors.default.gray(S_BAR)}`;
				default: return `${title}${import_picocolors.default.cyan(S_BAR)}  ${limitOptions({
					cursor: this.cursor,
					options: this.options,
					maxItems: opts.maxItems,
					style: (item, active) => opt(item, active ? "active" : "inactive")
				}).join(`\n${import_picocolors.default.cyan(S_BAR)}  `)}\n${import_picocolors.default.cyan(S_BAR_END)}\n`;
			}
		}
	}).prompt();
};
const multiselect = (opts) => {
	const opt = (option, state) => {
		const label = option.label ?? String(option.value);
		if (state === "active") return `${import_picocolors.default.cyan(S_CHECKBOX_ACTIVE)} ${label} ${option.hint ? import_picocolors.default.dim(`(${option.hint})`) : ""}`;
else if (state === "selected") return `${import_picocolors.default.green(S_CHECKBOX_SELECTED)} ${import_picocolors.default.dim(label)}`;
else if (state === "cancelled") return import_picocolors.default.strikethrough(import_picocolors.default.dim(label));
else if (state === "active-selected") return `${import_picocolors.default.green(S_CHECKBOX_SELECTED)} ${label} ${option.hint ? import_picocolors.default.dim(`(${option.hint})`) : ""}`;
else if (state === "submitted") return import_picocolors.default.dim(label);
		return `${import_picocolors.default.dim(S_CHECKBOX_INACTIVE)} ${import_picocolors.default.dim(label)}`;
	};
	return new MultiSelectPrompt({
		options: opts.options,
		initialValues: opts.initialValues,
		required: opts.required ?? true,
		cursorAt: opts.cursorAt,
		validate(selected) {
			if (this.required && selected.length === 0) return `Please select at least one option.\n${import_picocolors.default.reset(import_picocolors.default.dim(`Press ${import_picocolors.default.gray(import_picocolors.default.bgWhite(import_picocolors.default.inverse(" space ")))} to select, ${import_picocolors.default.gray(import_picocolors.default.bgWhite(import_picocolors.default.inverse(" enter ")))} to submit`))}`;
		},
		render() {
			const title = `${import_picocolors.default.gray(S_BAR)}\n${symbol(this.state)}  ${opts.message}\n`;
			const styleOption = (option, active) => {
				const selected = this.value.includes(option.value);
				if (active && selected) return opt(option, "active-selected");
				if (selected) return opt(option, "selected");
				return opt(option, active ? "active" : "inactive");
			};
			switch (this.state) {
				case "submit": return `${title}${import_picocolors.default.gray(S_BAR)}  ${this.options.filter(({ value }) => this.value.includes(value)).map((option) => opt(option, "submitted")).join(import_picocolors.default.dim(", ")) || import_picocolors.default.dim("none")}`;
				case "cancel": {
					const label = this.options.filter(({ value }) => this.value.includes(value)).map((option) => opt(option, "cancelled")).join(import_picocolors.default.dim(", "));
					return `${title}${import_picocolors.default.gray(S_BAR)}  ${label.trim() ? `${label}\n${import_picocolors.default.gray(S_BAR)}` : ""}`;
				}
				case "error": {
					const footer = this.error.split("\n").map((ln, i$1) => i$1 === 0 ? `${import_picocolors.default.yellow(S_BAR_END)}  ${import_picocolors.default.yellow(ln)}` : `   ${ln}`).join("\n");
					return title + import_picocolors.default.yellow(S_BAR) + "  " + limitOptions({
						options: this.options,
						cursor: this.cursor,
						maxItems: opts.maxItems,
						style: styleOption
					}).join(`\n${import_picocolors.default.yellow(S_BAR)}  `) + "\n" + footer + "\n";
				}
				default: return `${title}${import_picocolors.default.cyan(S_BAR)}  ${limitOptions({
					options: this.options,
					cursor: this.cursor,
					maxItems: opts.maxItems,
					style: styleOption
				}).join(`\n${import_picocolors.default.cyan(S_BAR)}  `)}\n${import_picocolors.default.cyan(S_BAR_END)}\n`;
			}
		}
	}).prompt();
};
const strip = (str) => str.replace(ansiRegex(), "");
function buildBox(message = "", title = "", dimmed = true) {
	const lines = `\n${message}\n`.split("\n");
	const titleLen = strip(title).length;
	const len = Math.max(lines.reduce((sum, ln) => {
		ln = strip(ln);
		return ln.length > sum ? ln.length : sum;
	}, 0), titleLen) + 2;
	const msg = lines.map((ln) => `${import_picocolors.default.gray(S_BAR)}  ${dimmed ? import_picocolors.default.dim(ln) : ln}${" ".repeat(len - strip(ln).length)}${import_picocolors.default.gray(S_BAR)}`).join("\n");
	process$1.stdout.write(`${import_picocolors.default.gray(S_BAR)}\n${import_picocolors.default.green(S_STEP_SUBMIT)}  ${import_picocolors.default.reset(title)} ${import_picocolors.default.gray(S_BAR_H.repeat(Math.max(len - titleLen - 1, 1)) + S_CORNER_TOP_RIGHT)}\n${msg}\n${import_picocolors.default.gray(S_CONNECT_LEFT + S_BAR_H.repeat(len + 2) + S_CORNER_BOTTOM_RIGHT)}\n`);
}
const note = (message = "", title = "") => buildBox(message, title, true);
const box = (message = "", title = "") => buildBox(message, title, false);
const taskLog = (title) => {
	const BAR = import_picocolors.default.dim(S_BAR);
	const ACTIVE = import_picocolors.default.green(S_STEP_SUBMIT);
	const SUCCESS = import_picocolors.default.green(S_SUCCESS);
	const ERROR = import_picocolors.default.red(S_ERROR);
	process$1.stdout.write(`${BAR}\n`);
	process$1.stdout.write(`${ACTIVE}  ${title}\n`);
	let output = "";
	let frame = "";
	const clear = (eraseTitle = false) => {
		if (!frame) return;
		const terminalWidth = process$1.stdout.columns;
		const frameHeight = frame.split("\n").reduce((height, line) => {
			height += Math.ceil(line.length / terminalWidth);
			return height;
		}, 0);
		const lines = frameHeight + (eraseTitle ? 1 : 0);
		process$1.stdout.write(import_src.cursor.up(lines));
		process$1.stdout.write(import_src.erase.down());
	};
	const print$1 = (limit = 0) => {
		const lines = output.split("\n").slice(-limit);
		frame = "";
		for (const line of lines) frame += `${BAR}  ${line}\n`;
		process$1.stdout.write(import_picocolors.default.dim(frame));
	};
	return {
		set text(data$1) {
			clear();
			output += data$1;
			const frameHeight = Math.ceil(process$1.stdout.rows / 2);
			print$1(frameHeight);
		},
		fail(message) {
			clear(true);
			process$1.stdout.write(`${ERROR}  ${message}\n`);
			print$1();
		},
		success(message) {
			clear(true);
			process$1.stdout.write(`${SUCCESS}  ${message}\n`);
		}
	};
};
const cancel = (message = "") => {
	process$1.stdout.write(`${import_picocolors.default.gray(S_BAR_END)}  ${import_picocolors.default.red(message)}\n\n`);
};
const intro = (title = "") => {
	process$1.stdout.write(`${import_picocolors.default.gray(S_BAR_START)}  ${title}\n`);
};
const outro = (message = "") => {
	process$1.stdout.write(`${import_picocolors.default.gray(S_BAR)}\n${import_picocolors.default.gray(S_BAR_END)}  ${message}\n\n`);
};
const log = {
	message: (message = "", { symbol: symbol$1 = import_picocolors.default.gray(S_BAR) } = {}) => {
		const parts = [import_picocolors.default.gray(S_BAR)];
		if (message) {
			const [firstLine, ...lines] = message.split("\n");
			parts.push(`${symbol$1}  ${firstLine}`, ...lines.map((ln) => `${import_picocolors.default.gray(S_BAR)}  ${ln}`));
		}
		process$1.stdout.write(`${parts.join("\n")}\n`);
	},
	info: (message) => {
		log.message(message, { symbol: import_picocolors.default.blue(S_INFO) });
	},
	success: (message) => {
		log.message(message, { symbol: import_picocolors.default.green(S_SUCCESS) });
	},
	step: (message) => {
		log.message(message, { symbol: import_picocolors.default.green(S_STEP_SUBMIT) });
	},
	warn: (message) => {
		log.message(message, { symbol: import_picocolors.default.yellow(S_WARN) });
	},
	warning: (message) => {
		log.warn(message);
	},
	error: (message) => {
		log.message(message, { symbol: import_picocolors.default.red(S_ERROR) });
	}
};
const spinner = () => {
	const frames = unicode ? [
		"◒",
		"◐",
		"◓",
		"◑"
	] : [
		"•",
		"o",
		"O",
		"0"
	];
	const delay = unicode ? 80 : 120;
	let unblock;
	let loop;
	let isSpinnerActive = false;
	let _message = "";
	const handleExit = (code) => {
		const msg = code > 1 ? "Something went wrong" : "Canceled";
		if (isSpinnerActive) stop(msg, code);
	};
	const errorEventHandler = () => {
		handleExit(2);
	};
	const signalEventHandler = () => {
		handleExit(1);
	};
	const registerHooks = () => {
		process$1.on("uncaughtExceptionMonitor", errorEventHandler);
		process$1.on("unhandledRejection", errorEventHandler);
		process$1.on("SIGINT", signalEventHandler);
		process$1.on("SIGTERM", signalEventHandler);
		process$1.on("exit", handleExit);
	};
	const clearHooks = () => {
		process$1.removeListener("uncaughtExceptionMonitor", errorEventHandler);
		process$1.removeListener("unhandledRejection", errorEventHandler);
		process$1.removeListener("SIGINT", signalEventHandler);
		process$1.removeListener("SIGTERM", signalEventHandler);
		process$1.removeListener("exit", handleExit);
	};
	const start = (msg = "") => {
		isSpinnerActive = true;
		unblock = block();
		_message = msg.replace(/\.+$/, "");
		process$1.stdout.write(`${import_picocolors.default.gray(S_BAR)}\n`);
		let frameIndex = 0;
		let dotsTimer = 0;
		registerHooks();
		loop = setInterval(() => {
			const frame = import_picocolors.default.magenta(frames[frameIndex]);
			const loadingDots = ".".repeat(Math.floor(dotsTimer)).slice(0, 3);
			process$1.stdout.write(import_src.cursor.move(-999, 0));
			process$1.stdout.write(import_src.erase.down(1));
			process$1.stdout.write(`${frame}  ${_message}${loadingDots}`);
			frameIndex = frameIndex + 1 < frames.length ? frameIndex + 1 : 0;
			dotsTimer = dotsTimer < frames.length ? dotsTimer + .125 : 0;
		}, delay);
	};
	const stop = (msg = "", code = 0) => {
		_message = msg ?? _message;
		isSpinnerActive = false;
		clearInterval(loop);
		const step = code === 0 ? import_picocolors.default.green(S_STEP_SUBMIT) : code === 1 ? import_picocolors.default.red(S_STEP_CANCEL) : import_picocolors.default.red(S_STEP_ERROR);
		process$1.stdout.write(import_src.cursor.move(-999, 0));
		process$1.stdout.write(import_src.erase.down(1));
		process$1.stdout.write(`${step}  ${_message}\n`);
		clearHooks();
		unblock();
	};
	const message = (msg = "") => {
		_message = msg ?? _message;
	};
	return {
		start,
		stop,
		message
	};
};
function ansiRegex() {
	const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
	return new RegExp(pattern, "g");
}
const group = async (prompts, opts) => {
	const results = {};
	const promptNames = Object.keys(prompts);
	for (const name of promptNames) {
		const prompt = prompts[name];
		const result = await prompt({ results })?.catch((e) => {
			throw e;
		});
		if (typeof opts?.onCancel === "function" && isCancel(result)) {
			results[name] = "canceled";
			opts.onCancel({ results });
			continue;
		}
		results[name] = result;
	}
	return results;
};

//#endregion
//#region node_modules/.pnpm/tinyexec@0.3.2/node_modules/tinyexec/dist/main.js
const require$1 = createRequire$1(import.meta.url);
var St = Object.create;
var $ = Object.defineProperty;
var kt = Object.getOwnPropertyDescriptor;
var Tt = Object.getOwnPropertyNames;
var At = Object.getPrototypeOf, Rt = Object.prototype.hasOwnProperty;
var h = /* @__PURE__ */ ((t) => typeof require$1 < "u" ? require$1 : typeof Proxy < "u" ? new Proxy(t, { get: (e, n$1) => (typeof require$1 < "u" ? require$1 : e)[n$1] }) : t)(function(t) {
	if (typeof require$1 < "u") return require$1.apply(this, arguments);
	throw Error("Dynamic require of \"" + t + "\" is not supported");
});
var l$1 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var $t = (t, e, n$1, r) => {
	if (e && typeof e == "object" || typeof e == "function") for (let s$1 of Tt(e)) !Rt.call(t, s$1) && s$1 !== n$1 && $(t, s$1, {
		get: () => e[s$1],
		enumerable: !(r = kt(e, s$1)) || r.enumerable
	});
	return t;
};
var Nt = (t, e, n$1) => (n$1 = t != null ? St(At(t)) : {}, $t(
	// If the importer is in node compatibility mode or this is not an ESM
	// file that has been converted to a CommonJS file using a Babel-
	// compatible transform (i.e. "__esModule" has not been set), then set
	// "default" to the CommonJS "module.exports" for node compatibility.
	e || !t || !t.__esModule ? $(n$1, "default", {
		value: t,
		enumerable: !0
	}) : n$1,
	t
));
var W = l$1((Se, H) => {
	"use strict";
	H.exports = z;
	z.sync = Wt;
	var j = h("fs");
	function Ht(t, e) {
		var n$1 = e.pathExt !== void 0 ? e.pathExt : process.env.PATHEXT;
		if (!n$1 || (n$1 = n$1.split(";"), n$1.indexOf("") !== -1)) return !0;
		for (var r = 0; r < n$1.length; r++) {
			var s$1 = n$1[r].toLowerCase();
			if (s$1 && t.substr(-s$1.length).toLowerCase() === s$1) return !0;
		}
		return !1;
	}
	function F(t, e, n$1) {
		return !t.isSymbolicLink() && !t.isFile() ? !1 : Ht(e, n$1);
	}
	function z(t, e, n$1) {
		j.stat(t, function(r, s$1) {
			n$1(r, r ? !1 : F(s$1, t, e));
		});
	}
	function Wt(t, e) {
		return F(j.statSync(t), t, e);
	}
});
var X = l$1((ke, B) => {
	"use strict";
	B.exports = K;
	K.sync = Dt;
	var D = h("fs");
	function K(t, e, n$1) {
		D.stat(t, function(r, s$1) {
			n$1(r, r ? !1 : M(s$1, e));
		});
	}
	function Dt(t, e) {
		return M(D.statSync(t), e);
	}
	function M(t, e) {
		return t.isFile() && Kt(t, e);
	}
	function Kt(t, e) {
		var n$1 = t.mode, r = t.uid, s$1 = t.gid, o = e.uid !== void 0 ? e.uid : process.getuid && process.getuid(), i$1 = e.gid !== void 0 ? e.gid : process.getgid && process.getgid(), a = parseInt("100", 8), c$1 = parseInt("010", 8), u = parseInt("001", 8), f = a | c$1, p = n$1 & u || n$1 & c$1 && s$1 === i$1 || n$1 & a && r === o || n$1 & f && o === 0;
		return p;
	}
});
var U = l$1((Ae, G) => {
	"use strict";
	var Te = h("fs"), v;
	process.platform === "win32" || global.TESTING_WINDOWS ? v = W() : v = X();
	G.exports = y;
	y.sync = Mt;
	function y(t, e, n$1) {
		if (typeof e == "function" && (n$1 = e, e = {}), !n$1) {
			if (typeof Promise != "function") throw new TypeError("callback not provided");
			return new Promise(function(r, s$1) {
				y(t, e || {}, function(o, i$1) {
					o ? s$1(o) : r(i$1);
				});
			});
		}
		v(t, e || {}, function(r, s$1) {
			r && (r.code === "EACCES" || e && e.ignoreErrors) && (r = null, s$1 = !1), n$1(r, s$1);
		});
	}
	function Mt(t, e) {
		try {
			return v.sync(t, e || {});
		} catch (n$1) {
			if (e && e.ignoreErrors || n$1.code === "EACCES") return !1;
			throw n$1;
		}
	}
});
var et = l$1((Re, tt) => {
	"use strict";
	var g = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Y = h("path"), Bt = g ? ";" : ":", V = U(), J = (t) => Object.assign(new Error(`not found: ${t}`), { code: "ENOENT" }), Q = (t, e) => {
		let n$1 = e.colon || Bt, r = t.match(/\//) || g && t.match(/\\/) ? [""] : [...g ? [process.cwd()] : [], ...(e.path || process.env.PATH || "").split(n$1)], s$1 = g ? e.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o = g ? s$1.split(n$1) : [""];
		return g && t.indexOf(".") !== -1 && o[0] !== "" && o.unshift(""), {
			pathEnv: r,
			pathExt: o,
			pathExtExe: s$1
		};
	}, Z = (t, e, n$1) => {
		typeof e == "function" && (n$1 = e, e = {}), e || (e = {});
		let { pathEnv: r, pathExt: s$1, pathExtExe: o } = Q(t, e), i$1 = [], a = (u) => new Promise((f, p) => {
			if (u === r.length) return e.all && i$1.length ? f(i$1) : p(J(t));
			let d = r[u], w = /^".*"$/.test(d) ? d.slice(1, -1) : d, m = Y.join(w, t), b = !w && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + m : m;
			f(c$1(b, u, 0));
		}), c$1 = (u, f, p) => new Promise((d, w) => {
			if (p === s$1.length) return d(a(f + 1));
			let m = s$1[p];
			V(u + m, { pathExt: o }, (b, Ot) => {
				if (!b && Ot) if (e.all) i$1.push(u + m);
else return d(u + m);
				return d(c$1(u, f, p + 1));
			});
		});
		return n$1 ? a(0).then((u) => n$1(null, u), n$1) : a(0);
	}, Xt = (t, e) => {
		e = e || {};
		let { pathEnv: n$1, pathExt: r, pathExtExe: s$1 } = Q(t, e), o = [];
		for (let i$1 = 0; i$1 < n$1.length; i$1++) {
			let a = n$1[i$1], c$1 = /^".*"$/.test(a) ? a.slice(1, -1) : a, u = Y.join(c$1, t), f = !c$1 && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + u : u;
			for (let p = 0; p < r.length; p++) {
				let d = f + r[p];
				try {
					if (V.sync(d, { pathExt: s$1 })) if (e.all) o.push(d);
else return d;
				} catch {}
			}
		}
		if (e.all && o.length) return o;
		if (e.nothrow) return null;
		throw J(t);
	};
	tt.exports = Z;
	Z.sync = Xt;
});
var rt = l$1(($e, _) => {
	"use strict";
	var nt = (t = {}) => {
		let e = t.env || process.env;
		return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e).reverse().find((r) => r.toUpperCase() === "PATH") || "Path";
	};
	_.exports = nt;
	_.exports.default = nt;
});
var ct = l$1((Ne, it) => {
	"use strict";
	var st = h("path"), Gt = et(), Ut = rt();
	function ot(t, e) {
		let n$1 = t.options.env || process.env, r = process.cwd(), s$1 = t.options.cwd != null, o = s$1 && process.chdir !== void 0 && !process.chdir.disabled;
		if (o) try {
			process.chdir(t.options.cwd);
		} catch {}
		let i$1;
		try {
			i$1 = Gt.sync(t.command, {
				path: n$1[Ut({ env: n$1 })],
				pathExt: e ? st.delimiter : void 0
			});
		} catch {} finally {
			o && process.chdir(r);
		}
		return i$1 && (i$1 = st.resolve(s$1 ? t.options.cwd : "", i$1)), i$1;
	}
	function Yt(t) {
		return ot(t) || ot(t, !0);
	}
	it.exports = Yt;
});
var ut = l$1((qe, P) => {
	"use strict";
	var C = /([()\][%!^"`<>&|;, *?])/g;
	function Vt(t) {
		return t = t.replace(C, "^$1"), t;
	}
	function Jt(t, e) {
		return t = `${t}`, t = t.replace(/(\\*)"/g, "$1$1\\\""), t = t.replace(/(\\*)$/, "$1$1"), t = `"${t}"`, t = t.replace(C, "^$1"), e && (t = t.replace(C, "^$1")), t;
	}
	P.exports.command = Vt;
	P.exports.argument = Jt;
});
var lt = l$1((Ie, at) => {
	"use strict";
	at.exports = /^#!(.*)/;
});
var dt = l$1((Le, pt) => {
	"use strict";
	var Qt = lt();
	pt.exports = (t = "") => {
		let e = t.match(Qt);
		if (!e) return null;
		let [n$1, r] = e[0].replace(/#! ?/, "").split(" "), s$1 = n$1.split("/").pop();
		return s$1 === "env" ? r : r ? `${s$1} ${r}` : s$1;
	};
});
var ht = l$1((je, ft) => {
	"use strict";
	var O = h("fs"), Zt = dt();
	function te(t) {
		let n$1 = Buffer.alloc(150), r;
		try {
			r = O.openSync(t, "r"), O.readSync(r, n$1, 0, 150, 0), O.closeSync(r);
		} catch {}
		return Zt(n$1.toString());
	}
	ft.exports = te;
});
var wt = l$1((Fe, Et) => {
	"use strict";
	var ee = h("path"), mt = ct(), gt = ut(), ne = ht(), re = process.platform === "win32", se = /\.(?:com|exe)$/i, oe = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
	function ie(t) {
		t.file = mt(t);
		let e = t.file && ne(t.file);
		return e ? (t.args.unshift(t.file), t.command = e, mt(t)) : t.file;
	}
	function ce(t) {
		if (!re) return t;
		let e = ie(t), n$1 = !se.test(e);
		if (t.options.forceShell || n$1) {
			let r = oe.test(e);
			t.command = ee.normalize(t.command), t.command = gt.command(t.command), t.args = t.args.map((o) => gt.argument(o, r));
			let s$1 = [t.command].concat(t.args).join(" ");
			t.args = [
				"/d",
				"/s",
				"/c",
				`"${s$1}"`
			], t.command = process.env.comspec || "cmd.exe", t.options.windowsVerbatimArguments = !0;
		}
		return t;
	}
	function ue(t, e, n$1) {
		e && !Array.isArray(e) && (n$1 = e, e = null), e = e ? e.slice(0) : [], n$1 = Object.assign({}, n$1);
		let r = {
			command: t,
			args: e,
			options: n$1,
			file: void 0,
			original: {
				command: t,
				args: e
			}
		};
		return n$1.shell ? r : ce(r);
	}
	Et.exports = ue;
});
var bt = l$1((ze, vt) => {
	"use strict";
	var S = process.platform === "win32";
	function k(t, e) {
		return Object.assign(new Error(`${e} ${t.command} ENOENT`), {
			code: "ENOENT",
			errno: "ENOENT",
			syscall: `${e} ${t.command}`,
			path: t.command,
			spawnargs: t.args
		});
	}
	function ae(t, e) {
		if (!S) return;
		let n$1 = t.emit;
		t.emit = function(r, s$1) {
			if (r === "exit") {
				let o = xt(s$1, e, "spawn");
				if (o) return n$1.call(t, "error", o);
			}
			return n$1.apply(t, arguments);
		};
	}
	function xt(t, e) {
		return S && t === 1 && !e.file ? k(e.original, "spawn") : null;
	}
	function le(t, e) {
		return S && t === 1 && !e.file ? k(e.original, "spawnSync") : null;
	}
	vt.exports = {
		hookChildProcess: ae,
		verifyENOENT: xt,
		verifyENOENTSync: le,
		notFoundError: k
	};
});
var Ct = l$1((He, E) => {
	"use strict";
	var yt = h("child_process"), T = wt(), A = bt();
	function _t(t, e, n$1) {
		let r = T(t, e, n$1), s$1 = yt.spawn(r.command, r.args, r.options);
		return A.hookChildProcess(s$1, r), s$1;
	}
	function pe(t, e, n$1) {
		let r = T(t, e, n$1), s$1 = yt.spawnSync(r.command, r.args, r.options);
		return s$1.error = s$1.error || A.verifyENOENTSync(s$1.status, r), s$1;
	}
	E.exports = _t;
	E.exports.spawn = _t;
	E.exports.sync = pe;
	E.exports._parse = T;
	E.exports._enoent = A;
});
var Lt = /^path$/i, q = {
	key: "PATH",
	value: ""
};
function jt(t) {
	for (let e in t) {
		if (!Object.prototype.hasOwnProperty.call(t, e) || !Lt.test(e)) continue;
		let n$1 = t[e];
		return n$1 ? {
			key: e,
			value: n$1
		} : q;
	}
	return q;
}
function Ft(t, e) {
	let n$1 = e.value.split(delimiter), r = t, s$1;
	do 
		n$1.push(resolve$1(r, "node_modules", ".bin")), s$1 = r, r = dirname$1(r);
	while (r !== s$1);
	return {
		key: e.key,
		value: n$1.join(delimiter)
	};
}
function I(t, e) {
	let n$1 = {
		...process.env,
		...e
	}, r = Ft(t, jt(n$1));
	return n$1[r.key] = r.value, n$1;
}
var L = (t) => {
	let e = t.length, n$1 = new PassThrough(), r = () => {
		--e === 0 && n$1.emit("end");
	};
	for (let s$1 of t) s$1.pipe(n$1, { end: !1 }), s$1.on("end", r);
	return n$1;
};
var Pt = Nt(Ct(), 1);
var x = class extends Error {
	result;
	output;
	get exitCode() {
		if (this.result.exitCode !== null) return this.result.exitCode;
	}
	constructor(e, n$1) {
		super(`Process exited with non-zero status (${e.exitCode})`), this.result = e, this.output = n$1;
	}
};
var ge = {
	timeout: void 0,
	persist: !1
}, Ee = { windowsHide: !0 };
function we(t, e) {
	return {
		command: normalize(t),
		args: e ?? []
	};
}
function xe(t) {
	let e = new AbortController();
	for (let n$1 of t) {
		if (n$1.aborted) return e.abort(), n$1;
		let r = () => {
			e.abort(n$1.reason);
		};
		n$1.addEventListener("abort", r, { signal: e.signal });
	}
	return e.signal;
}
var R = class {
	_process;
	_aborted = !1;
	_options;
	_command;
	_args;
	_resolveClose;
	_processClosed;
	_thrownError;
	get process() {
		return this._process;
	}
	get pid() {
		return this._process?.pid;
	}
	get exitCode() {
		if (this._process && this._process.exitCode !== null) return this._process.exitCode;
	}
	constructor(e, n$1, r) {
		this._options = {
			...ge,
			...r
		}, this._command = e, this._args = n$1 ?? [], this._processClosed = new Promise((s$1) => {
			this._resolveClose = s$1;
		});
	}
	kill(e) {
		return this._process?.kill(e) === !0;
	}
	get aborted() {
		return this._aborted;
	}
	get killed() {
		return this._process?.killed === !0;
	}
	pipe(e, n$1, r) {
		return be(e, n$1, {
			...r,
			stdin: this
		});
	}
	async *[Symbol.asyncIterator]() {
		let e = this._process;
		if (!e) return;
		let n$1 = [];
		this._streamErr && n$1.push(this._streamErr), this._streamOut && n$1.push(this._streamOut);
		let r = L(n$1), s$1 = me.createInterface({ input: r });
		for await (let o of s$1) yield o.toString();
		if (await this._processClosed, e.removeAllListeners(), this._thrownError) throw this._thrownError;
		if (this._options?.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0) throw new x(this);
	}
	async _waitForOutput() {
		let e = this._process;
		if (!e) throw new Error("No process was started");
		let n$1 = "", r = "";
		if (this._streamOut) for await (let o of this._streamOut) r += o.toString();
		if (this._streamErr) for await (let o of this._streamErr) n$1 += o.toString();
		if (await this._processClosed, this._options?.stdin && await this._options.stdin, e.removeAllListeners(), this._thrownError) throw this._thrownError;
		let s$1 = {
			stderr: n$1,
			stdout: r,
			exitCode: this.exitCode
		};
		if (this._options.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0) throw new x(this, s$1);
		return s$1;
	}
	then(e, n$1) {
		return this._waitForOutput().then(e, n$1);
	}
	_streamOut;
	_streamErr;
	spawn() {
		let e = cwd(), n$1 = this._options, r = {
			...Ee,
			...n$1.nodeOptions
		}, s$1 = [];
		this._resetState(), n$1.timeout !== void 0 && s$1.push(AbortSignal.timeout(n$1.timeout)), n$1.signal !== void 0 && s$1.push(n$1.signal), n$1.persist === !0 && (r.detached = !0), s$1.length > 0 && (r.signal = xe(s$1)), r.env = I(e, r.env);
		let { command: o, args: i$1 } = we(this._command, this._args), a = (0, Pt._parse)(o, i$1, r), c$1 = spawn(a.command, a.args, a.options);
		if (c$1.stderr && (this._streamErr = c$1.stderr), c$1.stdout && (this._streamOut = c$1.stdout), this._process = c$1, c$1.once("error", this._onError), c$1.once("close", this._onClose), n$1.stdin !== void 0 && c$1.stdin && n$1.stdin.process) {
			let { stdout: u } = n$1.stdin.process;
			u && u.pipe(c$1.stdin);
		}
	}
	_resetState() {
		this._aborted = !1, this._processClosed = new Promise((e) => {
			this._resolveClose = e;
		}), this._thrownError = void 0;
	}
	_onError = (e) => {
		if (e.name === "AbortError" && (!(e.cause instanceof Error) || e.cause.name !== "TimeoutError")) {
			this._aborted = !0;
			return;
		}
		this._thrownError = e;
	};
	_onClose = () => {
		this._resolveClose && this._resolveClose();
	};
}, ve = (t, e, n$1) => {
	let r = new R(t, e, n$1);
	return r.spawn(), r;
}, be = ve;

//#endregion
//#region node_modules/.pnpm/package-manager-detector@0.2.11/node_modules/package-manager-detector/dist/commands.mjs
function npmRun(agent) {
	return (args) => {
		if (args.length > 1) return [
			agent,
			"run",
			args[0],
			"--",
			...args.slice(1)
		];
else return [
			agent,
			"run",
			args[0]
		];
	};
}
function denoExecute() {
	return (args) => {
		return [
			"deno",
			"run",
			`npm:${args[0]}`,
			...args.slice(1)
		];
	};
}
const npm = {
	"agent": ["npm", 0],
	"run": npmRun("npm"),
	"install": [
		"npm",
		"i",
		0
	],
	"frozen": [
		"npm",
		"ci",
		0
	],
	"global": [
		"npm",
		"i",
		"-g",
		0
	],
	"add": [
		"npm",
		"i",
		0
	],
	"upgrade": [
		"npm",
		"update",
		0
	],
	"upgrade-interactive": null,
	"execute": ["npx", 0],
	"execute-local": ["npx", 0],
	"uninstall": [
		"npm",
		"uninstall",
		0
	],
	"global_uninstall": [
		"npm",
		"uninstall",
		"-g",
		0
	]
};
const yarn = {
	"agent": ["yarn", 0],
	"run": [
		"yarn",
		"run",
		0
	],
	"install": [
		"yarn",
		"install",
		0
	],
	"frozen": [
		"yarn",
		"install",
		"--frozen-lockfile",
		0
	],
	"global": [
		"yarn",
		"global",
		"add",
		0
	],
	"add": [
		"yarn",
		"add",
		0
	],
	"upgrade": [
		"yarn",
		"upgrade",
		0
	],
	"upgrade-interactive": [
		"yarn",
		"upgrade-interactive",
		0
	],
	"execute": ["npx", 0],
	"execute-local": [
		"yarn",
		"exec",
		0
	],
	"uninstall": [
		"yarn",
		"remove",
		0
	],
	"global_uninstall": [
		"yarn",
		"global",
		"remove",
		0
	]
};
const yarnBerry = {
	...yarn,
	"frozen": [
		"yarn",
		"install",
		"--immutable",
		0
	],
	"upgrade": [
		"yarn",
		"up",
		0
	],
	"upgrade-interactive": [
		"yarn",
		"up",
		"-i",
		0
	],
	"execute": [
		"yarn",
		"dlx",
		0
	],
	"execute-local": [
		"yarn",
		"exec",
		0
	],
	"global": [
		"npm",
		"i",
		"-g",
		0
	],
	"global_uninstall": [
		"npm",
		"uninstall",
		"-g",
		0
	]
};
const pnpm = {
	"agent": ["pnpm", 0],
	"run": [
		"pnpm",
		"run",
		0
	],
	"install": [
		"pnpm",
		"i",
		0
	],
	"frozen": [
		"pnpm",
		"i",
		"--frozen-lockfile",
		0
	],
	"global": [
		"pnpm",
		"add",
		"-g",
		0
	],
	"add": [
		"pnpm",
		"add",
		0
	],
	"upgrade": [
		"pnpm",
		"update",
		0
	],
	"upgrade-interactive": [
		"pnpm",
		"update",
		"-i",
		0
	],
	"execute": [
		"pnpm",
		"dlx",
		0
	],
	"execute-local": [
		"pnpm",
		"exec",
		0
	],
	"uninstall": [
		"pnpm",
		"remove",
		0
	],
	"global_uninstall": [
		"pnpm",
		"remove",
		"--global",
		0
	]
};
const bun = {
	"agent": ["bun", 0],
	"run": [
		"bun",
		"run",
		0
	],
	"install": [
		"bun",
		"install",
		0
	],
	"frozen": [
		"bun",
		"install",
		"--frozen-lockfile",
		0
	],
	"global": [
		"bun",
		"add",
		"-g",
		0
	],
	"add": [
		"bun",
		"add",
		0
	],
	"upgrade": [
		"bun",
		"update",
		0
	],
	"upgrade-interactive": [
		"bun",
		"update",
		0
	],
	"execute": [
		"bun",
		"x",
		0
	],
	"execute-local": [
		"bun",
		"x",
		0
	],
	"uninstall": [
		"bun",
		"remove",
		0
	],
	"global_uninstall": [
		"bun",
		"remove",
		"-g",
		0
	]
};
const deno = {
	"agent": ["deno", 0],
	"run": [
		"deno",
		"task",
		0
	],
	"install": [
		"deno",
		"install",
		0
	],
	"frozen": [
		"deno",
		"install",
		"--frozen",
		0
	],
	"global": [
		"deno",
		"install",
		"-g",
		0
	],
	"add": [
		"deno",
		"add",
		0
	],
	"upgrade": [
		"deno",
		"outdated",
		"--update",
		0
	],
	"upgrade-interactive": [
		"deno",
		"outdated",
		"--update",
		0
	],
	"execute": denoExecute(),
	"execute-local": [
		"deno",
		"task",
		"--eval",
		0
	],
	"uninstall": [
		"deno",
		"remove",
		0
	],
	"global_uninstall": [
		"deno",
		"uninstall",
		"-g",
		0
	]
};
const COMMANDS = {
	"npm": npm,
	"yarn": yarn,
	"yarn@berry": yarnBerry,
	"pnpm": pnpm,
	"pnpm@6": {
		...pnpm,
		run: npmRun("pnpm")
	},
	"bun": bun,
	"deno": deno
};
function resolveCommand(agent, command, args) {
	const value = COMMANDS[agent][command];
	return constructCommand(value, args);
}
function constructCommand(value, args) {
	if (value == null) return null;
	const list$2 = typeof value === "function" ? value(args) : value.flatMap((v) => {
		if (typeof v === "number") return args;
		return [v];
	});
	return {
		command: list$2[0],
		args: list$2.slice(1)
	};
}

//#endregion
//#region node_modules/.pnpm/package-manager-detector@0.2.11/node_modules/package-manager-detector/dist/constants.mjs
const AGENTS = [
	"npm",
	"yarn",
	"yarn@berry",
	"pnpm",
	"pnpm@6",
	"bun",
	"deno"
];
const LOCKS = {
	"bun.lock": "bun",
	"bun.lockb": "bun",
	"deno.lock": "deno",
	"pnpm-lock.yaml": "pnpm",
	"yarn.lock": "yarn",
	"package-lock.json": "npm",
	"npm-shrinkwrap.json": "npm"
};

//#endregion
//#region node_modules/.pnpm/quansync@0.2.10/node_modules/quansync/dist/index.mjs
const GET_IS_ASYNC = Symbol.for("quansync.getIsAsync");
var QuansyncError = class extends Error {
	constructor(message = "Unexpected promise in sync context") {
		super(message);
		this.name = "QuansyncError";
	}
};
function isThenable(value) {
	return value && typeof value === "object" && typeof value.then === "function";
}
function isQuansyncGenerator(value) {
	return value && typeof value === "object" && typeof value[Symbol.iterator] === "function" && "__quansync" in value;
}
function fromObject(options) {
	const generator = function* (...args) {
		const isAsync = yield GET_IS_ASYNC;
		if (isAsync) return yield options.async.apply(this, args);
		return options.sync.apply(this, args);
	};
	function fn(...args) {
		const iter = generator.apply(this, args);
		iter.then = (...thenArgs) => options.async.apply(this, args).then(...thenArgs);
		iter.__quansync = true;
		return iter;
	}
	fn.sync = options.sync;
	fn.async = options.async;
	return fn;
}
function fromPromise(promise) {
	return fromObject({
		async: () => Promise.resolve(promise),
		sync: () => {
			if (isThenable(promise)) throw new QuansyncError();
			return promise;
		}
	});
}
function unwrapYield(value, isAsync) {
	if (value === GET_IS_ASYNC) return isAsync;
	if (isQuansyncGenerator(value)) return isAsync ? iterateAsync(value) : iterateSync(value);
	if (!isAsync && isThenable(value)) throw new QuansyncError();
	return value;
}
const DEFAULT_ON_YIELD = (value) => value;
function iterateSync(generator, onYield = DEFAULT_ON_YIELD) {
	let current = generator.next();
	while (!current.done) try {
		current = generator.next(unwrapYield(onYield(current.value, false)));
	} catch (err) {
		current = generator.throw(err);
	}
	return unwrapYield(current.value);
}
async function iterateAsync(generator, onYield = DEFAULT_ON_YIELD) {
	let current = generator.next();
	while (!current.done) try {
		current = generator.next(await unwrapYield(onYield(current.value, true), true));
	} catch (err) {
		current = generator.throw(err);
	}
	return current.value;
}
function fromGeneratorFn(generatorFn, options) {
	return fromObject({
		name: generatorFn.name,
		async(...args) {
			return iterateAsync(generatorFn.apply(this, args), options?.onYield);
		},
		sync(...args) {
			return iterateSync(generatorFn.apply(this, args), options?.onYield);
		}
	});
}
function quansync$1(input, options) {
	if (isThenable(input)) return fromPromise(input);
	if (typeof input === "function") return fromGeneratorFn(input, options);
else return fromObject(input);
}
const getIsAsync = quansync$1({
	async: () => Promise.resolve(true),
	sync: () => false
});

//#endregion
//#region node_modules/.pnpm/quansync@0.2.10/node_modules/quansync/dist/macro.mjs
const quansync = quansync$1;

//#endregion
//#region node_modules/.pnpm/package-manager-detector@0.2.11/node_modules/package-manager-detector/dist/detect.mjs
const isFile = quansync({
	sync: (path2) => {
		try {
			return fs.statSync(path2).isFile();
		} catch {
			return false;
		}
	},
	async: async (path2) => {
		try {
			return (await fs.promises.stat(path2)).isFile();
		} catch {
			return false;
		}
	}
});
function* lookup(cwd$1 = process$1.cwd()) {
	let directory = path.resolve(cwd$1);
	const { root: root$1 } = path.parse(directory);
	while (directory && directory !== root$1) {
		yield directory;
		directory = path.dirname(directory);
	}
}
const parsePackageJson = quansync(function* (filepath, onUnknown) {
	return !filepath || !(yield isFile(filepath)) ? null : handlePackageManager(filepath, onUnknown);
});
const detect = quansync(function* (options = {}) {
	const { cwd: cwd$1, onUnknown } = options;
	for (const directory of lookup(cwd$1)) {
		for (const lock of Object.keys(LOCKS)) if (yield isFile(path.join(directory, lock))) {
			const name = LOCKS[lock];
			const result2 = yield parsePackageJson(path.join(directory, "package.json"), onUnknown);
			if (result2) return result2;
else return {
				name,
				agent: name
			};
		}
		const result = yield parsePackageJson(path.join(directory, "package.json"), onUnknown);
		if (result) return result;
	}
	return null;
});
const detectSync = detect.sync;
function handlePackageManager(filepath, onUnknown) {
	try {
		const pkg = JSON.parse(fs.readFileSync(filepath, "utf8"));
		let agent;
		if (typeof pkg.packageManager === "string") {
			const [name, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
			let version$1 = ver;
			if (name === "yarn" && Number.parseInt(ver) > 1) {
				agent = "yarn@berry";
				version$1 = "berry";
				return {
					name,
					agent,
					version: version$1
				};
			} else if (name === "pnpm" && Number.parseInt(ver) < 7) {
				agent = "pnpm@6";
				return {
					name,
					agent,
					version: version$1
				};
			} else if (AGENTS.includes(name)) {
				agent = name;
				return {
					name,
					agent,
					version: version$1
				};
			} else return onUnknown?.(pkg.packageManager) ?? null;
		}
	} catch {}
	return null;
}

//#endregion
//#region node_modules/.pnpm/empathic@1.0.0/node_modules/empathic/resolve.mjs
function absolute(input, root$1) {
	return isAbsolute(input) ? input : resolve(root$1 || ".", input);
}
function from(root$1, ident, silent) {
	try {
		let r = root$1 instanceof URL || root$1.startsWith("file://") ? join(fileURLToPath(root$1), "noop.js") : join(absolute(root$1), "noop.js");
		return createRequire$1(r).resolve(ident);
	} catch (err) {
		if (!silent) throw err;
	}
}

//#endregion
//#region node_modules/.pnpm/empathic@1.0.0/node_modules/empathic/walk.mjs
function up$1(base, options) {
	let { stop, cwd: cwd$1 } = options || {};
	let tmp = absolute(base, cwd$1), root$1 = !stop;
	let prev, arr = [];
	if (stop) stop = absolute(stop, cwd$1);
	while (root$1 || tmp !== stop) {
		arr.push(tmp);
		tmp = dirname(prev = tmp);
		if (tmp === prev) break;
	}
	return arr;
}

//#endregion
//#region node_modules/.pnpm/empathic@1.0.0/node_modules/empathic/find.mjs
function up(name, options) {
	let dir, tmp;
	let start = options && options.cwd || "";
	for (dir of up$1(start, options)) {
		tmp = join(dir, name);
		if (existsSync(tmp)) return tmp;
	}
}

//#endregion
//#region packages/core/dist/tooling-orV6i6rP.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
};
var __copyProps = (to, from$1, except, desc) => {
	if (from$1 && typeof from$1 === "object" || typeof from$1 === "function") for (var keys$1 = __getOwnPropNames(from$1), i$1 = 0, n$1 = keys$1.length, key; i$1 < n$1; i$1++) {
		key = keys$1[i$1];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from$1[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from$1, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ createRequire(import.meta.url);
var require_picocolors = __commonJS({ "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports$1, module) {
	let p = process || {}, argv = p.argv || [], env$1 = p.env || {};
	let isColorSupported = !(!!env$1.NO_COLOR || argv.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI);
	let formatter = (open, close, replace = open) => (input) => {
		let string = "" + input, index = string.indexOf(close, open.length);
		return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	};
	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index);
		return result + string.substring(cursor);
	};
	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m")
		};
	};
	module.exports = createColors();
	module.exports.createColors = createColors;
} });
var walk_exports = {};
__export(walk_exports, { walk: () => walk });
function walk(node, state, visitors) {
	const universal = visitors._;
	let stopped = false;
	/** @type {import('./types').Visitor<T, U, T>} _ */
	function default_visitor(_, { next, state: state$1 }) {
		next(state$1);
	}
	/**
	* @param {T} node
	* @param {T[]} path
	* @param {U} state
	* @returns {T | undefined}
	*/
	function visit(node$1, path$2, state$1) {
		if (stopped) return;
		if (!node$1.type) return;
		/** @type {T | void} */
		let result;
		/** @type {Record<string, any>} */
		const mutations = {};
		/** @type {import('./types').Context<T, U>} */
		const context = {
			path: path$2,
			state: state$1,
			next: (next_state = state$1) => {
				path$2.push(node$1);
				for (const key in node$1) {
					if (key === "type") continue;
					const child_node = node$1[key];
					if (child_node && typeof child_node === "object") if (Array.isArray(child_node)) {
						/** @type {Record<number, T>} */
						const array_mutations = {};
						child_node.forEach((node$2, i$1) => {
							if (node$2 && typeof node$2 === "object") {
								const result$1 = visit(node$2, path$2, next_state);
								if (result$1) array_mutations[i$1] = result$1;
							}
						});
						if (Object.keys(array_mutations).length > 0) mutations[key] = child_node.map((node$2, i$1) => array_mutations[i$1] ?? node$2);
					} else {
						const result$1 = visit(child_node, path$2, next_state);
						if (result$1) mutations[key] = result$1;
					}
				}
				path$2.pop();
				if (Object.keys(mutations).length > 0) return apply_mutations(node$1, mutations);
			},
			stop: () => {
				stopped = true;
			},
			visit: (next_node, next_state = state$1) => {
				path$2.push(node$1);
				const result$1 = visit(next_node, path$2, next_state) ?? next_node;
				path$2.pop();
				return result$1;
			}
		};
		let visitor = visitors[node$1.type] ?? default_visitor;
		if (universal) {
			/** @type {T | void} */
			let inner_result;
			result = universal(node$1, {
				...context,
				next: (next_state = state$1) => {
					state$1 = next_state;
					inner_result = visitor(node$1, {
						...context,
						state: next_state
					});
					return inner_result;
				}
			});
			if (!result && inner_result) result = inner_result;
		} else result = visitor(node$1, context);
		if (!result) {
			if (Object.keys(mutations).length > 0) result = apply_mutations(node$1, mutations);
		}
		if (result) return result;
	}
	return visit(node, [], state) ?? node;
}
/**
* @template {Record<string, any>} T
* @param {T} node
* @param {Record<string, any>} mutations
* @returns {T}
*/
function apply_mutations(node, mutations) {
	/** @type {Record<string, any>} */
	const obj = {};
	const descriptors = Object.getOwnPropertyDescriptors(node);
	for (const key in descriptors) Object.defineProperty(obj, key, descriptors[key]);
	for (const key in mutations) obj[key] = mutations[key];
	return obj;
}
var esm_exports = {};
__export(esm_exports, {
	CDATA: () => CDATA$1,
	Comment: () => Comment$7,
	Directive: () => Directive,
	Doctype: () => Doctype,
	ElementType: () => ElementType,
	Root: () => Root$8,
	Script: () => Script,
	Style: () => Style,
	Tag: () => Tag,
	Text: () => Text$1,
	isTag: () => isTag$1
});
var ElementType;
(function(ElementType$1) {
	/** Type for the root element of a document */
	ElementType$1["Root"] = "root";
	/** Type for Text */
	ElementType$1["Text"] = "text";
	/** Type for <? ... ?> */
	ElementType$1["Directive"] = "directive";
	/** Type for <!-- ... --> */
	ElementType$1["Comment"] = "comment";
	/** Type for <script> tags */
	ElementType$1["Script"] = "script";
	/** Type for <style> tags */
	ElementType$1["Style"] = "style";
	/** Type for Any tag */
	ElementType$1["Tag"] = "tag";
	/** Type for <![CDATA[ ... ]]> */
	ElementType$1["CDATA"] = "cdata";
	/** Type for <!doctype ...> */
	ElementType$1["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag$1(elem) {
	return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
const Root$8 = ElementType.Root;
const Text$1 = ElementType.Text;
const Directive = ElementType.Directive;
const Comment$7 = ElementType.Comment;
const Script = ElementType.Script;
const Style = ElementType.Style;
const Tag = ElementType.Tag;
const CDATA$1 = ElementType.CDATA;
const Doctype = ElementType.Doctype;
var Node$7 = class {
	constructor() {
		/** Parent of the node */
		this.parent = null;
		/** Previous sibling */
		this.prev = null;
		/** Next sibling */
		this.next = null;
		/** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
		this.startIndex = null;
		/** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
		this.endIndex = null;
	}
	/**
	* Same as {@link parent}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get parentNode() {
		return this.parent;
	}
	set parentNode(parent) {
		this.parent = parent;
	}
	/**
	* Same as {@link prev}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get previousSibling() {
		return this.prev;
	}
	set previousSibling(prev) {
		this.prev = prev;
	}
	/**
	* Same as {@link next}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get nextSibling() {
		return this.next;
	}
	set nextSibling(next) {
		this.next = next;
	}
	/**
	* Clone this node, and optionally its children.
	*
	* @param recursive Clone child nodes as well.
	* @returns A clone of the node.
	*/
	cloneNode(recursive = false) {
		return cloneNode$1(this, recursive);
	}
};
var DataNode = class extends Node$7 {
	/**
	* @param data The content of the data node
	*/
	constructor(data$1) {
		super();
		this.data = data$1;
	}
	/**
	* Same as {@link data}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get nodeValue() {
		return this.data;
	}
	set nodeValue(data$1) {
		this.data = data$1;
	}
};
var Text = class extends DataNode {
	constructor() {
		super(...arguments);
		this.type = ElementType.Text;
	}
	get nodeType() {
		return 3;
	}
};
var Comment$6 = class extends DataNode {
	constructor() {
		super(...arguments);
		this.type = ElementType.Comment;
	}
	get nodeType() {
		return 8;
	}
};
var ProcessingInstruction = class extends DataNode {
	constructor(name, data$1) {
		super(data$1);
		this.name = name;
		this.type = ElementType.Directive;
	}
	get nodeType() {
		return 1;
	}
};
var NodeWithChildren = class extends Node$7 {
	/**
	* @param children Children of the node. Only certain node types can have children.
	*/
	constructor(children) {
		super();
		this.children = children;
	}
	/** First child of the node. */
	get firstChild() {
		var _a$1;
		return (_a$1 = this.children[0]) !== null && _a$1 !== void 0 ? _a$1 : null;
	}
	/** Last child of the node. */
	get lastChild() {
		return this.children.length > 0 ? this.children[this.children.length - 1] : null;
	}
	/**
	* Same as {@link children}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get childNodes() {
		return this.children;
	}
	set childNodes(children) {
		this.children = children;
	}
};
var CDATA = class extends NodeWithChildren {
	constructor() {
		super(...arguments);
		this.type = ElementType.CDATA;
	}
	get nodeType() {
		return 4;
	}
};
var Document$5 = class extends NodeWithChildren {
	constructor() {
		super(...arguments);
		this.type = ElementType.Root;
	}
	get nodeType() {
		return 9;
	}
};
var Element = class extends NodeWithChildren {
	/**
	* @param name Name of the tag, eg. `div`, `span`.
	* @param attribs Object mapping attribute names to attribute values.
	* @param children Children of the node.
	*/
	constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
		super(children);
		this.name = name;
		this.attribs = attribs;
		this.type = type;
	}
	get nodeType() {
		return 1;
	}
	/**
	* Same as {@link name}.
	* [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	*/
	get tagName() {
		return this.name;
	}
	set tagName(name) {
		this.name = name;
	}
	get attributes() {
		return Object.keys(this.attribs).map((name) => {
			var _a$1, _b;
			return {
				name,
				value: this.attribs[name],
				namespace: (_a$1 = this["x-attribsNamespace"]) === null || _a$1 === void 0 ? void 0 : _a$1[name],
				prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
			};
		});
	}
};
function isTag(node) {
	return isTag$1(node);
}
function isCDATA(node) {
	return node.type === ElementType.CDATA;
}
function isText(node) {
	return node.type === ElementType.Text;
}
function isComment(node) {
	return node.type === ElementType.Comment;
}
function isDirective(node) {
	return node.type === ElementType.Directive;
}
function isDocument(node) {
	return node.type === ElementType.Root;
}
function cloneNode$1(node, recursive = false) {
	let result;
	if (isText(node)) result = new Text(node.data);
else if (isComment(node)) result = new Comment$6(node.data);
else if (isTag(node)) {
		const children = recursive ? cloneChildren(node.children) : [];
		const clone = new Element(node.name, { ...node.attribs }, children);
		children.forEach((child) => child.parent = clone);
		if (node.namespace != null) clone.namespace = node.namespace;
		if (node["x-attribsNamespace"]) clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
		if (node["x-attribsPrefix"]) clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
		result = clone;
	} else if (isCDATA(node)) {
		const children = recursive ? cloneChildren(node.children) : [];
		const clone = new CDATA(children);
		children.forEach((child) => child.parent = clone);
		result = clone;
	} else if (isDocument(node)) {
		const children = recursive ? cloneChildren(node.children) : [];
		const clone = new Document$5(children);
		children.forEach((child) => child.parent = clone);
		if (node["x-mode"]) clone["x-mode"] = node["x-mode"];
		result = clone;
	} else if (isDirective(node)) {
		const instruction = new ProcessingInstruction(node.name, node.data);
		if (node["x-name"] != null) {
			instruction["x-name"] = node["x-name"];
			instruction["x-publicId"] = node["x-publicId"];
			instruction["x-systemId"] = node["x-systemId"];
		}
		result = instruction;
	} else throw new Error(`Not implemented yet: ${node.type}`);
	result.startIndex = node.startIndex;
	result.endIndex = node.endIndex;
	if (node.sourceCodeLocation != null) result.sourceCodeLocation = node.sourceCodeLocation;
	return result;
}
function cloneChildren(childs) {
	const children = childs.map((child) => cloneNode$1(child, true));
	for (let i$1 = 1; i$1 < children.length; i$1++) {
		children[i$1].prev = children[i$1 - 1];
		children[i$1 - 1].next = children[i$1];
	}
	return children;
}
const defaultOpts = {
	withStartIndices: false,
	withEndIndices: false,
	xmlMode: false
};
var DomHandler = class {
	/**
	* @param callback Called once parsing has completed.
	* @param options Settings for the handler.
	* @param elementCB Callback whenever a tag is closed.
	*/
	constructor(callback, options, elementCB) {
		/** The elements of the DOM */
		this.dom = [];
		/** The root element for the DOM */
		this.root = new Document$5(this.dom);
		/** Indicated whether parsing has been completed. */
		this.done = false;
		/** Stack of open tags. */
		this.tagStack = [this.root];
		/** A data node that is still being written to. */
		this.lastNode = null;
		/** Reference to the parser instance. Used for location information. */
		this.parser = null;
		if (typeof options === "function") {
			elementCB = options;
			options = defaultOpts;
		}
		if (typeof callback === "object") {
			options = callback;
			callback = undefined;
		}
		this.callback = callback !== null && callback !== void 0 ? callback : null;
		this.options = options !== null && options !== void 0 ? options : defaultOpts;
		this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
	}
	onparserinit(parser) {
		this.parser = parser;
	}
	onreset() {
		this.dom = [];
		this.root = new Document$5(this.dom);
		this.done = false;
		this.tagStack = [this.root];
		this.lastNode = null;
		this.parser = null;
	}
	onend() {
		if (this.done) return;
		this.done = true;
		this.parser = null;
		this.handleCallback(null);
	}
	onerror(error) {
		this.handleCallback(error);
	}
	onclosetag() {
		this.lastNode = null;
		const elem = this.tagStack.pop();
		if (this.options.withEndIndices) elem.endIndex = this.parser.endIndex;
		if (this.elementCB) this.elementCB(elem);
	}
	onopentag(name, attribs) {
		const type = this.options.xmlMode ? ElementType.Tag : undefined;
		const element = new Element(name, attribs, undefined, type);
		this.addNode(element);
		this.tagStack.push(element);
	}
	ontext(data$1) {
		const { lastNode } = this;
		if (lastNode && lastNode.type === ElementType.Text) {
			lastNode.data += data$1;
			if (this.options.withEndIndices) lastNode.endIndex = this.parser.endIndex;
		} else {
			const node = new Text(data$1);
			this.addNode(node);
			this.lastNode = node;
		}
	}
	oncomment(data$1) {
		if (this.lastNode && this.lastNode.type === ElementType.Comment) {
			this.lastNode.data += data$1;
			return;
		}
		const node = new Comment$6(data$1);
		this.addNode(node);
		this.lastNode = node;
	}
	oncommentend() {
		this.lastNode = null;
	}
	oncdatastart() {
		const text$1 = new Text("");
		const node = new CDATA([text$1]);
		this.addNode(node);
		text$1.parent = node;
		this.lastNode = text$1;
	}
	oncdataend() {
		this.lastNode = null;
	}
	onprocessinginstruction(name, data$1) {
		const node = new ProcessingInstruction(name, data$1);
		this.addNode(node);
	}
	handleCallback(error) {
		if (typeof this.callback === "function") this.callback(error, this.dom);
else if (error) throw error;
	}
	addNode(node) {
		const parent = this.tagStack[this.tagStack.length - 1];
		const previousSibling = parent.children[parent.children.length - 1];
		if (this.options.withStartIndices) node.startIndex = this.parser.startIndex;
		if (this.options.withEndIndices) node.endIndex = this.parser.endIndex;
		parent.children.push(node);
		if (previousSibling) {
			node.prev = previousSibling;
			previousSibling.next = node;
		}
		node.parent = parent;
		this.lastNode = null;
	}
};
var decode_data_html_default = new Uint16Array(
	// prettier-ignore
	"ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻\"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻\xA0ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌".split("").map((c$1) => c$1.charCodeAt(0))
);
var decode_data_xml_default = new Uint16Array(
	// prettier-ignore
	"Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c$1) => c$1.charCodeAt(0))
);
var _a;
const decodeMap = new Map([
	[0, 65533],
	[128, 8364],
	[130, 8218],
	[131, 402],
	[132, 8222],
	[133, 8230],
	[134, 8224],
	[135, 8225],
	[136, 710],
	[137, 8240],
	[138, 352],
	[139, 8249],
	[140, 338],
	[142, 381],
	[145, 8216],
	[146, 8217],
	[147, 8220],
	[148, 8221],
	[149, 8226],
	[150, 8211],
	[151, 8212],
	[152, 732],
	[153, 8482],
	[154, 353],
	[155, 8250],
	[156, 339],
	[158, 382],
	[159, 376]
]);
const fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
	let output = "";
	if (codePoint > 65535) {
		codePoint -= 65536;
		output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
		codePoint = 56320 | codePoint & 1023;
	}
	output += String.fromCharCode(codePoint);
	return output;
};
function replaceCodePoint(codePoint) {
	var _a$1;
	if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) return 65533;
	return (_a$1 = decodeMap.get(codePoint)) !== null && _a$1 !== void 0 ? _a$1 : codePoint;
}
var CharCodes$1;
(function(CharCodes$2) {
	CharCodes$2[CharCodes$2["NUM"] = 35] = "NUM";
	CharCodes$2[CharCodes$2["SEMI"] = 59] = "SEMI";
	CharCodes$2[CharCodes$2["EQUALS"] = 61] = "EQUALS";
	CharCodes$2[CharCodes$2["ZERO"] = 48] = "ZERO";
	CharCodes$2[CharCodes$2["NINE"] = 57] = "NINE";
	CharCodes$2[CharCodes$2["LOWER_A"] = 97] = "LOWER_A";
	CharCodes$2[CharCodes$2["LOWER_F"] = 102] = "LOWER_F";
	CharCodes$2[CharCodes$2["LOWER_X"] = 120] = "LOWER_X";
	CharCodes$2[CharCodes$2["LOWER_Z"] = 122] = "LOWER_Z";
	CharCodes$2[CharCodes$2["UPPER_A"] = 65] = "UPPER_A";
	CharCodes$2[CharCodes$2["UPPER_F"] = 70] = "UPPER_F";
	CharCodes$2[CharCodes$2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes$1 || (CharCodes$1 = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags$1) {
	BinTrieFlags$1[BinTrieFlags$1["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
	BinTrieFlags$1[BinTrieFlags$1["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
	BinTrieFlags$1[BinTrieFlags$1["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
	return code >= CharCodes$1.ZERO && code <= CharCodes$1.NINE;
}
function isHexadecimalCharacter(code) {
	return code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_F || code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
	return code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_Z || code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_Z || isNumber(code);
}
/**
* Checks if the given character is a valid end character for an entity in an attribute.
*
* Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
* See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
*/
function isEntityInAttributeInvalidEnd(code) {
	return code === CharCodes$1.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState$1) {
	EntityDecoderState$1[EntityDecoderState$1["EntityStart"] = 0] = "EntityStart";
	EntityDecoderState$1[EntityDecoderState$1["NumericStart"] = 1] = "NumericStart";
	EntityDecoderState$1[EntityDecoderState$1["NumericDecimal"] = 2] = "NumericDecimal";
	EntityDecoderState$1[EntityDecoderState$1["NumericHex"] = 3] = "NumericHex";
	EntityDecoderState$1[EntityDecoderState$1["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode$1) {
	/** Entities in text nodes that can end with any character. */
	DecodingMode$1[DecodingMode$1["Legacy"] = 0] = "Legacy";
	/** Only allow entities terminated with a semicolon. */
	DecodingMode$1[DecodingMode$1["Strict"] = 1] = "Strict";
	/** Entities in attributes have limitations on ending characters. */
	DecodingMode$1[DecodingMode$1["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
	constructor(decodeTree, emitCodePoint, errors) {
		this.decodeTree = decodeTree;
		this.emitCodePoint = emitCodePoint;
		this.errors = errors;
		/** The current state of the decoder. */
		this.state = EntityDecoderState.EntityStart;
		/** Characters that were consumed while parsing an entity. */
		this.consumed = 1;
		/**
		* The result of the entity.
		*
		* Either the result index of a numeric entity, or the codepoint of a
		* numeric entity.
		*/
		this.result = 0;
		/** The current index in the decode tree. */
		this.treeIndex = 0;
		/** The number of characters that were consumed in excess. */
		this.excess = 1;
		/** The mode in which the decoder is operating. */
		this.decodeMode = DecodingMode.Strict;
	}
	/** Resets the instance to make it reusable. */
	startEntity(decodeMode) {
		this.decodeMode = decodeMode;
		this.state = EntityDecoderState.EntityStart;
		this.result = 0;
		this.treeIndex = 0;
		this.excess = 1;
		this.consumed = 1;
	}
	/**
	* Write an entity to the decoder. This can be called multiple times with partial entities.
	* If the entity is incomplete, the decoder will return -1.
	*
	* Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
	* entity is incomplete, and resume when the next string is written.
	*
	* @param string The string containing the entity (or a continuation of the entity).
	* @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	write(str, offset) {
		switch (this.state) {
			case EntityDecoderState.EntityStart: {
				if (str.charCodeAt(offset) === CharCodes$1.NUM) {
					this.state = EntityDecoderState.NumericStart;
					this.consumed += 1;
					return this.stateNumericStart(str, offset + 1);
				}
				this.state = EntityDecoderState.NamedEntity;
				return this.stateNamedEntity(str, offset);
			}
			case EntityDecoderState.NumericStart: return this.stateNumericStart(str, offset);
			case EntityDecoderState.NumericDecimal: return this.stateNumericDecimal(str, offset);
			case EntityDecoderState.NumericHex: return this.stateNumericHex(str, offset);
			case EntityDecoderState.NamedEntity: return this.stateNamedEntity(str, offset);
		}
	}
	/**
	* Switches between the numeric decimal and hexadecimal states.
	*
	* Equivalent to the `Numeric character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericStart(str, offset) {
		if (offset >= str.length) return -1;
		if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
			this.state = EntityDecoderState.NumericHex;
			this.consumed += 1;
			return this.stateNumericHex(str, offset + 1);
		}
		this.state = EntityDecoderState.NumericDecimal;
		return this.stateNumericDecimal(str, offset);
	}
	addToNumericResult(str, start, end, base) {
		if (start !== end) {
			const digitCount = end - start;
			this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
			this.consumed += digitCount;
		}
	}
	/**
	* Parses a hexadecimal numeric entity.
	*
	* Equivalent to the `Hexademical character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericHex(str, offset) {
		const startIdx = offset;
		while (offset < str.length) {
			const char = str.charCodeAt(offset);
			if (isNumber(char) || isHexadecimalCharacter(char)) offset += 1;
else {
				this.addToNumericResult(str, startIdx, offset, 16);
				return this.emitNumericEntity(char, 3);
			}
		}
		this.addToNumericResult(str, startIdx, offset, 16);
		return -1;
	}
	/**
	* Parses a decimal numeric entity.
	*
	* Equivalent to the `Decimal character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNumericDecimal(str, offset) {
		const startIdx = offset;
		while (offset < str.length) {
			const char = str.charCodeAt(offset);
			if (isNumber(char)) offset += 1;
else {
				this.addToNumericResult(str, startIdx, offset, 10);
				return this.emitNumericEntity(char, 2);
			}
		}
		this.addToNumericResult(str, startIdx, offset, 10);
		return -1;
	}
	/**
	* Validate and emit a numeric entity.
	*
	* Implements the logic from the `Hexademical character reference start
	* state` and `Numeric character reference end state` in the HTML spec.
	*
	* @param lastCp The last code point of the entity. Used to see if the
	*               entity was terminated with a semicolon.
	* @param expectedLength The minimum number of characters that should be
	*                       consumed. Used to validate that at least one digit
	*                       was consumed.
	* @returns The number of characters that were consumed.
	*/
	emitNumericEntity(lastCp, expectedLength) {
		var _a$1;
		if (this.consumed <= expectedLength) {
			(_a$1 = this.errors) === null || _a$1 === void 0 ? void 0 : _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
			return 0;
		}
		if (lastCp === CharCodes$1.SEMI) this.consumed += 1;
else if (this.decodeMode === DecodingMode.Strict) return 0;
		this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
		if (this.errors) {
			if (lastCp !== CharCodes$1.SEMI) this.errors.missingSemicolonAfterCharacterReference();
			this.errors.validateNumericCharacterReference(this.result);
		}
		return this.consumed;
	}
	/**
	* Parses a named entity.
	*
	* Equivalent to the `Named character reference state` in the HTML spec.
	*
	* @param str The string containing the entity (or a continuation of the entity).
	* @param offset The current offset.
	* @returns The number of characters that were consumed, or -1 if the entity is incomplete.
	*/
	stateNamedEntity(str, offset) {
		const { decodeTree } = this;
		let current = decodeTree[this.treeIndex];
		let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
		for (; offset < str.length; offset++, this.excess++) {
			const char = str.charCodeAt(offset);
			this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
			if (this.treeIndex < 0) return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
			current = decodeTree[this.treeIndex];
			valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			if (valueLength !== 0) {
				if (char === CharCodes$1.SEMI) return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
				if (this.decodeMode !== DecodingMode.Strict) {
					this.result = this.treeIndex;
					this.consumed += this.excess;
					this.excess = 0;
				}
			}
		}
		return -1;
	}
	/**
	* Emit a named entity that was not terminated with a semicolon.
	*
	* @returns The number of characters consumed.
	*/
	emitNotTerminatedNamedEntity() {
		var _a$1;
		const { result, decodeTree } = this;
		const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
		this.emitNamedEntityData(result, valueLength, this.consumed);
		(_a$1 = this.errors) === null || _a$1 === void 0 ? void 0 : _a$1.missingSemicolonAfterCharacterReference();
		return this.consumed;
	}
	/**
	* Emit a named entity.
	*
	* @param result The index of the entity in the decode tree.
	* @param valueLength The number of bytes in the entity.
	* @param consumed The number of characters consumed.
	*
	* @returns The number of characters consumed.
	*/
	emitNamedEntityData(result, valueLength, consumed) {
		const { decodeTree } = this;
		this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
		if (valueLength === 3) this.emitCodePoint(decodeTree[result + 2], consumed);
		return consumed;
	}
	/**
	* Signal to the parser that the end of the input was reached.
	*
	* Remaining data will be emitted and relevant errors will be produced.
	*
	* @returns The number of characters consumed.
	*/
	end() {
		var _a$1;
		switch (this.state) {
			case EntityDecoderState.NamedEntity: return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
			case EntityDecoderState.NumericDecimal: return this.emitNumericEntity(0, 2);
			case EntityDecoderState.NumericHex: return this.emitNumericEntity(0, 3);
			case EntityDecoderState.NumericStart: {
				(_a$1 = this.errors) === null || _a$1 === void 0 ? void 0 : _a$1.absenceOfDigitsInNumericCharacterReference(this.consumed);
				return 0;
			}
			case EntityDecoderState.EntityStart: return 0;
		}
	}
};
/**
* Creates a function that decodes entities in a string.
*
* @param decodeTree The decode tree.
* @returns A function that decodes entities in a string.
*/
function getDecoder(decodeTree) {
	let ret = "";
	const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
	return function decodeWithTrie(str, decodeMode) {
		let lastIndex = 0;
		let offset = 0;
		while ((offset = str.indexOf("&", offset)) >= 0) {
			ret += str.slice(lastIndex, offset);
			decoder.startEntity(decodeMode);
			const len = decoder.write(
				str,
				// Skip the "&"
				offset + 1
);
			if (len < 0) {
				lastIndex = offset + decoder.end();
				break;
			}
			lastIndex = offset + len;
			offset = len === 0 ? lastIndex + 1 : lastIndex;
		}
		const result = ret + str.slice(lastIndex);
		ret = "";
		return result;
	};
}
function determineBranch(decodeTree, current, nodeIdx, char) {
	const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
	const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
	if (branchCount === 0) return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
	if (jumpOffset) {
		const value = char - jumpOffset;
		return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
	}
	let lo = nodeIdx;
	let hi = lo + branchCount - 1;
	while (lo <= hi) {
		const mid = lo + hi >>> 1;
		const midVal = decodeTree[mid];
		if (midVal < char) lo = mid + 1;
else if (midVal > char) hi = mid - 1;
else return decodeTree[mid + branchCount];
	}
	return -1;
}
const htmlDecoder = getDecoder(decode_data_html_default);
const xmlDecoder = getDecoder(decode_data_xml_default);
var CharCodes;
(function(CharCodes$2) {
	CharCodes$2[CharCodes$2["Tab"] = 9] = "Tab";
	CharCodes$2[CharCodes$2["NewLine"] = 10] = "NewLine";
	CharCodes$2[CharCodes$2["FormFeed"] = 12] = "FormFeed";
	CharCodes$2[CharCodes$2["CarriageReturn"] = 13] = "CarriageReturn";
	CharCodes$2[CharCodes$2["Space"] = 32] = "Space";
	CharCodes$2[CharCodes$2["ExclamationMark"] = 33] = "ExclamationMark";
	CharCodes$2[CharCodes$2["Number"] = 35] = "Number";
	CharCodes$2[CharCodes$2["Amp"] = 38] = "Amp";
	CharCodes$2[CharCodes$2["SingleQuote"] = 39] = "SingleQuote";
	CharCodes$2[CharCodes$2["DoubleQuote"] = 34] = "DoubleQuote";
	CharCodes$2[CharCodes$2["Dash"] = 45] = "Dash";
	CharCodes$2[CharCodes$2["Slash"] = 47] = "Slash";
	CharCodes$2[CharCodes$2["Zero"] = 48] = "Zero";
	CharCodes$2[CharCodes$2["Nine"] = 57] = "Nine";
	CharCodes$2[CharCodes$2["Semi"] = 59] = "Semi";
	CharCodes$2[CharCodes$2["Lt"] = 60] = "Lt";
	CharCodes$2[CharCodes$2["Eq"] = 61] = "Eq";
	CharCodes$2[CharCodes$2["Gt"] = 62] = "Gt";
	CharCodes$2[CharCodes$2["Questionmark"] = 63] = "Questionmark";
	CharCodes$2[CharCodes$2["UpperA"] = 65] = "UpperA";
	CharCodes$2[CharCodes$2["LowerA"] = 97] = "LowerA";
	CharCodes$2[CharCodes$2["UpperF"] = 70] = "UpperF";
	CharCodes$2[CharCodes$2["LowerF"] = 102] = "LowerF";
	CharCodes$2[CharCodes$2["UpperZ"] = 90] = "UpperZ";
	CharCodes$2[CharCodes$2["LowerZ"] = 122] = "LowerZ";
	CharCodes$2[CharCodes$2["LowerX"] = 120] = "LowerX";
	CharCodes$2[CharCodes$2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */
var State;
(function(State$1) {
	State$1[State$1["Text"] = 1] = "Text";
	State$1[State$1["BeforeTagName"] = 2] = "BeforeTagName";
	State$1[State$1["InTagName"] = 3] = "InTagName";
	State$1[State$1["InSelfClosingTag"] = 4] = "InSelfClosingTag";
	State$1[State$1["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
	State$1[State$1["InClosingTagName"] = 6] = "InClosingTagName";
	State$1[State$1["AfterClosingTagName"] = 7] = "AfterClosingTagName";
	State$1[State$1["BeforeAttributeName"] = 8] = "BeforeAttributeName";
	State$1[State$1["InAttributeName"] = 9] = "InAttributeName";
	State$1[State$1["AfterAttributeName"] = 10] = "AfterAttributeName";
	State$1[State$1["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
	State$1[State$1["InAttributeValueDq"] = 12] = "InAttributeValueDq";
	State$1[State$1["InAttributeValueSq"] = 13] = "InAttributeValueSq";
	State$1[State$1["InAttributeValueNq"] = 14] = "InAttributeValueNq";
	State$1[State$1["BeforeDeclaration"] = 15] = "BeforeDeclaration";
	State$1[State$1["InDeclaration"] = 16] = "InDeclaration";
	State$1[State$1["InProcessingInstruction"] = 17] = "InProcessingInstruction";
	State$1[State$1["BeforeComment"] = 18] = "BeforeComment";
	State$1[State$1["CDATASequence"] = 19] = "CDATASequence";
	State$1[State$1["InSpecialComment"] = 20] = "InSpecialComment";
	State$1[State$1["InCommentLike"] = 21] = "InCommentLike";
	State$1[State$1["BeforeSpecialS"] = 22] = "BeforeSpecialS";
	State$1[State$1["BeforeSpecialT"] = 23] = "BeforeSpecialT";
	State$1[State$1["SpecialStartSequence"] = 24] = "SpecialStartSequence";
	State$1[State$1["InSpecialTag"] = 25] = "InSpecialTag";
	State$1[State$1["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
function isWhitespace(c$1) {
	return c$1 === CharCodes.Space || c$1 === CharCodes.NewLine || c$1 === CharCodes.Tab || c$1 === CharCodes.FormFeed || c$1 === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c$1) {
	return c$1 === CharCodes.Slash || c$1 === CharCodes.Gt || isWhitespace(c$1);
}
function isASCIIAlpha(c$1) {
	return c$1 >= CharCodes.LowerA && c$1 <= CharCodes.LowerZ || c$1 >= CharCodes.UpperA && c$1 <= CharCodes.UpperZ;
}
var QuoteType;
(function(QuoteType$1) {
	QuoteType$1[QuoteType$1["NoValue"] = 0] = "NoValue";
	QuoteType$1[QuoteType$1["Unquoted"] = 1] = "Unquoted";
	QuoteType$1[QuoteType$1["Single"] = 2] = "Single";
	QuoteType$1[QuoteType$1["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
/**
* Sequences used to match longer strings.
*
* We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
* sequences with an increased offset.
*/
const Sequences = {
	Cdata: new Uint8Array([
		67,
		68,
		65,
		84,
		65,
		91
	]),
	CdataEnd: new Uint8Array([
		93,
		93,
		62
	]),
	CommentEnd: new Uint8Array([
		45,
		45,
		62
	]),
	ScriptEnd: new Uint8Array([
		60,
		47,
		115,
		99,
		114,
		105,
		112,
		116
	]),
	StyleEnd: new Uint8Array([
		60,
		47,
		115,
		116,
		121,
		108,
		101
	]),
	TitleEnd: new Uint8Array([
		60,
		47,
		116,
		105,
		116,
		108,
		101
	]),
	TextareaEnd: new Uint8Array([
		60,
		47,
		116,
		101,
		120,
		116,
		97,
		114,
		101,
		97
	])
};
var Tokenizer = class {
	constructor({ xmlMode = false, decodeEntities = true }, cbs) {
		this.cbs = cbs;
		/** The current state the tokenizer is in. */
		this.state = State.Text;
		/** The read buffer. */
		this.buffer = "";
		/** The beginning of the section that is currently being read. */
		this.sectionStart = 0;
		/** The index within the buffer that we are currently looking at. */
		this.index = 0;
		/** The start of the last entity. */
		this.entityStart = 0;
		/** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
		this.baseState = State.Text;
		/** For special parsing behavior inside of script and style tags. */
		this.isSpecial = false;
		/** Indicates whether the tokenizer has been paused. */
		this.running = true;
		/** The offset of the current buffer. */
		this.offset = 0;
		this.currentSequence = undefined;
		this.sequenceIndex = 0;
		this.xmlMode = xmlMode;
		this.decodeEntities = decodeEntities;
		this.entityDecoder = new EntityDecoder(xmlMode ? decode_data_xml_default : decode_data_html_default, (cp, consumed) => this.emitCodePoint(cp, consumed));
	}
	reset() {
		this.state = State.Text;
		this.buffer = "";
		this.sectionStart = 0;
		this.index = 0;
		this.baseState = State.Text;
		this.currentSequence = undefined;
		this.running = true;
		this.offset = 0;
	}
	write(chunk) {
		this.offset += this.buffer.length;
		this.buffer = chunk;
		this.parse();
	}
	end() {
		if (this.running) this.finish();
	}
	pause() {
		this.running = false;
	}
	resume() {
		this.running = true;
		if (this.index < this.buffer.length + this.offset) this.parse();
	}
	stateText(c$1) {
		if (c$1 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
			if (this.index > this.sectionStart) this.cbs.ontext(this.sectionStart, this.index);
			this.state = State.BeforeTagName;
			this.sectionStart = this.index;
		} else if (this.decodeEntities && c$1 === CharCodes.Amp) this.startEntity();
	}
	stateSpecialStartSequence(c$1) {
		const isEnd = this.sequenceIndex === this.currentSequence.length;
		const isMatch = isEnd ? isEndOfTagSection(c$1) : (c$1 | 32) === this.currentSequence[this.sequenceIndex];
		if (!isMatch) this.isSpecial = false;
else if (!isEnd) {
			this.sequenceIndex++;
			return;
		}
		this.sequenceIndex = 0;
		this.state = State.InTagName;
		this.stateInTagName(c$1);
	}
	/** Look for an end tag. For <title> tags, also decode entities. */
	stateInSpecialTag(c$1) {
		if (this.sequenceIndex === this.currentSequence.length) {
			if (c$1 === CharCodes.Gt || isWhitespace(c$1)) {
				const endOfText = this.index - this.currentSequence.length;
				if (this.sectionStart < endOfText) {
					const actualIndex = this.index;
					this.index = endOfText;
					this.cbs.ontext(this.sectionStart, endOfText);
					this.index = actualIndex;
				}
				this.isSpecial = false;
				this.sectionStart = endOfText + 2;
				this.stateInClosingTagName(c$1);
				return;
			}
			this.sequenceIndex = 0;
		}
		if ((c$1 | 32) === this.currentSequence[this.sequenceIndex]) this.sequenceIndex += 1;
else if (this.sequenceIndex === 0) {
			if (this.currentSequence === Sequences.TitleEnd) {
				if (this.decodeEntities && c$1 === CharCodes.Amp) this.startEntity();
			} else if (this.fastForwardTo(CharCodes.Lt)) this.sequenceIndex = 1;
		} else this.sequenceIndex = Number(c$1 === CharCodes.Lt);
	}
	stateCDATASequence(c$1) {
		if (c$1 === Sequences.Cdata[this.sequenceIndex]) {
			if (++this.sequenceIndex === Sequences.Cdata.length) {
				this.state = State.InCommentLike;
				this.currentSequence = Sequences.CdataEnd;
				this.sequenceIndex = 0;
				this.sectionStart = this.index + 1;
			}
		} else {
			this.sequenceIndex = 0;
			this.state = State.InDeclaration;
			this.stateInDeclaration(c$1);
		}
	}
	/**
	* When we wait for one specific character, we can speed things up
	* by skipping through the buffer until we find it.
	*
	* @returns Whether the character was found.
	*/
	fastForwardTo(c$1) {
		while (++this.index < this.buffer.length + this.offset) if (this.buffer.charCodeAt(this.index - this.offset) === c$1) return true;
		this.index = this.buffer.length + this.offset - 1;
		return false;
	}
	/**
	* Comments and CDATA end with `-->` and `]]>`.
	*
	* Their common qualities are:
	* - Their end sequences have a distinct character they start with.
	* - That character is then repeated, so we have to check multiple repeats.
	* - All characters but the start character of the sequence can be skipped.
	*/
	stateInCommentLike(c$1) {
		if (c$1 === this.currentSequence[this.sequenceIndex]) {
			if (++this.sequenceIndex === this.currentSequence.length) {
				if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, this.index, 2);
else this.cbs.oncomment(this.sectionStart, this.index, 2);
				this.sequenceIndex = 0;
				this.sectionStart = this.index + 1;
				this.state = State.Text;
			}
		} else if (this.sequenceIndex === 0) {
			if (this.fastForwardTo(this.currentSequence[0])) this.sequenceIndex = 1;
		} else if (c$1 !== this.currentSequence[this.sequenceIndex - 1]) this.sequenceIndex = 0;
	}
	/**
	* HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
	*
	* XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
	* We allow anything that wouldn't end the tag.
	*/
	isTagStartChar(c$1) {
		return this.xmlMode ? !isEndOfTagSection(c$1) : isASCIIAlpha(c$1);
	}
	startSpecial(sequence$1, offset) {
		this.isSpecial = true;
		this.currentSequence = sequence$1;
		this.sequenceIndex = offset;
		this.state = State.SpecialStartSequence;
	}
	stateBeforeTagName(c$1) {
		if (c$1 === CharCodes.ExclamationMark) {
			this.state = State.BeforeDeclaration;
			this.sectionStart = this.index + 1;
		} else if (c$1 === CharCodes.Questionmark) {
			this.state = State.InProcessingInstruction;
			this.sectionStart = this.index + 1;
		} else if (this.isTagStartChar(c$1)) {
			const lower = c$1 | 32;
			this.sectionStart = this.index;
			if (this.xmlMode) this.state = State.InTagName;
else if (lower === Sequences.ScriptEnd[2]) this.state = State.BeforeSpecialS;
else if (lower === Sequences.TitleEnd[2]) this.state = State.BeforeSpecialT;
else this.state = State.InTagName;
		} else if (c$1 === CharCodes.Slash) this.state = State.BeforeClosingTagName;
else {
			this.state = State.Text;
			this.stateText(c$1);
		}
	}
	stateInTagName(c$1) {
		if (isEndOfTagSection(c$1)) {
			this.cbs.onopentagname(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$1);
		}
	}
	stateBeforeClosingTagName(c$1) {
		if (isWhitespace(c$1)) {} else if (c$1 === CharCodes.Gt) this.state = State.Text;
else {
			this.state = this.isTagStartChar(c$1) ? State.InClosingTagName : State.InSpecialComment;
			this.sectionStart = this.index;
		}
	}
	stateInClosingTagName(c$1) {
		if (c$1 === CharCodes.Gt || isWhitespace(c$1)) {
			this.cbs.onclosetag(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.state = State.AfterClosingTagName;
			this.stateAfterClosingTagName(c$1);
		}
	}
	stateAfterClosingTagName(c$1) {
		if (c$1 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeAttributeName(c$1) {
		if (c$1 === CharCodes.Gt) {
			this.cbs.onopentagend(this.index);
			if (this.isSpecial) {
				this.state = State.InSpecialTag;
				this.sequenceIndex = 0;
			} else this.state = State.Text;
			this.sectionStart = this.index + 1;
		} else if (c$1 === CharCodes.Slash) this.state = State.InSelfClosingTag;
else if (!isWhitespace(c$1)) {
			this.state = State.InAttributeName;
			this.sectionStart = this.index;
		}
	}
	stateInSelfClosingTag(c$1) {
		if (c$1 === CharCodes.Gt) {
			this.cbs.onselfclosingtag(this.index);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
			this.isSpecial = false;
		} else if (!isWhitespace(c$1)) {
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$1);
		}
	}
	stateInAttributeName(c$1) {
		if (c$1 === CharCodes.Eq || isEndOfTagSection(c$1)) {
			this.cbs.onattribname(this.sectionStart, this.index);
			this.sectionStart = this.index;
			this.state = State.AfterAttributeName;
			this.stateAfterAttributeName(c$1);
		}
	}
	stateAfterAttributeName(c$1) {
		if (c$1 === CharCodes.Eq) this.state = State.BeforeAttributeValue;
else if (c$1 === CharCodes.Slash || c$1 === CharCodes.Gt) {
			this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
			this.sectionStart = -1;
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$1);
		} else if (!isWhitespace(c$1)) {
			this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
			this.state = State.InAttributeName;
			this.sectionStart = this.index;
		}
	}
	stateBeforeAttributeValue(c$1) {
		if (c$1 === CharCodes.DoubleQuote) {
			this.state = State.InAttributeValueDq;
			this.sectionStart = this.index + 1;
		} else if (c$1 === CharCodes.SingleQuote) {
			this.state = State.InAttributeValueSq;
			this.sectionStart = this.index + 1;
		} else if (!isWhitespace(c$1)) {
			this.sectionStart = this.index;
			this.state = State.InAttributeValueNq;
			this.stateInAttributeValueNoQuotes(c$1);
		}
	}
	handleInAttributeValue(c$1, quote$1) {
		if (c$1 === quote$1 || !this.decodeEntities && this.fastForwardTo(quote$1)) {
			this.cbs.onattribdata(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.cbs.onattribend(quote$1 === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
			this.state = State.BeforeAttributeName;
		} else if (this.decodeEntities && c$1 === CharCodes.Amp) this.startEntity();
	}
	stateInAttributeValueDoubleQuotes(c$1) {
		this.handleInAttributeValue(c$1, CharCodes.DoubleQuote);
	}
	stateInAttributeValueSingleQuotes(c$1) {
		this.handleInAttributeValue(c$1, CharCodes.SingleQuote);
	}
	stateInAttributeValueNoQuotes(c$1) {
		if (isWhitespace(c$1) || c$1 === CharCodes.Gt) {
			this.cbs.onattribdata(this.sectionStart, this.index);
			this.sectionStart = -1;
			this.cbs.onattribend(QuoteType.Unquoted, this.index);
			this.state = State.BeforeAttributeName;
			this.stateBeforeAttributeName(c$1);
		} else if (this.decodeEntities && c$1 === CharCodes.Amp) this.startEntity();
	}
	stateBeforeDeclaration(c$1) {
		if (c$1 === CharCodes.OpeningSquareBracket) {
			this.state = State.CDATASequence;
			this.sequenceIndex = 0;
		} else this.state = c$1 === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
	}
	stateInDeclaration(c$1) {
		if (c$1 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.cbs.ondeclaration(this.sectionStart, this.index);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateInProcessingInstruction(c$1) {
		if (c$1 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.cbs.onprocessinginstruction(this.sectionStart, this.index);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeComment(c$1) {
		if (c$1 === CharCodes.Dash) {
			this.state = State.InCommentLike;
			this.currentSequence = Sequences.CommentEnd;
			this.sequenceIndex = 2;
			this.sectionStart = this.index + 1;
		} else this.state = State.InDeclaration;
	}
	stateInSpecialComment(c$1) {
		if (c$1 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
			this.cbs.oncomment(this.sectionStart, this.index, 0);
			this.state = State.Text;
			this.sectionStart = this.index + 1;
		}
	}
	stateBeforeSpecialS(c$1) {
		const lower = c$1 | 32;
		if (lower === Sequences.ScriptEnd[3]) this.startSpecial(Sequences.ScriptEnd, 4);
else if (lower === Sequences.StyleEnd[3]) this.startSpecial(Sequences.StyleEnd, 4);
else {
			this.state = State.InTagName;
			this.stateInTagName(c$1);
		}
	}
	stateBeforeSpecialT(c$1) {
		const lower = c$1 | 32;
		if (lower === Sequences.TitleEnd[3]) this.startSpecial(Sequences.TitleEnd, 4);
else if (lower === Sequences.TextareaEnd[3]) this.startSpecial(Sequences.TextareaEnd, 4);
else {
			this.state = State.InTagName;
			this.stateInTagName(c$1);
		}
	}
	startEntity() {
		this.baseState = this.state;
		this.state = State.InEntity;
		this.entityStart = this.index;
		this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);
	}
	stateInEntity() {
		const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
		if (length >= 0) {
			this.state = this.baseState;
			if (length === 0) this.index = this.entityStart;
		} else this.index = this.offset + this.buffer.length - 1;
	}
	/**
	* Remove data that has already been consumed from the buffer.
	*/
	cleanup() {
		if (this.running && this.sectionStart !== this.index) {
			if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
				this.cbs.ontext(this.sectionStart, this.index);
				this.sectionStart = this.index;
			} else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
				this.cbs.onattribdata(this.sectionStart, this.index);
				this.sectionStart = this.index;
			}
		}
	}
	shouldContinue() {
		return this.index < this.buffer.length + this.offset && this.running;
	}
	/**
	* Iterates through the buffer, calling the function corresponding to the current state.
	*
	* States that are more likely to be hit are higher up, as a performance improvement.
	*/
	parse() {
		while (this.shouldContinue()) {
			const c$1 = this.buffer.charCodeAt(this.index - this.offset);
			switch (this.state) {
				case State.Text: {
					this.stateText(c$1);
					break;
				}
				case State.SpecialStartSequence: {
					this.stateSpecialStartSequence(c$1);
					break;
				}
				case State.InSpecialTag: {
					this.stateInSpecialTag(c$1);
					break;
				}
				case State.CDATASequence: {
					this.stateCDATASequence(c$1);
					break;
				}
				case State.InAttributeValueDq: {
					this.stateInAttributeValueDoubleQuotes(c$1);
					break;
				}
				case State.InAttributeName: {
					this.stateInAttributeName(c$1);
					break;
				}
				case State.InCommentLike: {
					this.stateInCommentLike(c$1);
					break;
				}
				case State.InSpecialComment: {
					this.stateInSpecialComment(c$1);
					break;
				}
				case State.BeforeAttributeName: {
					this.stateBeforeAttributeName(c$1);
					break;
				}
				case State.InTagName: {
					this.stateInTagName(c$1);
					break;
				}
				case State.InClosingTagName: {
					this.stateInClosingTagName(c$1);
					break;
				}
				case State.BeforeTagName: {
					this.stateBeforeTagName(c$1);
					break;
				}
				case State.AfterAttributeName: {
					this.stateAfterAttributeName(c$1);
					break;
				}
				case State.InAttributeValueSq: {
					this.stateInAttributeValueSingleQuotes(c$1);
					break;
				}
				case State.BeforeAttributeValue: {
					this.stateBeforeAttributeValue(c$1);
					break;
				}
				case State.BeforeClosingTagName: {
					this.stateBeforeClosingTagName(c$1);
					break;
				}
				case State.AfterClosingTagName: {
					this.stateAfterClosingTagName(c$1);
					break;
				}
				case State.BeforeSpecialS: {
					this.stateBeforeSpecialS(c$1);
					break;
				}
				case State.BeforeSpecialT: {
					this.stateBeforeSpecialT(c$1);
					break;
				}
				case State.InAttributeValueNq: {
					this.stateInAttributeValueNoQuotes(c$1);
					break;
				}
				case State.InSelfClosingTag: {
					this.stateInSelfClosingTag(c$1);
					break;
				}
				case State.InDeclaration: {
					this.stateInDeclaration(c$1);
					break;
				}
				case State.BeforeDeclaration: {
					this.stateBeforeDeclaration(c$1);
					break;
				}
				case State.BeforeComment: {
					this.stateBeforeComment(c$1);
					break;
				}
				case State.InProcessingInstruction: {
					this.stateInProcessingInstruction(c$1);
					break;
				}
				case State.InEntity: {
					this.stateInEntity();
					break;
				}
			}
			this.index++;
		}
		this.cleanup();
	}
	finish() {
		if (this.state === State.InEntity) {
			this.entityDecoder.end();
			this.state = this.baseState;
		}
		this.handleTrailingData();
		this.cbs.onend();
	}
	/** Handle any trailing data. */
	handleTrailingData() {
		const endIndex = this.buffer.length + this.offset;
		if (this.sectionStart >= endIndex) return;
		if (this.state === State.InCommentLike) if (this.currentSequence === Sequences.CdataEnd) this.cbs.oncdata(this.sectionStart, endIndex, 0);
else this.cbs.oncomment(this.sectionStart, endIndex, 0);
else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {} else this.cbs.ontext(this.sectionStart, endIndex);
	}
	emitCodePoint(cp, consumed) {
		if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
			if (this.sectionStart < this.entityStart) this.cbs.onattribdata(this.sectionStart, this.entityStart);
			this.sectionStart = this.entityStart + consumed;
			this.index = this.sectionStart - 1;
			this.cbs.onattribentity(cp);
		} else {
			if (this.sectionStart < this.entityStart) this.cbs.ontext(this.sectionStart, this.entityStart);
			this.sectionStart = this.entityStart + consumed;
			this.index = this.sectionStart - 1;
			this.cbs.ontextentity(cp, this.sectionStart);
		}
	}
};
const formTags = new Set([
	"input",
	"option",
	"optgroup",
	"select",
	"button",
	"datalist",
	"textarea"
]);
const pTag = new Set(["p"]);
const tableSectionTags = new Set(["thead", "tbody"]);
const ddtTags = new Set(["dd", "dt"]);
const rtpTags = new Set(["rt", "rp"]);
const openImpliesClose = new Map([
	["tr", new Set([
		"tr",
		"th",
		"td"
	])],
	["th", new Set(["th"])],
	["td", new Set([
		"thead",
		"th",
		"td"
	])],
	["body", new Set([
		"head",
		"link",
		"script"
	])],
	["li", new Set(["li"])],
	["p", pTag],
	["h1", pTag],
	["h2", pTag],
	["h3", pTag],
	["h4", pTag],
	["h5", pTag],
	["h6", pTag],
	["select", formTags],
	["input", formTags],
	["output", formTags],
	["button", formTags],
	["datalist", formTags],
	["textarea", formTags],
	["option", new Set(["option"])],
	["optgroup", new Set(["optgroup", "option"])],
	["dd", ddtTags],
	["dt", ddtTags],
	["address", pTag],
	["article", pTag],
	["aside", pTag],
	["blockquote", pTag],
	["details", pTag],
	["div", pTag],
	["dl", pTag],
	["fieldset", pTag],
	["figcaption", pTag],
	["figure", pTag],
	["footer", pTag],
	["form", pTag],
	["header", pTag],
	["hr", pTag],
	["main", pTag],
	["nav", pTag],
	["ol", pTag],
	["pre", pTag],
	["section", pTag],
	["table", pTag],
	["ul", pTag],
	["rt", rtpTags],
	["rp", rtpTags],
	["tbody", tableSectionTags],
	["tfoot", tableSectionTags]
]);
const voidElements = new Set([
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"img",
	"input",
	"isindex",
	"keygen",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr"
]);
const foreignContextElements = new Set(["math", "svg"]);
const htmlIntegrationElements = new Set([
	"mi",
	"mo",
	"mn",
	"ms",
	"mtext",
	"annotation-xml",
	"foreignobject",
	"desc",
	"title"
]);
const reNameEnd = /\s|\//;
var Parser$3 = class {
	constructor(cbs, options = {}) {
		var _a$1, _b, _c, _d, _e, _f;
		this.options = options;
		/** The start index of the last event. */
		this.startIndex = 0;
		/** The end index of the last event. */
		this.endIndex = 0;
		/**
		* Store the start index of the current open tag,
		* so we can update the start index for attributes.
		*/
		this.openTagStart = 0;
		this.tagname = "";
		this.attribname = "";
		this.attribvalue = "";
		this.attribs = null;
		this.stack = [];
		this.buffers = [];
		this.bufferOffset = 0;
		/** The index of the last written buffer. Used when resuming after a `pause()`. */
		this.writeIndex = 0;
		/** Indicates whether the parser has finished running / `.end` has been called. */
		this.ended = false;
		this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
		this.htmlMode = !this.options.xmlMode;
		this.lowerCaseTagNames = (_a$1 = options.lowerCaseTags) !== null && _a$1 !== void 0 ? _a$1 : this.htmlMode;
		this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
		this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
		this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
		this.foreignContext = [!this.htmlMode];
		(_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
	}
	/** @internal */
	ontext(start, endIndex) {
		var _a$1, _b;
		const data$1 = this.getSlice(start, endIndex);
		this.endIndex = endIndex - 1;
		(_b = (_a$1 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a$1, data$1);
		this.startIndex = endIndex;
	}
	/** @internal */
	ontextentity(cp, endIndex) {
		var _a$1, _b;
		this.endIndex = endIndex - 1;
		(_b = (_a$1 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a$1, fromCodePoint(cp));
		this.startIndex = endIndex;
	}
	/**
	* Checks if the current tag is a void element. Override this if you want
	* to specify your own additional void elements.
	*/
	isVoidElement(name) {
		return this.htmlMode && voidElements.has(name);
	}
	/** @internal */
	onopentagname(start, endIndex) {
		this.endIndex = endIndex;
		let name = this.getSlice(start, endIndex);
		if (this.lowerCaseTagNames) name = name.toLowerCase();
		this.emitOpenTag(name);
	}
	emitOpenTag(name) {
		var _a$1, _b, _c, _d;
		this.openTagStart = this.startIndex;
		this.tagname = name;
		const impliesClose = this.htmlMode && openImpliesClose.get(name);
		if (impliesClose) while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
			const element = this.stack.shift();
			(_b = (_a$1 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a$1, element, true);
		}
		if (!this.isVoidElement(name)) {
			this.stack.unshift(name);
			if (this.htmlMode) {
				if (foreignContextElements.has(name)) this.foreignContext.unshift(true);
else if (htmlIntegrationElements.has(name)) this.foreignContext.unshift(false);
			}
		}
		(_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
		if (this.cbs.onopentag) this.attribs = {};
	}
	endOpenTag(isImplied) {
		var _a$1, _b;
		this.startIndex = this.openTagStart;
		if (this.attribs) {
			(_b = (_a$1 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a$1, this.tagname, this.attribs, isImplied);
			this.attribs = null;
		}
		if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) this.cbs.onclosetag(this.tagname, true);
		this.tagname = "";
	}
	/** @internal */
	onopentagend(endIndex) {
		this.endIndex = endIndex;
		this.endOpenTag(false);
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onclosetag(start, endIndex) {
		var _a$1, _b, _c, _d, _e, _f, _g, _h;
		this.endIndex = endIndex;
		let name = this.getSlice(start, endIndex);
		if (this.lowerCaseTagNames) name = name.toLowerCase();
		if (this.htmlMode && (foreignContextElements.has(name) || htmlIntegrationElements.has(name))) this.foreignContext.shift();
		if (!this.isVoidElement(name)) {
			const pos = this.stack.indexOf(name);
			if (pos !== -1) for (let index = 0; index <= pos; index++) {
				const element = this.stack.shift();
				(_b = (_a$1 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a$1, element, index !== pos);
			}
else if (this.htmlMode && name === "p") {
				this.emitOpenTag("p");
				this.closeCurrentTag(true);
			}
		} else if (this.htmlMode && name === "br") {
			(_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
			(_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
			(_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onselfclosingtag(endIndex) {
		this.endIndex = endIndex;
		if (this.recognizeSelfClosing || this.foreignContext[0]) {
			this.closeCurrentTag(false);
			this.startIndex = endIndex + 1;
		} else this.onopentagend(endIndex);
	}
	closeCurrentTag(isOpenImplied) {
		var _a$1, _b;
		const name = this.tagname;
		this.endOpenTag(isOpenImplied);
		if (this.stack[0] === name) {
			(_b = (_a$1 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a$1, name, !isOpenImplied);
			this.stack.shift();
		}
	}
	/** @internal */
	onattribname(start, endIndex) {
		this.startIndex = start;
		const name = this.getSlice(start, endIndex);
		this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
	}
	/** @internal */
	onattribdata(start, endIndex) {
		this.attribvalue += this.getSlice(start, endIndex);
	}
	/** @internal */
	onattribentity(cp) {
		this.attribvalue += fromCodePoint(cp);
	}
	/** @internal */
	onattribend(quote$1, endIndex) {
		var _a$1, _b;
		this.endIndex = endIndex;
		(_b = (_a$1 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a$1, this.attribname, this.attribvalue, quote$1 === QuoteType.Double ? "\"" : quote$1 === QuoteType.Single ? "'" : quote$1 === QuoteType.NoValue ? undefined : null);
		if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) this.attribs[this.attribname] = this.attribvalue;
		this.attribvalue = "";
	}
	getInstructionName(value) {
		const index = value.search(reNameEnd);
		let name = index < 0 ? value : value.substr(0, index);
		if (this.lowerCaseTagNames) name = name.toLowerCase();
		return name;
	}
	/** @internal */
	ondeclaration(start, endIndex) {
		this.endIndex = endIndex;
		const value = this.getSlice(start, endIndex);
		if (this.cbs.onprocessinginstruction) {
			const name = this.getInstructionName(value);
			this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onprocessinginstruction(start, endIndex) {
		this.endIndex = endIndex;
		const value = this.getSlice(start, endIndex);
		if (this.cbs.onprocessinginstruction) {
			const name = this.getInstructionName(value);
			this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	oncomment(start, endIndex, offset) {
		var _a$1, _b, _c, _d;
		this.endIndex = endIndex;
		(_b = (_a$1 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a$1, this.getSlice(start, endIndex - offset));
		(_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	oncdata(start, endIndex, offset) {
		var _a$1, _b, _c, _d, _e, _f, _g, _h, _j, _k;
		this.endIndex = endIndex;
		const value = this.getSlice(start, endIndex - offset);
		if (!this.htmlMode || this.options.recognizeCDATA) {
			(_b = (_a$1 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a$1);
			(_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
			(_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
		} else {
			(_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
			(_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
		}
		this.startIndex = endIndex + 1;
	}
	/** @internal */
	onend() {
		var _a$1, _b;
		if (this.cbs.onclosetag) {
			this.endIndex = this.startIndex;
			for (let index = 0; index < this.stack.length; index++) this.cbs.onclosetag(this.stack[index], true);
		}
		(_b = (_a$1 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a$1);
	}
	/**
	* Resets the parser to a blank state, ready to parse a new HTML document
	*/
	reset() {
		var _a$1, _b, _c, _d;
		(_b = (_a$1 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a$1);
		this.tokenizer.reset();
		this.tagname = "";
		this.attribname = "";
		this.attribs = null;
		this.stack.length = 0;
		this.startIndex = 0;
		this.endIndex = 0;
		(_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
		this.buffers.length = 0;
		this.foreignContext.length = 0;
		this.foreignContext.unshift(!this.htmlMode);
		this.bufferOffset = 0;
		this.writeIndex = 0;
		this.ended = false;
	}
	/**
	* Resets the parser, then parses a complete document and
	* pushes it to the handler.
	*
	* @param data Document to parse.
	*/
	parseComplete(data$1) {
		this.reset();
		this.end(data$1);
	}
	getSlice(start, end) {
		while (start - this.bufferOffset >= this.buffers[0].length) this.shiftBuffer();
		let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
		while (end - this.bufferOffset > this.buffers[0].length) {
			this.shiftBuffer();
			slice += this.buffers[0].slice(0, end - this.bufferOffset);
		}
		return slice;
	}
	shiftBuffer() {
		this.bufferOffset += this.buffers[0].length;
		this.writeIndex--;
		this.buffers.shift();
	}
	/**
	* Parses a chunk of data and calls the corresponding callbacks.
	*
	* @param chunk Chunk to parse.
	*/
	write(chunk) {
		var _a$1, _b;
		if (this.ended) {
			(_b = (_a$1 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a$1, new Error(".write() after done!"));
			return;
		}
		this.buffers.push(chunk);
		if (this.tokenizer.running) {
			this.tokenizer.write(chunk);
			this.writeIndex++;
		}
	}
	/**
	* Parses the end of the buffer and clears the stack, calls onend.
	*
	* @param chunk Optional final chunk to parse.
	*/
	end(chunk) {
		var _a$1, _b;
		if (this.ended) {
			(_b = (_a$1 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a$1, new Error(".end() after done!"));
			return;
		}
		if (chunk) this.write(chunk);
		this.ended = true;
		this.tokenizer.end();
	}
	/**
	* Pauses parsing. The parser won't emit events until `resume` is called.
	*/
	pause() {
		this.tokenizer.pause();
	}
	/**
	* Resumes parsing after `pause` was called.
	*/
	resume() {
		this.tokenizer.resume();
		while (this.tokenizer.running && this.writeIndex < this.buffers.length) this.tokenizer.write(this.buffers[this.writeIndex++]);
		if (this.ended) this.tokenizer.end();
	}
	/**
	* Alias of `write`, for backwards compatibility.
	*
	* @param chunk Chunk to parse.
	* @deprecated
	*/
	parseChunk(chunk) {
		this.write(chunk);
	}
	/**
	* Alias of `end`, for backwards compatibility.
	*
	* @param chunk Optional final chunk to parse.
	* @deprecated
	*/
	done(chunk) {
		this.end(chunk);
	}
};
function restoreDiff(arr) {
	for (let i$1 = 1; i$1 < arr.length; i$1++) arr[i$1][0] += arr[i$1 - 1][0] + 1;
	return arr;
}
var encode_html_default = new Map(
	/* #__PURE__ */ restoreDiff([
		[9, "&Tab;"],
		[0, "&NewLine;"],
		[22, "&excl;"],
		[0, "&quot;"],
		[0, "&num;"],
		[0, "&dollar;"],
		[0, "&percnt;"],
		[0, "&amp;"],
		[0, "&apos;"],
		[0, "&lpar;"],
		[0, "&rpar;"],
		[0, "&ast;"],
		[0, "&plus;"],
		[0, "&comma;"],
		[1, "&period;"],
		[0, "&sol;"],
		[10, "&colon;"],
		[0, "&semi;"],
		[0, {
			v: "&lt;",
			n: 8402,
			o: "&nvlt;"
		}],
		[0, {
			v: "&equals;",
			n: 8421,
			o: "&bne;"
		}],
		[0, {
			v: "&gt;",
			n: 8402,
			o: "&nvgt;"
		}],
		[0, "&quest;"],
		[0, "&commat;"],
		[26, "&lbrack;"],
		[0, "&bsol;"],
		[0, "&rbrack;"],
		[0, "&Hat;"],
		[0, "&lowbar;"],
		[0, "&DiacriticalGrave;"],
		[5, {
			n: 106,
			o: "&fjlig;"
		}],
		[20, "&lbrace;"],
		[0, "&verbar;"],
		[0, "&rbrace;"],
		[34, "&nbsp;"],
		[0, "&iexcl;"],
		[0, "&cent;"],
		[0, "&pound;"],
		[0, "&curren;"],
		[0, "&yen;"],
		[0, "&brvbar;"],
		[0, "&sect;"],
		[0, "&die;"],
		[0, "&copy;"],
		[0, "&ordf;"],
		[0, "&laquo;"],
		[0, "&not;"],
		[0, "&shy;"],
		[0, "&circledR;"],
		[0, "&macr;"],
		[0, "&deg;"],
		[0, "&PlusMinus;"],
		[0, "&sup2;"],
		[0, "&sup3;"],
		[0, "&acute;"],
		[0, "&micro;"],
		[0, "&para;"],
		[0, "&centerdot;"],
		[0, "&cedil;"],
		[0, "&sup1;"],
		[0, "&ordm;"],
		[0, "&raquo;"],
		[0, "&frac14;"],
		[0, "&frac12;"],
		[0, "&frac34;"],
		[0, "&iquest;"],
		[0, "&Agrave;"],
		[0, "&Aacute;"],
		[0, "&Acirc;"],
		[0, "&Atilde;"],
		[0, "&Auml;"],
		[0, "&angst;"],
		[0, "&AElig;"],
		[0, "&Ccedil;"],
		[0, "&Egrave;"],
		[0, "&Eacute;"],
		[0, "&Ecirc;"],
		[0, "&Euml;"],
		[0, "&Igrave;"],
		[0, "&Iacute;"],
		[0, "&Icirc;"],
		[0, "&Iuml;"],
		[0, "&ETH;"],
		[0, "&Ntilde;"],
		[0, "&Ograve;"],
		[0, "&Oacute;"],
		[0, "&Ocirc;"],
		[0, "&Otilde;"],
		[0, "&Ouml;"],
		[0, "&times;"],
		[0, "&Oslash;"],
		[0, "&Ugrave;"],
		[0, "&Uacute;"],
		[0, "&Ucirc;"],
		[0, "&Uuml;"],
		[0, "&Yacute;"],
		[0, "&THORN;"],
		[0, "&szlig;"],
		[0, "&agrave;"],
		[0, "&aacute;"],
		[0, "&acirc;"],
		[0, "&atilde;"],
		[0, "&auml;"],
		[0, "&aring;"],
		[0, "&aelig;"],
		[0, "&ccedil;"],
		[0, "&egrave;"],
		[0, "&eacute;"],
		[0, "&ecirc;"],
		[0, "&euml;"],
		[0, "&igrave;"],
		[0, "&iacute;"],
		[0, "&icirc;"],
		[0, "&iuml;"],
		[0, "&eth;"],
		[0, "&ntilde;"],
		[0, "&ograve;"],
		[0, "&oacute;"],
		[0, "&ocirc;"],
		[0, "&otilde;"],
		[0, "&ouml;"],
		[0, "&div;"],
		[0, "&oslash;"],
		[0, "&ugrave;"],
		[0, "&uacute;"],
		[0, "&ucirc;"],
		[0, "&uuml;"],
		[0, "&yacute;"],
		[0, "&thorn;"],
		[0, "&yuml;"],
		[0, "&Amacr;"],
		[0, "&amacr;"],
		[0, "&Abreve;"],
		[0, "&abreve;"],
		[0, "&Aogon;"],
		[0, "&aogon;"],
		[0, "&Cacute;"],
		[0, "&cacute;"],
		[0, "&Ccirc;"],
		[0, "&ccirc;"],
		[0, "&Cdot;"],
		[0, "&cdot;"],
		[0, "&Ccaron;"],
		[0, "&ccaron;"],
		[0, "&Dcaron;"],
		[0, "&dcaron;"],
		[0, "&Dstrok;"],
		[0, "&dstrok;"],
		[0, "&Emacr;"],
		[0, "&emacr;"],
		[2, "&Edot;"],
		[0, "&edot;"],
		[0, "&Eogon;"],
		[0, "&eogon;"],
		[0, "&Ecaron;"],
		[0, "&ecaron;"],
		[0, "&Gcirc;"],
		[0, "&gcirc;"],
		[0, "&Gbreve;"],
		[0, "&gbreve;"],
		[0, "&Gdot;"],
		[0, "&gdot;"],
		[0, "&Gcedil;"],
		[1, "&Hcirc;"],
		[0, "&hcirc;"],
		[0, "&Hstrok;"],
		[0, "&hstrok;"],
		[0, "&Itilde;"],
		[0, "&itilde;"],
		[0, "&Imacr;"],
		[0, "&imacr;"],
		[2, "&Iogon;"],
		[0, "&iogon;"],
		[0, "&Idot;"],
		[0, "&imath;"],
		[0, "&IJlig;"],
		[0, "&ijlig;"],
		[0, "&Jcirc;"],
		[0, "&jcirc;"],
		[0, "&Kcedil;"],
		[0, "&kcedil;"],
		[0, "&kgreen;"],
		[0, "&Lacute;"],
		[0, "&lacute;"],
		[0, "&Lcedil;"],
		[0, "&lcedil;"],
		[0, "&Lcaron;"],
		[0, "&lcaron;"],
		[0, "&Lmidot;"],
		[0, "&lmidot;"],
		[0, "&Lstrok;"],
		[0, "&lstrok;"],
		[0, "&Nacute;"],
		[0, "&nacute;"],
		[0, "&Ncedil;"],
		[0, "&ncedil;"],
		[0, "&Ncaron;"],
		[0, "&ncaron;"],
		[0, "&napos;"],
		[0, "&ENG;"],
		[0, "&eng;"],
		[0, "&Omacr;"],
		[0, "&omacr;"],
		[2, "&Odblac;"],
		[0, "&odblac;"],
		[0, "&OElig;"],
		[0, "&oelig;"],
		[0, "&Racute;"],
		[0, "&racute;"],
		[0, "&Rcedil;"],
		[0, "&rcedil;"],
		[0, "&Rcaron;"],
		[0, "&rcaron;"],
		[0, "&Sacute;"],
		[0, "&sacute;"],
		[0, "&Scirc;"],
		[0, "&scirc;"],
		[0, "&Scedil;"],
		[0, "&scedil;"],
		[0, "&Scaron;"],
		[0, "&scaron;"],
		[0, "&Tcedil;"],
		[0, "&tcedil;"],
		[0, "&Tcaron;"],
		[0, "&tcaron;"],
		[0, "&Tstrok;"],
		[0, "&tstrok;"],
		[0, "&Utilde;"],
		[0, "&utilde;"],
		[0, "&Umacr;"],
		[0, "&umacr;"],
		[0, "&Ubreve;"],
		[0, "&ubreve;"],
		[0, "&Uring;"],
		[0, "&uring;"],
		[0, "&Udblac;"],
		[0, "&udblac;"],
		[0, "&Uogon;"],
		[0, "&uogon;"],
		[0, "&Wcirc;"],
		[0, "&wcirc;"],
		[0, "&Ycirc;"],
		[0, "&ycirc;"],
		[0, "&Yuml;"],
		[0, "&Zacute;"],
		[0, "&zacute;"],
		[0, "&Zdot;"],
		[0, "&zdot;"],
		[0, "&Zcaron;"],
		[0, "&zcaron;"],
		[19, "&fnof;"],
		[34, "&imped;"],
		[63, "&gacute;"],
		[65, "&jmath;"],
		[142, "&circ;"],
		[0, "&caron;"],
		[16, "&breve;"],
		[0, "&DiacriticalDot;"],
		[0, "&ring;"],
		[0, "&ogon;"],
		[0, "&DiacriticalTilde;"],
		[0, "&dblac;"],
		[51, "&DownBreve;"],
		[127, "&Alpha;"],
		[0, "&Beta;"],
		[0, "&Gamma;"],
		[0, "&Delta;"],
		[0, "&Epsilon;"],
		[0, "&Zeta;"],
		[0, "&Eta;"],
		[0, "&Theta;"],
		[0, "&Iota;"],
		[0, "&Kappa;"],
		[0, "&Lambda;"],
		[0, "&Mu;"],
		[0, "&Nu;"],
		[0, "&Xi;"],
		[0, "&Omicron;"],
		[0, "&Pi;"],
		[0, "&Rho;"],
		[1, "&Sigma;"],
		[0, "&Tau;"],
		[0, "&Upsilon;"],
		[0, "&Phi;"],
		[0, "&Chi;"],
		[0, "&Psi;"],
		[0, "&ohm;"],
		[7, "&alpha;"],
		[0, "&beta;"],
		[0, "&gamma;"],
		[0, "&delta;"],
		[0, "&epsi;"],
		[0, "&zeta;"],
		[0, "&eta;"],
		[0, "&theta;"],
		[0, "&iota;"],
		[0, "&kappa;"],
		[0, "&lambda;"],
		[0, "&mu;"],
		[0, "&nu;"],
		[0, "&xi;"],
		[0, "&omicron;"],
		[0, "&pi;"],
		[0, "&rho;"],
		[0, "&sigmaf;"],
		[0, "&sigma;"],
		[0, "&tau;"],
		[0, "&upsi;"],
		[0, "&phi;"],
		[0, "&chi;"],
		[0, "&psi;"],
		[0, "&omega;"],
		[7, "&thetasym;"],
		[0, "&Upsi;"],
		[2, "&phiv;"],
		[0, "&piv;"],
		[5, "&Gammad;"],
		[0, "&digamma;"],
		[18, "&kappav;"],
		[0, "&rhov;"],
		[3, "&epsiv;"],
		[0, "&backepsilon;"],
		[10, "&IOcy;"],
		[0, "&DJcy;"],
		[0, "&GJcy;"],
		[0, "&Jukcy;"],
		[0, "&DScy;"],
		[0, "&Iukcy;"],
		[0, "&YIcy;"],
		[0, "&Jsercy;"],
		[0, "&LJcy;"],
		[0, "&NJcy;"],
		[0, "&TSHcy;"],
		[0, "&KJcy;"],
		[1, "&Ubrcy;"],
		[0, "&DZcy;"],
		[0, "&Acy;"],
		[0, "&Bcy;"],
		[0, "&Vcy;"],
		[0, "&Gcy;"],
		[0, "&Dcy;"],
		[0, "&IEcy;"],
		[0, "&ZHcy;"],
		[0, "&Zcy;"],
		[0, "&Icy;"],
		[0, "&Jcy;"],
		[0, "&Kcy;"],
		[0, "&Lcy;"],
		[0, "&Mcy;"],
		[0, "&Ncy;"],
		[0, "&Ocy;"],
		[0, "&Pcy;"],
		[0, "&Rcy;"],
		[0, "&Scy;"],
		[0, "&Tcy;"],
		[0, "&Ucy;"],
		[0, "&Fcy;"],
		[0, "&KHcy;"],
		[0, "&TScy;"],
		[0, "&CHcy;"],
		[0, "&SHcy;"],
		[0, "&SHCHcy;"],
		[0, "&HARDcy;"],
		[0, "&Ycy;"],
		[0, "&SOFTcy;"],
		[0, "&Ecy;"],
		[0, "&YUcy;"],
		[0, "&YAcy;"],
		[0, "&acy;"],
		[0, "&bcy;"],
		[0, "&vcy;"],
		[0, "&gcy;"],
		[0, "&dcy;"],
		[0, "&iecy;"],
		[0, "&zhcy;"],
		[0, "&zcy;"],
		[0, "&icy;"],
		[0, "&jcy;"],
		[0, "&kcy;"],
		[0, "&lcy;"],
		[0, "&mcy;"],
		[0, "&ncy;"],
		[0, "&ocy;"],
		[0, "&pcy;"],
		[0, "&rcy;"],
		[0, "&scy;"],
		[0, "&tcy;"],
		[0, "&ucy;"],
		[0, "&fcy;"],
		[0, "&khcy;"],
		[0, "&tscy;"],
		[0, "&chcy;"],
		[0, "&shcy;"],
		[0, "&shchcy;"],
		[0, "&hardcy;"],
		[0, "&ycy;"],
		[0, "&softcy;"],
		[0, "&ecy;"],
		[0, "&yucy;"],
		[0, "&yacy;"],
		[1, "&iocy;"],
		[0, "&djcy;"],
		[0, "&gjcy;"],
		[0, "&jukcy;"],
		[0, "&dscy;"],
		[0, "&iukcy;"],
		[0, "&yicy;"],
		[0, "&jsercy;"],
		[0, "&ljcy;"],
		[0, "&njcy;"],
		[0, "&tshcy;"],
		[0, "&kjcy;"],
		[1, "&ubrcy;"],
		[0, "&dzcy;"],
		[7074, "&ensp;"],
		[0, "&emsp;"],
		[0, "&emsp13;"],
		[0, "&emsp14;"],
		[1, "&numsp;"],
		[0, "&puncsp;"],
		[0, "&ThinSpace;"],
		[0, "&hairsp;"],
		[0, "&NegativeMediumSpace;"],
		[0, "&zwnj;"],
		[0, "&zwj;"],
		[0, "&lrm;"],
		[0, "&rlm;"],
		[0, "&dash;"],
		[2, "&ndash;"],
		[0, "&mdash;"],
		[0, "&horbar;"],
		[0, "&Verbar;"],
		[1, "&lsquo;"],
		[0, "&CloseCurlyQuote;"],
		[0, "&lsquor;"],
		[1, "&ldquo;"],
		[0, "&CloseCurlyDoubleQuote;"],
		[0, "&bdquo;"],
		[1, "&dagger;"],
		[0, "&Dagger;"],
		[0, "&bull;"],
		[2, "&nldr;"],
		[0, "&hellip;"],
		[9, "&permil;"],
		[0, "&pertenk;"],
		[0, "&prime;"],
		[0, "&Prime;"],
		[0, "&tprime;"],
		[0, "&backprime;"],
		[3, "&lsaquo;"],
		[0, "&rsaquo;"],
		[3, "&oline;"],
		[2, "&caret;"],
		[1, "&hybull;"],
		[0, "&frasl;"],
		[10, "&bsemi;"],
		[7, "&qprime;"],
		[7, {
			v: "&MediumSpace;",
			n: 8202,
			o: "&ThickSpace;"
		}],
		[0, "&NoBreak;"],
		[0, "&af;"],
		[0, "&InvisibleTimes;"],
		[0, "&ic;"],
		[72, "&euro;"],
		[46, "&tdot;"],
		[0, "&DotDot;"],
		[37, "&complexes;"],
		[2, "&incare;"],
		[4, "&gscr;"],
		[0, "&hamilt;"],
		[0, "&Hfr;"],
		[0, "&Hopf;"],
		[0, "&planckh;"],
		[0, "&hbar;"],
		[0, "&imagline;"],
		[0, "&Ifr;"],
		[0, "&lagran;"],
		[0, "&ell;"],
		[1, "&naturals;"],
		[0, "&numero;"],
		[0, "&copysr;"],
		[0, "&weierp;"],
		[0, "&Popf;"],
		[0, "&Qopf;"],
		[0, "&realine;"],
		[0, "&real;"],
		[0, "&reals;"],
		[0, "&rx;"],
		[3, "&trade;"],
		[1, "&integers;"],
		[2, "&mho;"],
		[0, "&zeetrf;"],
		[0, "&iiota;"],
		[2, "&bernou;"],
		[0, "&Cayleys;"],
		[1, "&escr;"],
		[0, "&Escr;"],
		[0, "&Fouriertrf;"],
		[1, "&Mellintrf;"],
		[0, "&order;"],
		[0, "&alefsym;"],
		[0, "&beth;"],
		[0, "&gimel;"],
		[0, "&daleth;"],
		[12, "&CapitalDifferentialD;"],
		[0, "&dd;"],
		[0, "&ee;"],
		[0, "&ii;"],
		[10, "&frac13;"],
		[0, "&frac23;"],
		[0, "&frac15;"],
		[0, "&frac25;"],
		[0, "&frac35;"],
		[0, "&frac45;"],
		[0, "&frac16;"],
		[0, "&frac56;"],
		[0, "&frac18;"],
		[0, "&frac38;"],
		[0, "&frac58;"],
		[0, "&frac78;"],
		[49, "&larr;"],
		[0, "&ShortUpArrow;"],
		[0, "&rarr;"],
		[0, "&darr;"],
		[0, "&harr;"],
		[0, "&updownarrow;"],
		[0, "&nwarr;"],
		[0, "&nearr;"],
		[0, "&LowerRightArrow;"],
		[0, "&LowerLeftArrow;"],
		[0, "&nlarr;"],
		[0, "&nrarr;"],
		[1, {
			v: "&rarrw;",
			n: 824,
			o: "&nrarrw;"
		}],
		[0, "&Larr;"],
		[0, "&Uarr;"],
		[0, "&Rarr;"],
		[0, "&Darr;"],
		[0, "&larrtl;"],
		[0, "&rarrtl;"],
		[0, "&LeftTeeArrow;"],
		[0, "&mapstoup;"],
		[0, "&map;"],
		[0, "&DownTeeArrow;"],
		[1, "&hookleftarrow;"],
		[0, "&hookrightarrow;"],
		[0, "&larrlp;"],
		[0, "&looparrowright;"],
		[0, "&harrw;"],
		[0, "&nharr;"],
		[1, "&lsh;"],
		[0, "&rsh;"],
		[0, "&ldsh;"],
		[0, "&rdsh;"],
		[1, "&crarr;"],
		[0, "&cularr;"],
		[0, "&curarr;"],
		[2, "&circlearrowleft;"],
		[0, "&circlearrowright;"],
		[0, "&leftharpoonup;"],
		[0, "&DownLeftVector;"],
		[0, "&RightUpVector;"],
		[0, "&LeftUpVector;"],
		[0, "&rharu;"],
		[0, "&DownRightVector;"],
		[0, "&dharr;"],
		[0, "&dharl;"],
		[0, "&RightArrowLeftArrow;"],
		[0, "&udarr;"],
		[0, "&LeftArrowRightArrow;"],
		[0, "&leftleftarrows;"],
		[0, "&upuparrows;"],
		[0, "&rightrightarrows;"],
		[0, "&ddarr;"],
		[0, "&leftrightharpoons;"],
		[0, "&Equilibrium;"],
		[0, "&nlArr;"],
		[0, "&nhArr;"],
		[0, "&nrArr;"],
		[0, "&DoubleLeftArrow;"],
		[0, "&DoubleUpArrow;"],
		[0, "&DoubleRightArrow;"],
		[0, "&dArr;"],
		[0, "&DoubleLeftRightArrow;"],
		[0, "&DoubleUpDownArrow;"],
		[0, "&nwArr;"],
		[0, "&neArr;"],
		[0, "&seArr;"],
		[0, "&swArr;"],
		[0, "&lAarr;"],
		[0, "&rAarr;"],
		[1, "&zigrarr;"],
		[6, "&larrb;"],
		[0, "&rarrb;"],
		[15, "&DownArrowUpArrow;"],
		[7, "&loarr;"],
		[0, "&roarr;"],
		[0, "&hoarr;"],
		[0, "&forall;"],
		[0, "&comp;"],
		[0, {
			v: "&part;",
			n: 824,
			o: "&npart;"
		}],
		[0, "&exist;"],
		[0, "&nexist;"],
		[0, "&empty;"],
		[1, "&Del;"],
		[0, "&Element;"],
		[0, "&NotElement;"],
		[1, "&ni;"],
		[0, "&notni;"],
		[2, "&prod;"],
		[0, "&coprod;"],
		[0, "&sum;"],
		[0, "&minus;"],
		[0, "&MinusPlus;"],
		[0, "&dotplus;"],
		[1, "&Backslash;"],
		[0, "&lowast;"],
		[0, "&compfn;"],
		[1, "&radic;"],
		[2, "&prop;"],
		[0, "&infin;"],
		[0, "&angrt;"],
		[0, {
			v: "&ang;",
			n: 8402,
			o: "&nang;"
		}],
		[0, "&angmsd;"],
		[0, "&angsph;"],
		[0, "&mid;"],
		[0, "&nmid;"],
		[0, "&DoubleVerticalBar;"],
		[0, "&NotDoubleVerticalBar;"],
		[0, "&and;"],
		[0, "&or;"],
		[0, {
			v: "&cap;",
			n: 65024,
			o: "&caps;"
		}],
		[0, {
			v: "&cup;",
			n: 65024,
			o: "&cups;"
		}],
		[0, "&int;"],
		[0, "&Int;"],
		[0, "&iiint;"],
		[0, "&conint;"],
		[0, "&Conint;"],
		[0, "&Cconint;"],
		[0, "&cwint;"],
		[0, "&ClockwiseContourIntegral;"],
		[0, "&awconint;"],
		[0, "&there4;"],
		[0, "&becaus;"],
		[0, "&ratio;"],
		[0, "&Colon;"],
		[0, "&dotminus;"],
		[1, "&mDDot;"],
		[0, "&homtht;"],
		[0, {
			v: "&sim;",
			n: 8402,
			o: "&nvsim;"
		}],
		[0, {
			v: "&backsim;",
			n: 817,
			o: "&race;"
		}],
		[0, {
			v: "&ac;",
			n: 819,
			o: "&acE;"
		}],
		[0, "&acd;"],
		[0, "&VerticalTilde;"],
		[0, "&NotTilde;"],
		[0, {
			v: "&eqsim;",
			n: 824,
			o: "&nesim;"
		}],
		[0, "&sime;"],
		[0, "&NotTildeEqual;"],
		[0, "&cong;"],
		[0, "&simne;"],
		[0, "&ncong;"],
		[0, "&ap;"],
		[0, "&nap;"],
		[0, "&ape;"],
		[0, {
			v: "&apid;",
			n: 824,
			o: "&napid;"
		}],
		[0, "&backcong;"],
		[0, {
			v: "&asympeq;",
			n: 8402,
			o: "&nvap;"
		}],
		[0, {
			v: "&bump;",
			n: 824,
			o: "&nbump;"
		}],
		[0, {
			v: "&bumpe;",
			n: 824,
			o: "&nbumpe;"
		}],
		[0, {
			v: "&doteq;",
			n: 824,
			o: "&nedot;"
		}],
		[0, "&doteqdot;"],
		[0, "&efDot;"],
		[0, "&erDot;"],
		[0, "&Assign;"],
		[0, "&ecolon;"],
		[0, "&ecir;"],
		[0, "&circeq;"],
		[1, "&wedgeq;"],
		[0, "&veeeq;"],
		[1, "&triangleq;"],
		[2, "&equest;"],
		[0, "&ne;"],
		[0, {
			v: "&Congruent;",
			n: 8421,
			o: "&bnequiv;"
		}],
		[0, "&nequiv;"],
		[1, {
			v: "&le;",
			n: 8402,
			o: "&nvle;"
		}],
		[0, {
			v: "&ge;",
			n: 8402,
			o: "&nvge;"
		}],
		[0, {
			v: "&lE;",
			n: 824,
			o: "&nlE;"
		}],
		[0, {
			v: "&gE;",
			n: 824,
			o: "&ngE;"
		}],
		[0, {
			v: "&lnE;",
			n: 65024,
			o: "&lvertneqq;"
		}],
		[0, {
			v: "&gnE;",
			n: 65024,
			o: "&gvertneqq;"
		}],
		[0, {
			v: "&ll;",
			n: new Map(
				/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])
)
		}],
		[0, {
			v: "&gg;",
			n: new Map(
				/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])
)
		}],
		[0, "&between;"],
		[0, "&NotCupCap;"],
		[0, "&nless;"],
		[0, "&ngt;"],
		[0, "&nle;"],
		[0, "&nge;"],
		[0, "&lesssim;"],
		[0, "&GreaterTilde;"],
		[0, "&nlsim;"],
		[0, "&ngsim;"],
		[0, "&LessGreater;"],
		[0, "&gl;"],
		[0, "&NotLessGreater;"],
		[0, "&NotGreaterLess;"],
		[0, "&pr;"],
		[0, "&sc;"],
		[0, "&prcue;"],
		[0, "&sccue;"],
		[0, "&PrecedesTilde;"],
		[0, {
			v: "&scsim;",
			n: 824,
			o: "&NotSucceedsTilde;"
		}],
		[0, "&NotPrecedes;"],
		[0, "&NotSucceeds;"],
		[0, {
			v: "&sub;",
			n: 8402,
			o: "&NotSubset;"
		}],
		[0, {
			v: "&sup;",
			n: 8402,
			o: "&NotSuperset;"
		}],
		[0, "&nsub;"],
		[0, "&nsup;"],
		[0, "&sube;"],
		[0, "&supe;"],
		[0, "&NotSubsetEqual;"],
		[0, "&NotSupersetEqual;"],
		[0, {
			v: "&subne;",
			n: 65024,
			o: "&varsubsetneq;"
		}],
		[0, {
			v: "&supne;",
			n: 65024,
			o: "&varsupsetneq;"
		}],
		[1, "&cupdot;"],
		[0, "&UnionPlus;"],
		[0, {
			v: "&sqsub;",
			n: 824,
			o: "&NotSquareSubset;"
		}],
		[0, {
			v: "&sqsup;",
			n: 824,
			o: "&NotSquareSuperset;"
		}],
		[0, "&sqsube;"],
		[0, "&sqsupe;"],
		[0, {
			v: "&sqcap;",
			n: 65024,
			o: "&sqcaps;"
		}],
		[0, {
			v: "&sqcup;",
			n: 65024,
			o: "&sqcups;"
		}],
		[0, "&CirclePlus;"],
		[0, "&CircleMinus;"],
		[0, "&CircleTimes;"],
		[0, "&osol;"],
		[0, "&CircleDot;"],
		[0, "&circledcirc;"],
		[0, "&circledast;"],
		[1, "&circleddash;"],
		[0, "&boxplus;"],
		[0, "&boxminus;"],
		[0, "&boxtimes;"],
		[0, "&dotsquare;"],
		[0, "&RightTee;"],
		[0, "&dashv;"],
		[0, "&DownTee;"],
		[0, "&bot;"],
		[1, "&models;"],
		[0, "&DoubleRightTee;"],
		[0, "&Vdash;"],
		[0, "&Vvdash;"],
		[0, "&VDash;"],
		[0, "&nvdash;"],
		[0, "&nvDash;"],
		[0, "&nVdash;"],
		[0, "&nVDash;"],
		[0, "&prurel;"],
		[1, "&LeftTriangle;"],
		[0, "&RightTriangle;"],
		[0, {
			v: "&LeftTriangleEqual;",
			n: 8402,
			o: "&nvltrie;"
		}],
		[0, {
			v: "&RightTriangleEqual;",
			n: 8402,
			o: "&nvrtrie;"
		}],
		[0, "&origof;"],
		[0, "&imof;"],
		[0, "&multimap;"],
		[0, "&hercon;"],
		[0, "&intcal;"],
		[0, "&veebar;"],
		[1, "&barvee;"],
		[0, "&angrtvb;"],
		[0, "&lrtri;"],
		[0, "&bigwedge;"],
		[0, "&bigvee;"],
		[0, "&bigcap;"],
		[0, "&bigcup;"],
		[0, "&diam;"],
		[0, "&sdot;"],
		[0, "&sstarf;"],
		[0, "&divideontimes;"],
		[0, "&bowtie;"],
		[0, "&ltimes;"],
		[0, "&rtimes;"],
		[0, "&leftthreetimes;"],
		[0, "&rightthreetimes;"],
		[0, "&backsimeq;"],
		[0, "&curlyvee;"],
		[0, "&curlywedge;"],
		[0, "&Sub;"],
		[0, "&Sup;"],
		[0, "&Cap;"],
		[0, "&Cup;"],
		[0, "&fork;"],
		[0, "&epar;"],
		[0, "&lessdot;"],
		[0, "&gtdot;"],
		[0, {
			v: "&Ll;",
			n: 824,
			o: "&nLl;"
		}],
		[0, {
			v: "&Gg;",
			n: 824,
			o: "&nGg;"
		}],
		[0, {
			v: "&leg;",
			n: 65024,
			o: "&lesg;"
		}],
		[0, {
			v: "&gel;",
			n: 65024,
			o: "&gesl;"
		}],
		[2, "&cuepr;"],
		[0, "&cuesc;"],
		[0, "&NotPrecedesSlantEqual;"],
		[0, "&NotSucceedsSlantEqual;"],
		[0, "&NotSquareSubsetEqual;"],
		[0, "&NotSquareSupersetEqual;"],
		[2, "&lnsim;"],
		[0, "&gnsim;"],
		[0, "&precnsim;"],
		[0, "&scnsim;"],
		[0, "&nltri;"],
		[0, "&NotRightTriangle;"],
		[0, "&nltrie;"],
		[0, "&NotRightTriangleEqual;"],
		[0, "&vellip;"],
		[0, "&ctdot;"],
		[0, "&utdot;"],
		[0, "&dtdot;"],
		[0, "&disin;"],
		[0, "&isinsv;"],
		[0, "&isins;"],
		[0, {
			v: "&isindot;",
			n: 824,
			o: "&notindot;"
		}],
		[0, "&notinvc;"],
		[0, "&notinvb;"],
		[1, {
			v: "&isinE;",
			n: 824,
			o: "&notinE;"
		}],
		[0, "&nisd;"],
		[0, "&xnis;"],
		[0, "&nis;"],
		[0, "&notnivc;"],
		[0, "&notnivb;"],
		[6, "&barwed;"],
		[0, "&Barwed;"],
		[1, "&lceil;"],
		[0, "&rceil;"],
		[0, "&LeftFloor;"],
		[0, "&rfloor;"],
		[0, "&drcrop;"],
		[0, "&dlcrop;"],
		[0, "&urcrop;"],
		[0, "&ulcrop;"],
		[0, "&bnot;"],
		[1, "&profline;"],
		[0, "&profsurf;"],
		[1, "&telrec;"],
		[0, "&target;"],
		[5, "&ulcorn;"],
		[0, "&urcorn;"],
		[0, "&dlcorn;"],
		[0, "&drcorn;"],
		[2, "&frown;"],
		[0, "&smile;"],
		[9, "&cylcty;"],
		[0, "&profalar;"],
		[7, "&topbot;"],
		[6, "&ovbar;"],
		[1, "&solbar;"],
		[60, "&angzarr;"],
		[51, "&lmoustache;"],
		[0, "&rmoustache;"],
		[2, "&OverBracket;"],
		[0, "&bbrk;"],
		[0, "&bbrktbrk;"],
		[37, "&OverParenthesis;"],
		[0, "&UnderParenthesis;"],
		[0, "&OverBrace;"],
		[0, "&UnderBrace;"],
		[2, "&trpezium;"],
		[4, "&elinters;"],
		[59, "&blank;"],
		[164, "&circledS;"],
		[55, "&boxh;"],
		[1, "&boxv;"],
		[9, "&boxdr;"],
		[3, "&boxdl;"],
		[3, "&boxur;"],
		[3, "&boxul;"],
		[3, "&boxvr;"],
		[7, "&boxvl;"],
		[7, "&boxhd;"],
		[7, "&boxhu;"],
		[7, "&boxvh;"],
		[19, "&boxH;"],
		[0, "&boxV;"],
		[0, "&boxdR;"],
		[0, "&boxDr;"],
		[0, "&boxDR;"],
		[0, "&boxdL;"],
		[0, "&boxDl;"],
		[0, "&boxDL;"],
		[0, "&boxuR;"],
		[0, "&boxUr;"],
		[0, "&boxUR;"],
		[0, "&boxuL;"],
		[0, "&boxUl;"],
		[0, "&boxUL;"],
		[0, "&boxvR;"],
		[0, "&boxVr;"],
		[0, "&boxVR;"],
		[0, "&boxvL;"],
		[0, "&boxVl;"],
		[0, "&boxVL;"],
		[0, "&boxHd;"],
		[0, "&boxhD;"],
		[0, "&boxHD;"],
		[0, "&boxHu;"],
		[0, "&boxhU;"],
		[0, "&boxHU;"],
		[0, "&boxvH;"],
		[0, "&boxVh;"],
		[0, "&boxVH;"],
		[19, "&uhblk;"],
		[3, "&lhblk;"],
		[3, "&block;"],
		[8, "&blk14;"],
		[0, "&blk12;"],
		[0, "&blk34;"],
		[13, "&square;"],
		[8, "&blacksquare;"],
		[0, "&EmptyVerySmallSquare;"],
		[1, "&rect;"],
		[0, "&marker;"],
		[2, "&fltns;"],
		[1, "&bigtriangleup;"],
		[0, "&blacktriangle;"],
		[0, "&triangle;"],
		[2, "&blacktriangleright;"],
		[0, "&rtri;"],
		[3, "&bigtriangledown;"],
		[0, "&blacktriangledown;"],
		[0, "&dtri;"],
		[2, "&blacktriangleleft;"],
		[0, "&ltri;"],
		[6, "&loz;"],
		[0, "&cir;"],
		[32, "&tridot;"],
		[2, "&bigcirc;"],
		[8, "&ultri;"],
		[0, "&urtri;"],
		[0, "&lltri;"],
		[0, "&EmptySmallSquare;"],
		[0, "&FilledSmallSquare;"],
		[8, "&bigstar;"],
		[0, "&star;"],
		[7, "&phone;"],
		[49, "&female;"],
		[1, "&male;"],
		[29, "&spades;"],
		[2, "&clubs;"],
		[1, "&hearts;"],
		[0, "&diamondsuit;"],
		[3, "&sung;"],
		[2, "&flat;"],
		[0, "&natural;"],
		[0, "&sharp;"],
		[163, "&check;"],
		[3, "&cross;"],
		[8, "&malt;"],
		[21, "&sext;"],
		[33, "&VerticalSeparator;"],
		[25, "&lbbrk;"],
		[0, "&rbbrk;"],
		[84, "&bsolhsub;"],
		[0, "&suphsol;"],
		[28, "&LeftDoubleBracket;"],
		[0, "&RightDoubleBracket;"],
		[0, "&lang;"],
		[0, "&rang;"],
		[0, "&Lang;"],
		[0, "&Rang;"],
		[0, "&loang;"],
		[0, "&roang;"],
		[7, "&longleftarrow;"],
		[0, "&longrightarrow;"],
		[0, "&longleftrightarrow;"],
		[0, "&DoubleLongLeftArrow;"],
		[0, "&DoubleLongRightArrow;"],
		[0, "&DoubleLongLeftRightArrow;"],
		[1, "&longmapsto;"],
		[2, "&dzigrarr;"],
		[258, "&nvlArr;"],
		[0, "&nvrArr;"],
		[0, "&nvHarr;"],
		[0, "&Map;"],
		[6, "&lbarr;"],
		[0, "&bkarow;"],
		[0, "&lBarr;"],
		[0, "&dbkarow;"],
		[0, "&drbkarow;"],
		[0, "&DDotrahd;"],
		[0, "&UpArrowBar;"],
		[0, "&DownArrowBar;"],
		[2, "&Rarrtl;"],
		[2, "&latail;"],
		[0, "&ratail;"],
		[0, "&lAtail;"],
		[0, "&rAtail;"],
		[0, "&larrfs;"],
		[0, "&rarrfs;"],
		[0, "&larrbfs;"],
		[0, "&rarrbfs;"],
		[2, "&nwarhk;"],
		[0, "&nearhk;"],
		[0, "&hksearow;"],
		[0, "&hkswarow;"],
		[0, "&nwnear;"],
		[0, "&nesear;"],
		[0, "&seswar;"],
		[0, "&swnwar;"],
		[8, {
			v: "&rarrc;",
			n: 824,
			o: "&nrarrc;"
		}],
		[1, "&cudarrr;"],
		[0, "&ldca;"],
		[0, "&rdca;"],
		[0, "&cudarrl;"],
		[0, "&larrpl;"],
		[2, "&curarrm;"],
		[0, "&cularrp;"],
		[7, "&rarrpl;"],
		[2, "&harrcir;"],
		[0, "&Uarrocir;"],
		[0, "&lurdshar;"],
		[0, "&ldrushar;"],
		[2, "&LeftRightVector;"],
		[0, "&RightUpDownVector;"],
		[0, "&DownLeftRightVector;"],
		[0, "&LeftUpDownVector;"],
		[0, "&LeftVectorBar;"],
		[0, "&RightVectorBar;"],
		[0, "&RightUpVectorBar;"],
		[0, "&RightDownVectorBar;"],
		[0, "&DownLeftVectorBar;"],
		[0, "&DownRightVectorBar;"],
		[0, "&LeftUpVectorBar;"],
		[0, "&LeftDownVectorBar;"],
		[0, "&LeftTeeVector;"],
		[0, "&RightTeeVector;"],
		[0, "&RightUpTeeVector;"],
		[0, "&RightDownTeeVector;"],
		[0, "&DownLeftTeeVector;"],
		[0, "&DownRightTeeVector;"],
		[0, "&LeftUpTeeVector;"],
		[0, "&LeftDownTeeVector;"],
		[0, "&lHar;"],
		[0, "&uHar;"],
		[0, "&rHar;"],
		[0, "&dHar;"],
		[0, "&luruhar;"],
		[0, "&ldrdhar;"],
		[0, "&ruluhar;"],
		[0, "&rdldhar;"],
		[0, "&lharul;"],
		[0, "&llhard;"],
		[0, "&rharul;"],
		[0, "&lrhard;"],
		[0, "&udhar;"],
		[0, "&duhar;"],
		[0, "&RoundImplies;"],
		[0, "&erarr;"],
		[0, "&simrarr;"],
		[0, "&larrsim;"],
		[0, "&rarrsim;"],
		[0, "&rarrap;"],
		[0, "&ltlarr;"],
		[1, "&gtrarr;"],
		[0, "&subrarr;"],
		[1, "&suplarr;"],
		[0, "&lfisht;"],
		[0, "&rfisht;"],
		[0, "&ufisht;"],
		[0, "&dfisht;"],
		[5, "&lopar;"],
		[0, "&ropar;"],
		[4, "&lbrke;"],
		[0, "&rbrke;"],
		[0, "&lbrkslu;"],
		[0, "&rbrksld;"],
		[0, "&lbrksld;"],
		[0, "&rbrkslu;"],
		[0, "&langd;"],
		[0, "&rangd;"],
		[0, "&lparlt;"],
		[0, "&rpargt;"],
		[0, "&gtlPar;"],
		[0, "&ltrPar;"],
		[3, "&vzigzag;"],
		[1, "&vangrt;"],
		[0, "&angrtvbd;"],
		[6, "&ange;"],
		[0, "&range;"],
		[0, "&dwangle;"],
		[0, "&uwangle;"],
		[0, "&angmsdaa;"],
		[0, "&angmsdab;"],
		[0, "&angmsdac;"],
		[0, "&angmsdad;"],
		[0, "&angmsdae;"],
		[0, "&angmsdaf;"],
		[0, "&angmsdag;"],
		[0, "&angmsdah;"],
		[0, "&bemptyv;"],
		[0, "&demptyv;"],
		[0, "&cemptyv;"],
		[0, "&raemptyv;"],
		[0, "&laemptyv;"],
		[0, "&ohbar;"],
		[0, "&omid;"],
		[0, "&opar;"],
		[1, "&operp;"],
		[1, "&olcross;"],
		[0, "&odsold;"],
		[1, "&olcir;"],
		[0, "&ofcir;"],
		[0, "&olt;"],
		[0, "&ogt;"],
		[0, "&cirscir;"],
		[0, "&cirE;"],
		[0, "&solb;"],
		[0, "&bsolb;"],
		[3, "&boxbox;"],
		[3, "&trisb;"],
		[0, "&rtriltri;"],
		[0, {
			v: "&LeftTriangleBar;",
			n: 824,
			o: "&NotLeftTriangleBar;"
		}],
		[0, {
			v: "&RightTriangleBar;",
			n: 824,
			o: "&NotRightTriangleBar;"
		}],
		[11, "&iinfin;"],
		[0, "&infintie;"],
		[0, "&nvinfin;"],
		[4, "&eparsl;"],
		[0, "&smeparsl;"],
		[0, "&eqvparsl;"],
		[5, "&blacklozenge;"],
		[8, "&RuleDelayed;"],
		[1, "&dsol;"],
		[9, "&bigodot;"],
		[0, "&bigoplus;"],
		[0, "&bigotimes;"],
		[1, "&biguplus;"],
		[1, "&bigsqcup;"],
		[5, "&iiiint;"],
		[0, "&fpartint;"],
		[2, "&cirfnint;"],
		[0, "&awint;"],
		[0, "&rppolint;"],
		[0, "&scpolint;"],
		[0, "&npolint;"],
		[0, "&pointint;"],
		[0, "&quatint;"],
		[0, "&intlarhk;"],
		[10, "&pluscir;"],
		[0, "&plusacir;"],
		[0, "&simplus;"],
		[0, "&plusdu;"],
		[0, "&plussim;"],
		[0, "&plustwo;"],
		[1, "&mcomma;"],
		[0, "&minusdu;"],
		[2, "&loplus;"],
		[0, "&roplus;"],
		[0, "&Cross;"],
		[0, "&timesd;"],
		[0, "&timesbar;"],
		[1, "&smashp;"],
		[0, "&lotimes;"],
		[0, "&rotimes;"],
		[0, "&otimesas;"],
		[0, "&Otimes;"],
		[0, "&odiv;"],
		[0, "&triplus;"],
		[0, "&triminus;"],
		[0, "&tritime;"],
		[0, "&intprod;"],
		[2, "&amalg;"],
		[0, "&capdot;"],
		[1, "&ncup;"],
		[0, "&ncap;"],
		[0, "&capand;"],
		[0, "&cupor;"],
		[0, "&cupcap;"],
		[0, "&capcup;"],
		[0, "&cupbrcap;"],
		[0, "&capbrcup;"],
		[0, "&cupcup;"],
		[0, "&capcap;"],
		[0, "&ccups;"],
		[0, "&ccaps;"],
		[2, "&ccupssm;"],
		[2, "&And;"],
		[0, "&Or;"],
		[0, "&andand;"],
		[0, "&oror;"],
		[0, "&orslope;"],
		[0, "&andslope;"],
		[1, "&andv;"],
		[0, "&orv;"],
		[0, "&andd;"],
		[0, "&ord;"],
		[1, "&wedbar;"],
		[6, "&sdote;"],
		[3, "&simdot;"],
		[2, {
			v: "&congdot;",
			n: 824,
			o: "&ncongdot;"
		}],
		[0, "&easter;"],
		[0, "&apacir;"],
		[0, {
			v: "&apE;",
			n: 824,
			o: "&napE;"
		}],
		[0, "&eplus;"],
		[0, "&pluse;"],
		[0, "&Esim;"],
		[0, "&Colone;"],
		[0, "&Equal;"],
		[1, "&ddotseq;"],
		[0, "&equivDD;"],
		[0, "&ltcir;"],
		[0, "&gtcir;"],
		[0, "&ltquest;"],
		[0, "&gtquest;"],
		[0, {
			v: "&leqslant;",
			n: 824,
			o: "&nleqslant;"
		}],
		[0, {
			v: "&geqslant;",
			n: 824,
			o: "&ngeqslant;"
		}],
		[0, "&lesdot;"],
		[0, "&gesdot;"],
		[0, "&lesdoto;"],
		[0, "&gesdoto;"],
		[0, "&lesdotor;"],
		[0, "&gesdotol;"],
		[0, "&lap;"],
		[0, "&gap;"],
		[0, "&lne;"],
		[0, "&gne;"],
		[0, "&lnap;"],
		[0, "&gnap;"],
		[0, "&lEg;"],
		[0, "&gEl;"],
		[0, "&lsime;"],
		[0, "&gsime;"],
		[0, "&lsimg;"],
		[0, "&gsiml;"],
		[0, "&lgE;"],
		[0, "&glE;"],
		[0, "&lesges;"],
		[0, "&gesles;"],
		[0, "&els;"],
		[0, "&egs;"],
		[0, "&elsdot;"],
		[0, "&egsdot;"],
		[0, "&el;"],
		[0, "&eg;"],
		[2, "&siml;"],
		[0, "&simg;"],
		[0, "&simlE;"],
		[0, "&simgE;"],
		[0, {
			v: "&LessLess;",
			n: 824,
			o: "&NotNestedLessLess;"
		}],
		[0, {
			v: "&GreaterGreater;",
			n: 824,
			o: "&NotNestedGreaterGreater;"
		}],
		[1, "&glj;"],
		[0, "&gla;"],
		[0, "&ltcc;"],
		[0, "&gtcc;"],
		[0, "&lescc;"],
		[0, "&gescc;"],
		[0, "&smt;"],
		[0, "&lat;"],
		[0, {
			v: "&smte;",
			n: 65024,
			o: "&smtes;"
		}],
		[0, {
			v: "&late;",
			n: 65024,
			o: "&lates;"
		}],
		[0, "&bumpE;"],
		[0, {
			v: "&PrecedesEqual;",
			n: 824,
			o: "&NotPrecedesEqual;"
		}],
		[0, {
			v: "&sce;",
			n: 824,
			o: "&NotSucceedsEqual;"
		}],
		[2, "&prE;"],
		[0, "&scE;"],
		[0, "&precneqq;"],
		[0, "&scnE;"],
		[0, "&prap;"],
		[0, "&scap;"],
		[0, "&precnapprox;"],
		[0, "&scnap;"],
		[0, "&Pr;"],
		[0, "&Sc;"],
		[0, "&subdot;"],
		[0, "&supdot;"],
		[0, "&subplus;"],
		[0, "&supplus;"],
		[0, "&submult;"],
		[0, "&supmult;"],
		[0, "&subedot;"],
		[0, "&supedot;"],
		[0, {
			v: "&subE;",
			n: 824,
			o: "&nsubE;"
		}],
		[0, {
			v: "&supE;",
			n: 824,
			o: "&nsupE;"
		}],
		[0, "&subsim;"],
		[0, "&supsim;"],
		[2, {
			v: "&subnE;",
			n: 65024,
			o: "&varsubsetneqq;"
		}],
		[0, {
			v: "&supnE;",
			n: 65024,
			o: "&varsupsetneqq;"
		}],
		[2, "&csub;"],
		[0, "&csup;"],
		[0, "&csube;"],
		[0, "&csupe;"],
		[0, "&subsup;"],
		[0, "&supsub;"],
		[0, "&subsub;"],
		[0, "&supsup;"],
		[0, "&suphsub;"],
		[0, "&supdsub;"],
		[0, "&forkv;"],
		[0, "&topfork;"],
		[0, "&mlcp;"],
		[8, "&Dashv;"],
		[1, "&Vdashl;"],
		[0, "&Barv;"],
		[0, "&vBar;"],
		[0, "&vBarv;"],
		[1, "&Vbar;"],
		[0, "&Not;"],
		[0, "&bNot;"],
		[0, "&rnmid;"],
		[0, "&cirmid;"],
		[0, "&midcir;"],
		[0, "&topcir;"],
		[0, "&nhpar;"],
		[0, "&parsim;"],
		[9, {
			v: "&parsl;",
			n: 8421,
			o: "&nparsl;"
		}],
		[44343, { n: new Map(
			/* #__PURE__ */ restoreDiff([
				[56476, "&Ascr;"],
				[1, "&Cscr;"],
				[0, "&Dscr;"],
				[2, "&Gscr;"],
				[2, "&Jscr;"],
				[0, "&Kscr;"],
				[2, "&Nscr;"],
				[0, "&Oscr;"],
				[0, "&Pscr;"],
				[0, "&Qscr;"],
				[1, "&Sscr;"],
				[0, "&Tscr;"],
				[0, "&Uscr;"],
				[0, "&Vscr;"],
				[0, "&Wscr;"],
				[0, "&Xscr;"],
				[0, "&Yscr;"],
				[0, "&Zscr;"],
				[0, "&ascr;"],
				[0, "&bscr;"],
				[0, "&cscr;"],
				[0, "&dscr;"],
				[1, "&fscr;"],
				[1, "&hscr;"],
				[0, "&iscr;"],
				[0, "&jscr;"],
				[0, "&kscr;"],
				[0, "&lscr;"],
				[0, "&mscr;"],
				[0, "&nscr;"],
				[1, "&pscr;"],
				[0, "&qscr;"],
				[0, "&rscr;"],
				[0, "&sscr;"],
				[0, "&tscr;"],
				[0, "&uscr;"],
				[0, "&vscr;"],
				[0, "&wscr;"],
				[0, "&xscr;"],
				[0, "&yscr;"],
				[0, "&zscr;"],
				[52, "&Afr;"],
				[0, "&Bfr;"],
				[1, "&Dfr;"],
				[0, "&Efr;"],
				[0, "&Ffr;"],
				[0, "&Gfr;"],
				[2, "&Jfr;"],
				[0, "&Kfr;"],
				[0, "&Lfr;"],
				[0, "&Mfr;"],
				[0, "&Nfr;"],
				[0, "&Ofr;"],
				[0, "&Pfr;"],
				[0, "&Qfr;"],
				[1, "&Sfr;"],
				[0, "&Tfr;"],
				[0, "&Ufr;"],
				[0, "&Vfr;"],
				[0, "&Wfr;"],
				[0, "&Xfr;"],
				[0, "&Yfr;"],
				[1, "&afr;"],
				[0, "&bfr;"],
				[0, "&cfr;"],
				[0, "&dfr;"],
				[0, "&efr;"],
				[0, "&ffr;"],
				[0, "&gfr;"],
				[0, "&hfr;"],
				[0, "&ifr;"],
				[0, "&jfr;"],
				[0, "&kfr;"],
				[0, "&lfr;"],
				[0, "&mfr;"],
				[0, "&nfr;"],
				[0, "&ofr;"],
				[0, "&pfr;"],
				[0, "&qfr;"],
				[0, "&rfr;"],
				[0, "&sfr;"],
				[0, "&tfr;"],
				[0, "&ufr;"],
				[0, "&vfr;"],
				[0, "&wfr;"],
				[0, "&xfr;"],
				[0, "&yfr;"],
				[0, "&zfr;"],
				[0, "&Aopf;"],
				[0, "&Bopf;"],
				[1, "&Dopf;"],
				[0, "&Eopf;"],
				[0, "&Fopf;"],
				[0, "&Gopf;"],
				[1, "&Iopf;"],
				[0, "&Jopf;"],
				[0, "&Kopf;"],
				[0, "&Lopf;"],
				[0, "&Mopf;"],
				[1, "&Oopf;"],
				[3, "&Sopf;"],
				[0, "&Topf;"],
				[0, "&Uopf;"],
				[0, "&Vopf;"],
				[0, "&Wopf;"],
				[0, "&Xopf;"],
				[0, "&Yopf;"],
				[1, "&aopf;"],
				[0, "&bopf;"],
				[0, "&copf;"],
				[0, "&dopf;"],
				[0, "&eopf;"],
				[0, "&fopf;"],
				[0, "&gopf;"],
				[0, "&hopf;"],
				[0, "&iopf;"],
				[0, "&jopf;"],
				[0, "&kopf;"],
				[0, "&lopf;"],
				[0, "&mopf;"],
				[0, "&nopf;"],
				[0, "&oopf;"],
				[0, "&popf;"],
				[0, "&qopf;"],
				[0, "&ropf;"],
				[0, "&sopf;"],
				[0, "&topf;"],
				[0, "&uopf;"],
				[0, "&vopf;"],
				[0, "&wopf;"],
				[0, "&xopf;"],
				[0, "&yopf;"],
				[0, "&zopf;"]
			])
) }],
		[8906, "&fflig;"],
		[0, "&filig;"],
		[0, "&fllig;"],
		[0, "&ffilig;"],
		[0, "&ffllig;"]
	])
);
const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = new Map([
	[34, "&quot;"],
	[38, "&amp;"],
	[39, "&apos;"],
	[60, "&lt;"],
	[62, "&gt;"]
]);
const getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c$1, index) => (c$1.charCodeAt(index) & 64512) === 55296 ? (c$1.charCodeAt(index) - 55296) * 1024 + c$1.charCodeAt(index + 1) - 56320 + 65536 : c$1.charCodeAt(index);
function encodeXML(str) {
	let ret = "";
	let lastIdx = 0;
	let match;
	while ((match = xmlReplacer.exec(str)) !== null) {
		const i$1 = match.index;
		const char = str.charCodeAt(i$1);
		const next = xmlCodeMap.get(char);
		if (next !== undefined) {
			ret += str.substring(lastIdx, i$1) + next;
			lastIdx = i$1 + 1;
		} else {
			ret += `${str.substring(lastIdx, i$1)}&#x${getCodePoint(str, i$1).toString(16)};`;
			lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
		}
	}
	return ret + str.substr(lastIdx);
}
/**
* Creates a function that escapes all characters matched by the given regular
* expression using the given map of characters to escape to their entities.
*
* @param regex Regular expression to match characters to escape.
* @param map Map of characters to escape to their entities.
*
* @returns Function that escapes all characters matched by the given regular
* expression using the given map of characters to escape to their entities.
*/
function getEscaper(regex$1, map) {
	return function escape$1(data$1) {
		let match;
		let lastIdx = 0;
		let result = "";
		while (match = regex$1.exec(data$1)) {
			if (lastIdx !== match.index) result += data$1.substring(lastIdx, match.index);
			result += map.get(match[0].charCodeAt(0));
			lastIdx = match.index + 1;
		}
		return result + data$1.substring(lastIdx);
	};
}
const escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
	[34, "&quot;"],
	[38, "&amp;"],
	[160, "&nbsp;"]
]));
const escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
	[38, "&amp;"],
	[60, "&lt;"],
	[62, "&gt;"],
	[160, "&nbsp;"]
]));
var EntityLevel;
(function(EntityLevel$1) {
	/** Support only XML entities. */
	EntityLevel$1[EntityLevel$1["XML"] = 0] = "XML";
	/** Support HTML entities, which are a superset of XML entities. */
	EntityLevel$1[EntityLevel$1["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode$1) {
	/**
	* The output is UTF-8 encoded. Only characters that need escaping within
	* XML will be escaped.
	*/
	EncodingMode$1[EncodingMode$1["UTF8"] = 0] = "UTF8";
	/**
	* The output consists only of ASCII characters. Characters that need
	* escaping within HTML, and characters that aren't ASCII characters will
	* be escaped.
	*/
	EncodingMode$1[EncodingMode$1["ASCII"] = 1] = "ASCII";
	/**
	* Encode all characters that have an equivalent entity, as well as all
	* characters that are not ASCII characters.
	*/
	EncodingMode$1[EncodingMode$1["Extensive"] = 2] = "Extensive";
	/**
	* Encode all characters that have to be escaped in HTML attributes,
	* following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
	*/
	EncodingMode$1[EncodingMode$1["Attribute"] = 3] = "Attribute";
	/**
	* Encode all characters that have to be escaped in HTML text,
	* following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
	*/
	EncodingMode$1[EncodingMode$1["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));
const elementNames = new Map([
	"altGlyph",
	"altGlyphDef",
	"altGlyphItem",
	"animateColor",
	"animateMotion",
	"animateTransform",
	"clipPath",
	"feBlend",
	"feColorMatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feDropShadow",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence",
	"foreignObject",
	"glyphRef",
	"linearGradient",
	"radialGradient",
	"textPath"
].map((val) => [val.toLowerCase(), val]));
const attributeNames = new Map([
	"definitionURL",
	"attributeName",
	"attributeType",
	"baseFrequency",
	"baseProfile",
	"calcMode",
	"clipPathUnits",
	"diffuseConstant",
	"edgeMode",
	"filterUnits",
	"glyphRef",
	"gradientTransform",
	"gradientUnits",
	"kernelMatrix",
	"kernelUnitLength",
	"keyPoints",
	"keySplines",
	"keyTimes",
	"lengthAdjust",
	"limitingConeAngle",
	"markerHeight",
	"markerUnits",
	"markerWidth",
	"maskContentUnits",
	"maskUnits",
	"numOctaves",
	"pathLength",
	"patternContentUnits",
	"patternTransform",
	"patternUnits",
	"pointsAtX",
	"pointsAtY",
	"pointsAtZ",
	"preserveAlpha",
	"preserveAspectRatio",
	"primitiveUnits",
	"refX",
	"refY",
	"repeatCount",
	"repeatDur",
	"requiredExtensions",
	"requiredFeatures",
	"specularConstant",
	"specularExponent",
	"spreadMethod",
	"startOffset",
	"stdDeviation",
	"stitchTiles",
	"surfaceScale",
	"systemLanguage",
	"tableValues",
	"targetX",
	"targetY",
	"textLength",
	"viewBox",
	"viewTarget",
	"xChannelSelector",
	"yChannelSelector",
	"zoomAndPan"
].map((val) => [val.toLowerCase(), val]));
const unencodedElements = new Set([
	"style",
	"script",
	"xmp",
	"iframe",
	"noembed",
	"noframes",
	"plaintext",
	"noscript"
]);
function replaceQuotes(value) {
	return value.replace(/"/g, "&quot;");
}
/**
* Format attributes
*/
function formatAttributes(attributes, opts) {
	var _a$1;
	if (!attributes) return;
	const encode$1 = ((_a$1 = opts.encodeEntities) !== null && _a$1 !== void 0 ? _a$1 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
	return Object.keys(attributes).map((key) => {
		var _a$2, _b;
		const value = (_a$2 = attributes[key]) !== null && _a$2 !== void 0 ? _a$2 : "";
		if (opts.xmlMode === "foreign") key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
		if (!opts.emptyAttrs && !opts.xmlMode && value === "") return key;
		return `${key}="${encode$1(value)}"`;
	}).join(" ");
}
/**
* Self-enclosing tags
*/
const singleTag = new Set([
	"area",
	"base",
	"basefont",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"img",
	"input",
	"isindex",
	"keygen",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr"
]);
function render(node, options = {}) {
	const nodes = "length" in node ? node : [node];
	let output = "";
	for (let i$1 = 0; i$1 < nodes.length; i$1++) output += renderNode(nodes[i$1], options);
	return output;
}
var esm_default = render;
function renderNode(node, options) {
	switch (node.type) {
		case Root$8: return render(node.children, options);
		case Doctype:
		case Directive: return renderDirective(node);
		case Comment$7: return renderComment(node);
		case CDATA$1: return renderCdata(node);
		case Script:
		case Style:
		case Tag: return renderTag(node, options);
		case Text$1: return renderText(node, options);
	}
}
const foreignModeIntegrationPoints = new Set([
	"mi",
	"mo",
	"mn",
	"ms",
	"mtext",
	"annotation-xml",
	"foreignObject",
	"desc",
	"title"
]);
const foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
	var _a$1;
	if (opts.xmlMode === "foreign") {
		elem.name = (_a$1 = elementNames.get(elem.name)) !== null && _a$1 !== void 0 ? _a$1 : elem.name;
		if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) opts = {
			...opts,
			xmlMode: false
		};
	}
	if (!opts.xmlMode && foreignElements.has(elem.name)) opts = {
		...opts,
		xmlMode: "foreign"
	};
	let tag = `<${elem.name}`;
	const attribs = formatAttributes(elem.attribs, opts);
	if (attribs) tag += ` ${attribs}`;
	if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
		if (!opts.xmlMode) tag += " ";
		tag += "/>";
	} else {
		tag += ">";
		if (elem.children.length > 0) tag += render(elem.children, opts);
		if (opts.xmlMode || !singleTag.has(elem.name)) tag += `</${elem.name}>`;
	}
	return tag;
}
function renderDirective(elem) {
	return `<${elem.data}>`;
}
function renderText(elem, opts) {
	var _a$1;
	let data$1 = elem.data || "";
	if (((_a$1 = opts.encodeEntities) !== null && _a$1 !== void 0 ? _a$1 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) data$1 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data$1) : escapeText(data$1);
	return data$1;
}
function renderCdata(elem) {
	return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
	return `<!--${elem.data}-->`;
}
var DocumentPosition;
(function(DocumentPosition$1) {
	DocumentPosition$1[DocumentPosition$1["DISCONNECTED"] = 1] = "DISCONNECTED";
	DocumentPosition$1[DocumentPosition$1["PRECEDING"] = 2] = "PRECEDING";
	DocumentPosition$1[DocumentPosition$1["FOLLOWING"] = 4] = "FOLLOWING";
	DocumentPosition$1[DocumentPosition$1["CONTAINS"] = 8] = "CONTAINS";
	DocumentPosition$1[DocumentPosition$1["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function parseDocument(data$1, options) {
	const handler = new DomHandler(undefined, options);
	new Parser$3(handler, options).end(data$1);
	return handler.root;
}
var require_tokenize = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/tokenize.js"(exports$1, module) {
	const SINGLE_QUOTE = "'".charCodeAt(0);
	const DOUBLE_QUOTE = "\"".charCodeAt(0);
	const BACKSLASH = "\\".charCodeAt(0);
	const SLASH = "/".charCodeAt(0);
	const NEWLINE = "\n".charCodeAt(0);
	const SPACE = " ".charCodeAt(0);
	const FEED = "\f".charCodeAt(0);
	const TAB = "	".charCodeAt(0);
	const CR = "\r".charCodeAt(0);
	const OPEN_SQUARE = "[".charCodeAt(0);
	const CLOSE_SQUARE = "]".charCodeAt(0);
	const OPEN_PARENTHESES = "(".charCodeAt(0);
	const CLOSE_PARENTHESES = ")".charCodeAt(0);
	const OPEN_CURLY = "{".charCodeAt(0);
	const CLOSE_CURLY = "}".charCodeAt(0);
	const SEMICOLON = ";".charCodeAt(0);
	const ASTERISK = "*".charCodeAt(0);
	const COLON = ":".charCodeAt(0);
	const AT = "@".charCodeAt(0);
	const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
	const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
	const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
	const RE_HEX_ESCAPE = /[\da-f]/i;
	module.exports = function tokenizer$3(input, options = {}) {
		let css = input.css.valueOf();
		let ignore = options.ignoreErrors;
		let code, content, escape$1, next, quote$1;
		let currentToken, escaped, escapePos, n$1, prev;
		let length = css.length;
		let pos = 0;
		let buffer = [];
		let returned = [];
		function position() {
			return pos;
		}
		function unclosed(what) {
			throw input.error("Unclosed " + what, pos);
		}
		function endOfFile() {
			return returned.length === 0 && pos >= length;
		}
		function nextToken(opts) {
			if (returned.length) return returned.pop();
			if (pos >= length) return;
			let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
			code = css.charCodeAt(pos);
			switch (code) {
				case NEWLINE:
				case SPACE:
				case TAB:
				case CR:
				case FEED: {
					next = pos;
					do {
						next += 1;
						code = css.charCodeAt(next);
					} while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
					currentToken = ["space", css.slice(pos, next)];
					pos = next - 1;
					break;
				}
				case OPEN_SQUARE:
				case CLOSE_SQUARE:
				case OPEN_CURLY:
				case CLOSE_CURLY:
				case COLON:
				case SEMICOLON:
				case CLOSE_PARENTHESES: {
					let controlChar = String.fromCharCode(code);
					currentToken = [
						controlChar,
						controlChar,
						pos
					];
					break;
				}
				case OPEN_PARENTHESES: {
					prev = buffer.length ? buffer.pop()[1] : "";
					n$1 = css.charCodeAt(pos + 1);
					if (prev === "url" && n$1 !== SINGLE_QUOTE && n$1 !== DOUBLE_QUOTE && n$1 !== SPACE && n$1 !== NEWLINE && n$1 !== TAB && n$1 !== FEED && n$1 !== CR) {
						next = pos;
						do {
							escaped = false;
							next = css.indexOf(")", next + 1);
							if (next === -1) if (ignore || ignoreUnclosed) {
								next = pos;
								break;
							} else unclosed("bracket");
							escapePos = next;
							while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
								escapePos -= 1;
								escaped = !escaped;
							}
						} while (escaped);
						currentToken = [
							"brackets",
							css.slice(pos, next + 1),
							pos,
							next
						];
						pos = next;
					} else {
						next = css.indexOf(")", pos + 1);
						content = css.slice(pos, next + 1);
						if (next === -1 || RE_BAD_BRACKET.test(content)) currentToken = [
							"(",
							"(",
							pos
						];
else {
							currentToken = [
								"brackets",
								content,
								pos,
								next
							];
							pos = next;
						}
					}
					break;
				}
				case SINGLE_QUOTE:
				case DOUBLE_QUOTE: {
					quote$1 = code === SINGLE_QUOTE ? "'" : "\"";
					next = pos;
					do {
						escaped = false;
						next = css.indexOf(quote$1, next + 1);
						if (next === -1) if (ignore || ignoreUnclosed) {
							next = pos + 1;
							break;
						} else unclosed("string");
						escapePos = next;
						while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
							escapePos -= 1;
							escaped = !escaped;
						}
					} while (escaped);
					currentToken = [
						"string",
						css.slice(pos, next + 1),
						pos,
						next
					];
					pos = next;
					break;
				}
				case AT: {
					RE_AT_END.lastIndex = pos + 1;
					RE_AT_END.test(css);
					if (RE_AT_END.lastIndex === 0) next = css.length - 1;
else next = RE_AT_END.lastIndex - 2;
					currentToken = [
						"at-word",
						css.slice(pos, next + 1),
						pos,
						next
					];
					pos = next;
					break;
				}
				case BACKSLASH: {
					next = pos;
					escape$1 = true;
					while (css.charCodeAt(next + 1) === BACKSLASH) {
						next += 1;
						escape$1 = !escape$1;
					}
					code = css.charCodeAt(next + 1);
					if (escape$1 && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
						next += 1;
						if (RE_HEX_ESCAPE.test(css.charAt(next))) {
							while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) next += 1;
							if (css.charCodeAt(next + 1) === SPACE) next += 1;
						}
					}
					currentToken = [
						"word",
						css.slice(pos, next + 1),
						pos,
						next
					];
					pos = next;
					break;
				}
				default: {
					if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
						next = css.indexOf("*/", pos + 2) + 1;
						if (next === 0) if (ignore || ignoreUnclosed) next = css.length;
else unclosed("comment");
						currentToken = [
							"comment",
							css.slice(pos, next + 1),
							pos,
							next
						];
						pos = next;
					} else {
						RE_WORD_END.lastIndex = pos + 1;
						RE_WORD_END.test(css);
						if (RE_WORD_END.lastIndex === 0) next = css.length - 1;
else next = RE_WORD_END.lastIndex - 2;
						currentToken = [
							"word",
							css.slice(pos, next + 1),
							pos,
							next
						];
						buffer.push(currentToken);
						pos = next;
					}
					break;
				}
			}
			pos++;
			return currentToken;
		}
		function back(token) {
			returned.push(token);
		}
		return {
			back,
			endOfFile,
			nextToken,
			position
		};
	};
} });
var require_terminal_highlight = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/terminal-highlight.js"(exports$1, module) {
	let pico$1 = require_picocolors();
	let tokenizer$2 = require_tokenize();
	let Input$6;
	function registerInput(dependant) {
		Input$6 = dependant;
	}
	const HIGHLIGHT_THEME = {
		";": pico$1.yellow,
		":": pico$1.yellow,
		"(": pico$1.cyan,
		")": pico$1.cyan,
		"[": pico$1.yellow,
		"]": pico$1.yellow,
		"{": pico$1.yellow,
		"}": pico$1.yellow,
		"at-word": pico$1.cyan,
		"brackets": pico$1.cyan,
		"call": pico$1.cyan,
		"class": pico$1.yellow,
		"comment": pico$1.gray,
		"hash": pico$1.magenta,
		"string": pico$1.green
	};
	function getTokenType([type, value], processor) {
		if (type === "word") {
			if (value[0] === ".") return "class";
			if (value[0] === "#") return "hash";
		}
		if (!processor.endOfFile()) {
			let next = processor.nextToken();
			processor.back(next);
			if (next[0] === "brackets" || next[0] === "(") return "call";
		}
		return type;
	}
	function terminalHighlight$2(css) {
		let processor = tokenizer$2(new Input$6(css), { ignoreErrors: true });
		let result = "";
		while (!processor.endOfFile()) {
			let token = processor.nextToken();
			let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
			if (color) result += token[1].split(/\r?\n/).map((i$1) => color(i$1)).join("\n");
else result += token[1];
		}
		return result;
	}
	terminalHighlight$2.registerInput = registerInput;
	module.exports = terminalHighlight$2;
} });
var require_css_syntax_error = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/css-syntax-error.js"(exports$1, module) {
	let pico = require_picocolors();
	let terminalHighlight$1 = require_terminal_highlight();
	var CssSyntaxError$4 = class CssSyntaxError$4$1 extends Error {
		constructor(message, line, column, source, file, plugin$1) {
			super(message);
			this.name = "CssSyntaxError";
			this.reason = message;
			if (file) this.file = file;
			if (source) this.source = source;
			if (plugin$1) this.plugin = plugin$1;
			if (typeof line !== "undefined" && typeof column !== "undefined") if (typeof line === "number") {
				this.line = line;
				this.column = column;
			} else {
				this.line = line.line;
				this.column = line.column;
				this.endLine = column.line;
				this.endColumn = column.column;
			}
			this.setMessage();
			if (Error.captureStackTrace) Error.captureStackTrace(this, CssSyntaxError$4$1);
		}
		setMessage() {
			this.message = this.plugin ? this.plugin + ": " : "";
			this.message += this.file ? this.file : "<css input>";
			if (typeof this.line !== "undefined") this.message += ":" + this.line + ":" + this.column;
			this.message += ": " + this.reason;
		}
		showSourceCode(color) {
			if (!this.source) return "";
			let css = this.source;
			if (color == null) color = pico.isColorSupported;
			let aside = (text$1) => text$1;
			let mark = (text$1) => text$1;
			let highlight = (text$1) => text$1;
			if (color) {
				let { bold, gray, red } = pico.createColors(true);
				mark = (text$1) => bold(red(text$1));
				aside = (text$1) => gray(text$1);
				if (terminalHighlight$1) highlight = (text$1) => terminalHighlight$1(text$1);
			}
			let lines = css.split(/\r?\n/);
			let start = Math.max(this.line - 3, 0);
			let end = Math.min(this.line + 2, lines.length);
			let maxWidth = String(end).length;
			return lines.slice(start, end).map((line, index) => {
				let number = start + 1 + index;
				let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
				if (number === this.line) {
					if (line.length > 160) {
						let padding = 20;
						let subLineStart = Math.max(0, this.column - padding);
						let subLineEnd = Math.max(this.column + padding, this.endColumn + padding);
						let subLine = line.slice(subLineStart, subLineEnd);
						let spacing$1 = aside(gutter.replace(/\d/g, " ")) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
						return mark(">") + aside(gutter) + highlight(subLine) + "\n " + spacing$1 + mark("^");
					}
					let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
					return mark(">") + aside(gutter) + highlight(line) + "\n " + spacing + mark("^");
				}
				return " " + aside(gutter) + highlight(line);
			}).join("\n");
		}
		toString() {
			let code = this.showSourceCode();
			if (code) code = "\n\n" + code + "\n";
			return this.name + ": " + this.message + code;
		}
	};
	module.exports = CssSyntaxError$4;
	CssSyntaxError$4.default = CssSyntaxError$4;
} });
var require_stringifier = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/stringifier.js"(exports$1, module) {
	const DEFAULT_RAW = {
		after: "\n",
		beforeClose: "\n",
		beforeComment: "\n",
		beforeDecl: "\n",
		beforeOpen: " ",
		beforeRule: "\n",
		colon: ": ",
		commentLeft: " ",
		commentRight: " ",
		emptyBody: "",
		indent: "    ",
		semicolon: false
	};
	function capitalize(str) {
		return str[0].toUpperCase() + str.slice(1);
	}
	var Stringifier$2 = class {
		constructor(builder) {
			this.builder = builder;
		}
		atrule(node, semicolon$1) {
			let name = "@" + node.name;
			let params = node.params ? this.rawValue(node, "params") : "";
			if (typeof node.raws.afterName !== "undefined") name += node.raws.afterName;
else if (params) name += " ";
			if (node.nodes) this.block(node, name + params);
else {
				let end = (node.raws.between || "") + (semicolon$1 ? ";" : "");
				this.builder(name + params + end, node);
			}
		}
		beforeAfter(node, detect$1) {
			let value;
			if (node.type === "decl") value = this.raw(node, null, "beforeDecl");
else if (node.type === "comment") value = this.raw(node, null, "beforeComment");
else if (detect$1 === "before") value = this.raw(node, null, "beforeRule");
else value = this.raw(node, null, "beforeClose");
			let buf = node.parent;
			let depth = 0;
			while (buf && buf.type !== "root") {
				depth += 1;
				buf = buf.parent;
			}
			if (value.includes("\n")) {
				let indent$1$1 = this.raw(node, null, "indent");
				if (indent$1$1.length) for (let step = 0; step < depth; step++) value += indent$1$1;
			}
			return value;
		}
		block(node, start) {
			let between = this.raw(node, "between", "beforeOpen");
			this.builder(start + between + "{", node, "start");
			let after;
			if (node.nodes && node.nodes.length) {
				this.body(node);
				after = this.raw(node, "after");
			} else after = this.raw(node, "after", "emptyBody");
			if (after) this.builder(after);
			this.builder("}", node, "end");
		}
		body(node) {
			let last = node.nodes.length - 1;
			while (last > 0) {
				if (node.nodes[last].type !== "comment") break;
				last -= 1;
			}
			let semicolon$1 = this.raw(node, "semicolon");
			for (let i$1 = 0; i$1 < node.nodes.length; i$1++) {
				let child = node.nodes[i$1];
				let before = this.raw(child, "before");
				if (before) this.builder(before);
				this.stringify(child, last !== i$1 || semicolon$1);
			}
		}
		comment(node) {
			let left = this.raw(node, "left", "commentLeft");
			let right = this.raw(node, "right", "commentRight");
			this.builder("/*" + left + node.text + right + "*/", node);
		}
		decl(node, semicolon$1) {
			let between = this.raw(node, "between", "colon");
			let string = node.prop + between + this.rawValue(node, "value");
			if (node.important) string += node.raws.important || " !important";
			if (semicolon$1) string += ";";
			this.builder(string, node);
		}
		document(node) {
			this.body(node);
		}
		raw(node, own, detect$1) {
			let value;
			if (!detect$1) detect$1 = own;
			if (own) {
				value = node.raws[own];
				if (typeof value !== "undefined") return value;
			}
			let parent = node.parent;
			if (detect$1 === "before") {
				if (!parent || parent.type === "root" && parent.first === node) return "";
				if (parent && parent.type === "document") return "";
			}
			if (!parent) return DEFAULT_RAW[detect$1];
			let root$1 = node.root();
			if (!root$1.rawCache) root$1.rawCache = {};
			if (typeof root$1.rawCache[detect$1] !== "undefined") return root$1.rawCache[detect$1];
			if (detect$1 === "before" || detect$1 === "after") return this.beforeAfter(node, detect$1);
else {
				let method = "raw" + capitalize(detect$1);
				if (this[method]) value = this[method](root$1, node);
else root$1.walk((i$1) => {
					value = i$1.raws[own];
					if (typeof value !== "undefined") return false;
				});
			}
			if (typeof value === "undefined") value = DEFAULT_RAW[detect$1];
			root$1.rawCache[detect$1] = value;
			return value;
		}
		rawBeforeClose(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && i$1.nodes.length > 0) {
					if (typeof i$1.raws.after !== "undefined") {
						value = i$1.raws.after;
						if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
						return false;
					}
				}
			});
			if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawBeforeComment(root$1, node) {
			let value;
			root$1.walkComments((i$1) => {
				if (typeof i$1.raws.before !== "undefined") {
					value = i$1.raws.before;
					if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
					return false;
				}
			});
			if (typeof value === "undefined") value = this.raw(node, null, "beforeDecl");
else if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawBeforeDecl(root$1, node) {
			let value;
			root$1.walkDecls((i$1) => {
				if (typeof i$1.raws.before !== "undefined") {
					value = i$1.raws.before;
					if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
					return false;
				}
			});
			if (typeof value === "undefined") value = this.raw(node, null, "beforeRule");
else if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawBeforeOpen(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.type !== "decl") {
					value = i$1.raws.between;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawBeforeRule(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && (i$1.parent !== root$1 || root$1.first !== i$1)) {
					if (typeof i$1.raws.before !== "undefined") {
						value = i$1.raws.before;
						if (value.includes("\n")) value = value.replace(/[^\n]+$/, "");
						return false;
					}
				}
			});
			if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawColon(root$1) {
			let value;
			root$1.walkDecls((i$1) => {
				if (typeof i$1.raws.between !== "undefined") {
					value = i$1.raws.between.replace(/[^\s:]/g, "");
					return false;
				}
			});
			return value;
		}
		rawEmptyBody(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && i$1.nodes.length === 0) {
					value = i$1.raws.after;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawIndent(root$1) {
			if (root$1.raws.indent) return root$1.raws.indent;
			let value;
			root$1.walk((i$1) => {
				let p$1 = i$1.parent;
				if (p$1 && p$1 !== root$1 && p$1.parent && p$1.parent === root$1) {
					if (typeof i$1.raws.before !== "undefined") {
						let parts = i$1.raws.before.split("\n");
						value = parts[parts.length - 1];
						value = value.replace(/\S/g, "");
						return false;
					}
				}
			});
			return value;
		}
		rawSemicolon(root$1) {
			let value;
			root$1.walk((i$1) => {
				if (i$1.nodes && i$1.nodes.length && i$1.last.type === "decl") {
					value = i$1.raws.semicolon;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawValue(node, prop) {
			let value = node[prop];
			let raw = node.raws[prop];
			if (raw && raw.value === value) return raw.raw;
			return value;
		}
		root(node) {
			this.body(node);
			if (node.raws.after) this.builder(node.raws.after);
		}
		rule(node) {
			this.block(node, this.rawValue(node, "selector"));
			if (node.raws.ownSemicolon) this.builder(node.raws.ownSemicolon, node, "end");
		}
		stringify(node, semicolon$1) {
			if (!this[node.type]) throw new Error("Unknown AST node type " + node.type + ". " + "Maybe you need to change PostCSS stringifier.");
			this[node.type](node, semicolon$1);
		}
	};
	module.exports = Stringifier$2;
	Stringifier$2.default = Stringifier$2;
} });
var require_stringify = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/stringify.js"(exports$1, module) {
	let Stringifier$1 = require_stringifier();
	function stringify$5(node, builder) {
		let str = new Stringifier$1(builder);
		str.stringify(node);
	}
	module.exports = stringify$5;
	stringify$5.default = stringify$5;
} });
var require_symbols = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/symbols.js"(exports$1, module) {
	module.exports.isClean = Symbol("isClean");
	module.exports.my = Symbol("my");
} });
var require_node = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/node.js"(exports$1, module) {
	let CssSyntaxError$3 = require_css_syntax_error();
	let Stringifier = require_stringifier();
	let stringify$4 = require_stringify();
	let { isClean: isClean$2, my: my$2 } = require_symbols();
	function cloneNode(obj, parent) {
		let cloned = new obj.constructor();
		for (let i$1 in obj) {
			if (!Object.prototype.hasOwnProperty.call(obj, i$1)) continue;
			if (i$1 === "proxyCache") continue;
			let value = obj[i$1];
			let type = typeof value;
			if (i$1 === "parent" && type === "object") {
				if (parent) cloned[i$1] = parent;
			} else if (i$1 === "source") cloned[i$1] = value;
else if (Array.isArray(value)) cloned[i$1] = value.map((j) => cloneNode(j, cloned));
else {
				if (type === "object" && value !== null) value = cloneNode(value);
				cloned[i$1] = value;
			}
		}
		return cloned;
	}
	function sourceOffset(inputCSS, position) {
		if (position && typeof position.offset !== "undefined") return position.offset;
		let column = 1;
		let line = 1;
		let offset = 0;
		for (let i$1 = 0; i$1 < inputCSS.length; i$1++) {
			if (line === position.line && column === position.column) {
				offset = i$1;
				break;
			}
			if (inputCSS[i$1] === "\n") {
				column = 1;
				line += 1;
			} else column += 1;
		}
		return offset;
	}
	var Node$6 = class {
		get proxyOf() {
			return this;
		}
		constructor(defaults = {}) {
			this.raws = {};
			this[isClean$2] = false;
			this[my$2] = true;
			for (let name in defaults) if (name === "nodes") {
				this.nodes = [];
				for (let node of defaults[name]) if (typeof node.clone === "function") this.append(node.clone());
else this.append(node);
			} else this[name] = defaults[name];
		}
		addToError(error) {
			error.postcssNode = this;
			if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
				let s$1 = this.source;
				error.stack = error.stack.replace(/\n\s{4}at /, `$&${s$1.input.from}:${s$1.start.line}:${s$1.start.column}$&`);
			}
			return error;
		}
		after(add) {
			this.parent.insertAfter(this, add);
			return this;
		}
		assign(overrides = {}) {
			for (let name in overrides) this[name] = overrides[name];
			return this;
		}
		before(add) {
			this.parent.insertBefore(this, add);
			return this;
		}
		cleanRaws(keepBetween) {
			delete this.raws.before;
			delete this.raws.after;
			if (!keepBetween) delete this.raws.between;
		}
		clone(overrides = {}) {
			let cloned = cloneNode(this);
			for (let name in overrides) cloned[name] = overrides[name];
			return cloned;
		}
		cloneAfter(overrides = {}) {
			let cloned = this.clone(overrides);
			this.parent.insertAfter(this, cloned);
			return cloned;
		}
		cloneBefore(overrides = {}) {
			let cloned = this.clone(overrides);
			this.parent.insertBefore(this, cloned);
			return cloned;
		}
		error(message, opts = {}) {
			if (this.source) {
				let { end, start } = this.rangeBy(opts);
				return this.source.input.error(message, {
					column: start.column,
					line: start.line
				}, {
					column: end.column,
					line: end.line
				}, opts);
			}
			return new CssSyntaxError$3(message);
		}
		getProxyProcessor() {
			return {
				get(node, prop) {
					if (prop === "proxyOf") return node;
else if (prop === "root") return () => node.root().toProxy();
else return node[prop];
				},
				set(node, prop, value) {
					if (node[prop] === value) return true;
					node[prop] = value;
					if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") node.markDirty();
					return true;
				}
			};
		}
		markClean() {
			this[isClean$2] = true;
		}
		markDirty() {
			if (this[isClean$2]) {
				this[isClean$2] = false;
				let next = this;
				while (next = next.parent) next[isClean$2] = false;
			}
		}
		next() {
			if (!this.parent) return undefined;
			let index = this.parent.index(this);
			return this.parent.nodes[index + 1];
		}
		positionBy(opts) {
			let pos = this.source.start;
			if (opts.index) pos = this.positionInside(opts.index);
else if (opts.word) {
				let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
				let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));
				let index = stringRepresentation.indexOf(opts.word);
				if (index !== -1) pos = this.positionInside(index);
			}
			return pos;
		}
		positionInside(index) {
			let column = this.source.start.column;
			let line = this.source.start.line;
			let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
			let offset = sourceOffset(inputString, this.source.start);
			let end = offset + index;
			for (let i$1 = offset; i$1 < end; i$1++) if (inputString[i$1] === "\n") {
				column = 1;
				line += 1;
			} else column += 1;
			return {
				column,
				line
			};
		}
		prev() {
			if (!this.parent) return undefined;
			let index = this.parent.index(this);
			return this.parent.nodes[index - 1];
		}
		rangeBy(opts) {
			let start = {
				column: this.source.start.column,
				line: this.source.start.line
			};
			let end = this.source.end ? {
				column: this.source.end.column + 1,
				line: this.source.end.line
			} : {
				column: start.column + 1,
				line: start.line
			};
			if (opts.word) {
				let inputString = "document" in this.source.input ? this.source.input.document : this.source.input.css;
				let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));
				let index = stringRepresentation.indexOf(opts.word);
				if (index !== -1) {
					start = this.positionInside(index);
					end = this.positionInside(index + opts.word.length);
				}
			} else {
				if (opts.start) start = {
					column: opts.start.column,
					line: opts.start.line
				};
else if (opts.index) start = this.positionInside(opts.index);
				if (opts.end) end = {
					column: opts.end.column,
					line: opts.end.line
				};
else if (typeof opts.endIndex === "number") end = this.positionInside(opts.endIndex);
else if (opts.index) end = this.positionInside(opts.index + 1);
			}
			if (end.line < start.line || end.line === start.line && end.column <= start.column) end = {
				column: start.column + 1,
				line: start.line
			};
			return {
				end,
				start
			};
		}
		raw(prop, defaultType) {
			let str = new Stringifier();
			return str.raw(this, prop, defaultType);
		}
		remove() {
			if (this.parent) this.parent.removeChild(this);
			this.parent = undefined;
			return this;
		}
		replaceWith(...nodes) {
			if (this.parent) {
				let bookmark = this;
				let foundSelf = false;
				for (let node of nodes) if (node === this) foundSelf = true;
else if (foundSelf) {
					this.parent.insertAfter(bookmark, node);
					bookmark = node;
				} else this.parent.insertBefore(bookmark, node);
				if (!foundSelf) this.remove();
			}
			return this;
		}
		root() {
			let result = this;
			while (result.parent && result.parent.type !== "document") result = result.parent;
			return result;
		}
		toJSON(_, inputs) {
			let fixed = {};
			let emitInputs = inputs == null;
			inputs = inputs || new Map();
			let inputsNextIndex = 0;
			for (let name in this) {
				if (!Object.prototype.hasOwnProperty.call(this, name)) continue;
				if (name === "parent" || name === "proxyCache") continue;
				let value = this[name];
				if (Array.isArray(value)) fixed[name] = value.map((i$1) => {
					if (typeof i$1 === "object" && i$1.toJSON) return i$1.toJSON(null, inputs);
else return i$1;
				});
else if (typeof value === "object" && value.toJSON) fixed[name] = value.toJSON(null, inputs);
else if (name === "source") {
					let inputId = inputs.get(value.input);
					if (inputId == null) {
						inputId = inputsNextIndex;
						inputs.set(value.input, inputsNextIndex);
						inputsNextIndex++;
					}
					fixed[name] = {
						end: value.end,
						inputId,
						start: value.start
					};
				} else fixed[name] = value;
			}
			if (emitInputs) fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
			return fixed;
		}
		toProxy() {
			if (!this.proxyCache) this.proxyCache = new Proxy(this, this.getProxyProcessor());
			return this.proxyCache;
		}
		toString(stringifier = stringify$4) {
			if (stringifier.stringify) stringifier = stringifier.stringify;
			let result = "";
			stringifier(this, (i$1) => {
				result += i$1;
			});
			return result;
		}
		warn(result, text$1, opts) {
			let data$1 = { node: this };
			for (let i$1 in opts) data$1[i$1] = opts[i$1];
			return result.warn(text$1, data$1);
		}
	};
	module.exports = Node$6;
	Node$6.default = Node$6;
} });
var require_comment = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/comment.js"(exports$1, module) {
	let Node$5 = require_node();
	var Comment$5 = class extends Node$5 {
		constructor(defaults) {
			super(defaults);
			this.type = "comment";
		}
	};
	module.exports = Comment$5;
	Comment$5.default = Comment$5;
} });
var require_declaration = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/declaration.js"(exports$1, module) {
	let Node$4 = require_node();
	var Declaration$5 = class extends Node$4 {
		get variable() {
			return this.prop.startsWith("--") || this.prop[0] === "$";
		}
		constructor(defaults) {
			if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") defaults = {
				...defaults,
				value: String(defaults.value)
			};
			super(defaults);
			this.type = "decl";
		}
	};
	module.exports = Declaration$5;
	Declaration$5.default = Declaration$5;
} });
var require_container = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/container.js"(exports$1, module) {
	let Comment$4 = require_comment();
	let Declaration$4 = require_declaration();
	let Node$3 = require_node();
	let { isClean: isClean$1, my: my$1 } = require_symbols();
	let AtRule$5, parse$6, Root$7, Rule$5;
	function cleanSource(nodes) {
		return nodes.map((i$1) => {
			if (i$1.nodes) i$1.nodes = cleanSource(i$1.nodes);
			delete i$1.source;
			return i$1;
		});
	}
	function markTreeDirty(node) {
		node[isClean$1] = false;
		if (node.proxyOf.nodes) for (let i$1 of node.proxyOf.nodes) markTreeDirty(i$1);
	}
	var Container$8 = class Container$8$1 extends Node$3 {
		get first() {
			if (!this.proxyOf.nodes) return undefined;
			return this.proxyOf.nodes[0];
		}
		get last() {
			if (!this.proxyOf.nodes) return undefined;
			return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
		}
		append(...children) {
			for (let child of children) {
				let nodes = this.normalize(child, this.last);
				for (let node of nodes) this.proxyOf.nodes.push(node);
			}
			this.markDirty();
			return this;
		}
		cleanRaws(keepBetween) {
			super.cleanRaws(keepBetween);
			if (this.nodes) for (let node of this.nodes) node.cleanRaws(keepBetween);
		}
		each(callback) {
			if (!this.proxyOf.nodes) return undefined;
			let iterator = this.getIterator();
			let index, result;
			while (this.indexes[iterator] < this.proxyOf.nodes.length) {
				index = this.indexes[iterator];
				result = callback(this.proxyOf.nodes[index], index);
				if (result === false) break;
				this.indexes[iterator] += 1;
			}
			delete this.indexes[iterator];
			return result;
		}
		every(condition) {
			return this.nodes.every(condition);
		}
		getIterator() {
			if (!this.lastEach) this.lastEach = 0;
			if (!this.indexes) this.indexes = {};
			this.lastEach += 1;
			let iterator = this.lastEach;
			this.indexes[iterator] = 0;
			return iterator;
		}
		getProxyProcessor() {
			return {
				get(node, prop) {
					if (prop === "proxyOf") return node;
else if (!node[prop]) return node[prop];
else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) return (...args) => {
						return node[prop](...args.map((i$1) => {
							if (typeof i$1 === "function") return (child, index) => i$1(child.toProxy(), index);
else return i$1;
						}));
					};
else if (prop === "every" || prop === "some") return (cb) => {
						return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
					};
else if (prop === "root") return () => node.root().toProxy();
else if (prop === "nodes") return node.nodes.map((i$1) => i$1.toProxy());
else if (prop === "first" || prop === "last") return node[prop].toProxy();
else return node[prop];
				},
				set(node, prop, value) {
					if (node[prop] === value) return true;
					node[prop] = value;
					if (prop === "name" || prop === "params" || prop === "selector") node.markDirty();
					return true;
				}
			};
		}
		index(child) {
			if (typeof child === "number") return child;
			if (child.proxyOf) child = child.proxyOf;
			return this.proxyOf.nodes.indexOf(child);
		}
		insertAfter(exist, add) {
			let existIndex = this.index(exist);
			let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
			existIndex = this.index(exist);
			for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (existIndex < index) this.indexes[id] = index + nodes.length;
			}
			this.markDirty();
			return this;
		}
		insertBefore(exist, add) {
			let existIndex = this.index(exist);
			let type = existIndex === 0 ? "prepend" : false;
			let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
			existIndex = this.index(exist);
			for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (existIndex <= index) this.indexes[id] = index + nodes.length;
			}
			this.markDirty();
			return this;
		}
		normalize(nodes, sample) {
			if (typeof nodes === "string") nodes = cleanSource(parse$6(nodes).nodes);
else if (typeof nodes === "undefined") nodes = [];
else if (Array.isArray(nodes)) {
				nodes = nodes.slice(0);
				for (let i$1 of nodes) if (i$1.parent) i$1.parent.removeChild(i$1, "ignore");
			} else if (nodes.type === "root" && this.type !== "document") {
				nodes = nodes.nodes.slice(0);
				for (let i$1 of nodes) if (i$1.parent) i$1.parent.removeChild(i$1, "ignore");
			} else if (nodes.type) nodes = [nodes];
else if (nodes.prop) {
				if (typeof nodes.value === "undefined") throw new Error("Value field is missed in node creation");
else if (typeof nodes.value !== "string") nodes.value = String(nodes.value);
				nodes = [new Declaration$4(nodes)];
			} else if (nodes.selector || nodes.selectors) nodes = [new Rule$5(nodes)];
else if (nodes.name) nodes = [new AtRule$5(nodes)];
else if (nodes.text) nodes = [new Comment$4(nodes)];
else throw new Error("Unknown node type in node creation");
			let processed = nodes.map((i$1) => {
				if (!i$1[my$1]) Container$8$1.rebuild(i$1);
				i$1 = i$1.proxyOf;
				if (i$1.parent) i$1.parent.removeChild(i$1);
				if (i$1[isClean$1]) markTreeDirty(i$1);
				if (!i$1.raws) i$1.raws = {};
				if (typeof i$1.raws.before === "undefined") {
					if (sample && typeof sample.raws.before !== "undefined") i$1.raws.before = sample.raws.before.replace(/\S/g, "");
				}
				i$1.parent = this.proxyOf;
				return i$1;
			});
			return processed;
		}
		prepend(...children) {
			children = children.reverse();
			for (let child of children) {
				let nodes = this.normalize(child, this.first, "prepend").reverse();
				for (let node of nodes) this.proxyOf.nodes.unshift(node);
				for (let id in this.indexes) this.indexes[id] = this.indexes[id] + nodes.length;
			}
			this.markDirty();
			return this;
		}
		push(child) {
			child.parent = this;
			this.proxyOf.nodes.push(child);
			return this;
		}
		removeAll() {
			for (let node of this.proxyOf.nodes) node.parent = undefined;
			this.proxyOf.nodes = [];
			this.markDirty();
			return this;
		}
		removeChild(child) {
			child = this.index(child);
			this.proxyOf.nodes[child].parent = undefined;
			this.proxyOf.nodes.splice(child, 1);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (index >= child) this.indexes[id] = index - 1;
			}
			this.markDirty();
			return this;
		}
		replaceValues(pattern, opts, callback) {
			if (!callback) {
				callback = opts;
				opts = {};
			}
			this.walkDecls((decl$1) => {
				if (opts.props && !opts.props.includes(decl$1.prop)) return;
				if (opts.fast && !decl$1.value.includes(opts.fast)) return;
				decl$1.value = decl$1.value.replace(pattern, callback);
			});
			this.markDirty();
			return this;
		}
		some(condition) {
			return this.nodes.some(condition);
		}
		walk(callback) {
			return this.each((child, i$1) => {
				let result;
				try {
					result = callback(child, i$1);
				} catch (e) {
					throw child.addToError(e);
				}
				if (result !== false && child.walk) result = child.walk(callback);
				return result;
			});
		}
		walkAtRules(name, callback) {
			if (!callback) {
				callback = name;
				return this.walk((child, i$1) => {
					if (child.type === "atrule") return callback(child, i$1);
				});
			}
			if (name instanceof RegExp) return this.walk((child, i$1) => {
				if (child.type === "atrule" && name.test(child.name)) return callback(child, i$1);
			});
			return this.walk((child, i$1) => {
				if (child.type === "atrule" && child.name === name) return callback(child, i$1);
			});
		}
		walkComments(callback) {
			return this.walk((child, i$1) => {
				if (child.type === "comment") return callback(child, i$1);
			});
		}
		walkDecls(prop, callback) {
			if (!callback) {
				callback = prop;
				return this.walk((child, i$1) => {
					if (child.type === "decl") return callback(child, i$1);
				});
			}
			if (prop instanceof RegExp) return this.walk((child, i$1) => {
				if (child.type === "decl" && prop.test(child.prop)) return callback(child, i$1);
			});
			return this.walk((child, i$1) => {
				if (child.type === "decl" && child.prop === prop) return callback(child, i$1);
			});
		}
		walkRules(selector, callback) {
			if (!callback) {
				callback = selector;
				return this.walk((child, i$1) => {
					if (child.type === "rule") return callback(child, i$1);
				});
			}
			if (selector instanceof RegExp) return this.walk((child, i$1) => {
				if (child.type === "rule" && selector.test(child.selector)) return callback(child, i$1);
			});
			return this.walk((child, i$1) => {
				if (child.type === "rule" && child.selector === selector) return callback(child, i$1);
			});
		}
	};
	Container$8.registerParse = (dependant) => {
		parse$6 = dependant;
	};
	Container$8.registerRule = (dependant) => {
		Rule$5 = dependant;
	};
	Container$8.registerAtRule = (dependant) => {
		AtRule$5 = dependant;
	};
	Container$8.registerRoot = (dependant) => {
		Root$7 = dependant;
	};
	module.exports = Container$8;
	Container$8.default = Container$8;
	Container$8.rebuild = (node) => {
		if (node.type === "atrule") Object.setPrototypeOf(node, AtRule$5.prototype);
else if (node.type === "rule") Object.setPrototypeOf(node, Rule$5.prototype);
else if (node.type === "decl") Object.setPrototypeOf(node, Declaration$4.prototype);
else if (node.type === "comment") Object.setPrototypeOf(node, Comment$4.prototype);
else if (node.type === "root") Object.setPrototypeOf(node, Root$7.prototype);
		node[my$1] = true;
		if (node.nodes) node.nodes.forEach((child) => {
			Container$8.rebuild(child);
		});
	};
} });
var require_at_rule = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/at-rule.js"(exports$1, module) {
	let Container$7 = require_container();
	var AtRule$4 = class extends Container$7 {
		constructor(defaults) {
			super(defaults);
			this.type = "atrule";
		}
		append(...children) {
			if (!this.proxyOf.nodes) this.nodes = [];
			return super.append(...children);
		}
		prepend(...children) {
			if (!this.proxyOf.nodes) this.nodes = [];
			return super.prepend(...children);
		}
	};
	module.exports = AtRule$4;
	AtRule$4.default = AtRule$4;
	Container$7.registerAtRule(AtRule$4);
} });
var require_document = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/document.js"(exports$1, module) {
	let Container$6 = require_container();
	let LazyResult$4, Processor$4;
	var Document$4 = class extends Container$6 {
		constructor(defaults) {
			super({
				type: "document",
				...defaults
			});
			if (!this.nodes) this.nodes = [];
		}
		toResult(opts = {}) {
			let lazy = new LazyResult$4(new Processor$4(), this, opts);
			return lazy.stringify();
		}
	};
	Document$4.registerLazyResult = (dependant) => {
		LazyResult$4 = dependant;
	};
	Document$4.registerProcessor = (dependant) => {
		Processor$4 = dependant;
	};
	module.exports = Document$4;
	Document$4.default = Document$4;
} });
var require_non_secure = __commonJS({ "node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.cjs"(exports$1, module) {
	let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
	let customAlphabet = (alphabet, defaultSize = 21) => {
		return (size = defaultSize) => {
			let id = "";
			let i$1 = size | 0;
			while (i$1--) id += alphabet[Math.random() * alphabet.length | 0];
			return id;
		};
	};
	let nanoid$1 = (size = 21) => {
		let id = "";
		let i$1 = size | 0;
		while (i$1--) id += urlAlphabet[Math.random() * 64 | 0];
		return id;
	};
	module.exports = {
		nanoid: nanoid$1,
		customAlphabet
	};
} });
var require_base64 = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js"(exports$1) {
	var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
	/**
	* Encode an integer in the range of 0 to 63 to a single base 64 digit.
	*/
	exports$1.encode = function(number) {
		if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
		throw new TypeError("Must be between 0 and 63: " + number);
	};
	/**
	* Decode a single base 64 character code digit to an integer. Returns -1 on
	* failure.
	*/
	exports$1.decode = function(charCode) {
		var bigA = 65;
		var bigZ = 90;
		var littleA = 97;
		var littleZ = 122;
		var zero = 48;
		var nine = 57;
		var plus = 43;
		var slash = 47;
		var littleOffset = 26;
		var numberOffset = 52;
		if (bigA <= charCode && charCode <= bigZ) return charCode - bigA;
		if (littleA <= charCode && charCode <= littleZ) return charCode - littleA + littleOffset;
		if (zero <= charCode && charCode <= nine) return charCode - zero + numberOffset;
		if (charCode == plus) return 62;
		if (charCode == slash) return 63;
		return -1;
	};
} });
var require_base64_vlq = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js"(exports$1) {
	var base64 = require_base64();
	var VLQ_BASE_SHIFT = 5;
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	/**
	* Converts from a two-complement value to a value where the sign bit is
	* placed in the least significant bit.  For example, as decimals:
	*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	*/
	function toVLQSigned(aValue) {
		return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}
	/**
	* Converts to a two-complement value from a value where the sign bit is
	* placed in the least significant bit.  For example, as decimals:
	*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	*/
	function fromVLQSigned(aValue) {
		var isNegative = (aValue & 1) === 1;
		var shifted = aValue >> 1;
		return isNegative ? -shifted : shifted;
	}
	/**
	* Returns the base 64 VLQ encoded value.
	*/
	exports$1.encode = function base64VLQ_encode(aValue) {
		var encoded = "";
		var digit;
		var vlq = toVLQSigned(aValue);
		do {
			digit = vlq & VLQ_BASE_MASK;
			vlq >>>= VLQ_BASE_SHIFT;
			if (vlq > 0) digit |= VLQ_CONTINUATION_BIT;
			encoded += base64.encode(digit);
		} while (vlq > 0);
		return encoded;
	};
	/**
	* Decodes the next base 64 VLQ value from the given string and returns the
	* value and the rest of the string via the out parameter.
	*/
	exports$1.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
		var strLen = aStr.length;
		var result = 0;
		var shift = 0;
		var continuation, digit;
		do {
			if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
			digit = base64.decode(aStr.charCodeAt(aIndex++));
			if (digit === -1) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
			continuation = !!(digit & VLQ_CONTINUATION_BIT);
			digit &= VLQ_BASE_MASK;
			result = result + (digit << shift);
			shift += VLQ_BASE_SHIFT;
		} while (continuation);
		aOutParam.value = fromVLQSigned(result);
		aOutParam.rest = aIndex;
	};
} });
var require_util = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js"(exports$1) {
	/**
	* This is a helper function for getting values from parameter/options
	* objects.
	*
	* @param args The object we are extracting values from
	* @param name The name of the property we are getting.
	* @param defaultValue An optional value to return if the property is missing
	* from the object. If this is not specified and the property is missing, an
	* error will be thrown.
	*/
	function getArg(aArgs, aName, aDefaultValue) {
		if (aName in aArgs) return aArgs[aName];
else if (arguments.length === 3) return aDefaultValue;
else throw new Error("\"" + aName + "\" is a required argument.");
	}
	exports$1.getArg = getArg;
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	function urlParse(aUrl) {
		var match = aUrl.match(urlRegexp);
		if (!match) return null;
		return {
			scheme: match[1],
			auth: match[2],
			host: match[3],
			port: match[4],
			path: match[5]
		};
	}
	exports$1.urlParse = urlParse;
	function urlGenerate(aParsedUrl) {
		var url = "";
		if (aParsedUrl.scheme) url += aParsedUrl.scheme + ":";
		url += "//";
		if (aParsedUrl.auth) url += aParsedUrl.auth + "@";
		if (aParsedUrl.host) url += aParsedUrl.host;
		if (aParsedUrl.port) url += ":" + aParsedUrl.port;
		if (aParsedUrl.path) url += aParsedUrl.path;
		return url;
	}
	exports$1.urlGenerate = urlGenerate;
	var MAX_CACHED_INPUTS = 32;
	/**
	* Takes some function `f(input) -> result` and returns a memoized version of
	* `f`.
	*
	* We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
	* memoization is a dumb-simple, linear least-recently-used cache.
	*/
	function lruMemoize(f) {
		var cache = [];
		return function(input) {
			for (var i$1 = 0; i$1 < cache.length; i$1++) if (cache[i$1].input === input) {
				var temp = cache[0];
				cache[0] = cache[i$1];
				cache[i$1] = temp;
				return cache[0].result;
			}
			var result = f(input);
			cache.unshift({
				input,
				result
			});
			if (cache.length > MAX_CACHED_INPUTS) cache.pop();
			return result;
		};
	}
	/**
	* Normalizes a path, or the path portion of a URL:
	*
	* - Replaces consecutive slashes with one slash.
	* - Removes unnecessary '.' parts.
	* - Removes unnecessary '<dir>/..' parts.
	*
	* Based on code in the Node.js 'path' core module.
	*
	* @param aPath The path or url to normalize.
	*/
	var normalize$1 = lruMemoize(function normalize$1$1(aPath) {
		var path$2 = aPath;
		var url = urlParse(aPath);
		if (url) {
			if (!url.path) return aPath;
			path$2 = url.path;
		}
		var isAbsolute$1 = exports$1.isAbsolute(path$2);
		var parts = [];
		var start = 0;
		var i$1 = 0;
		while (true) {
			start = i$1;
			i$1 = path$2.indexOf("/", start);
			if (i$1 === -1) {
				parts.push(path$2.slice(start));
				break;
			} else {
				parts.push(path$2.slice(start, i$1));
				while (i$1 < path$2.length && path$2[i$1] === "/") i$1++;
			}
		}
		for (var part, up$2 = 0, i$1 = parts.length - 1; i$1 >= 0; i$1--) {
			part = parts[i$1];
			if (part === ".") parts.splice(i$1, 1);
else if (part === "..") up$2++;
else if (up$2 > 0) if (part === "") {
				parts.splice(i$1 + 1, up$2);
				up$2 = 0;
			} else {
				parts.splice(i$1, 2);
				up$2--;
			}
		}
		path$2 = parts.join("/");
		if (path$2 === "") path$2 = isAbsolute$1 ? "/" : ".";
		if (url) {
			url.path = path$2;
			return urlGenerate(url);
		}
		return path$2;
	});
	exports$1.normalize = normalize$1;
	/**
	* Joins two paths/URLs.
	*
	* @param aRoot The root path or URL.
	* @param aPath The path or URL to be joined with the root.
	*
	* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	*   first.
	* - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	*   is updated with the result and aRoot is returned. Otherwise the result
	*   is returned.
	*   - If aPath is absolute, the result is aPath.
	*   - Otherwise the two paths are joined with a slash.
	* - Joining for example 'http://' and 'www.example.com' is also supported.
	*/
	function join$1(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		if (aPath === "") aPath = ".";
		var aPathUrl = urlParse(aPath);
		var aRootUrl = urlParse(aRoot);
		if (aRootUrl) aRoot = aRootUrl.path || "/";
		if (aPathUrl && !aPathUrl.scheme) {
			if (aRootUrl) aPathUrl.scheme = aRootUrl.scheme;
			return urlGenerate(aPathUrl);
		}
		if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
		if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
			aRootUrl.host = aPath;
			return urlGenerate(aRootUrl);
		}
		var joined = aPath.charAt(0) === "/" ? aPath : normalize$1(aRoot.replace(/\/+$/, "") + "/" + aPath);
		if (aRootUrl) {
			aRootUrl.path = joined;
			return urlGenerate(aRootUrl);
		}
		return joined;
	}
	exports$1.join = join$1;
	exports$1.isAbsolute = function(aPath) {
		return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
	};
	/**
	* Make a path relative to a URL or another path.
	*
	* @param aRoot The root path or URL.
	* @param aPath The path or URL to be made relative to aRoot.
	*/
	function relative$1(aRoot, aPath) {
		if (aRoot === "") aRoot = ".";
		aRoot = aRoot.replace(/\/$/, "");
		var level = 0;
		while (aPath.indexOf(aRoot + "/") !== 0) {
			var index = aRoot.lastIndexOf("/");
			if (index < 0) return aPath;
			aRoot = aRoot.slice(0, index);
			if (aRoot.match(/^([^\/]+:\/)?\/*$/)) return aPath;
			++level;
		}
		return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports$1.relative = relative$1;
	var supportsNullProto = function() {
		var obj = Object.create(null);
		return !("__proto__" in obj);
	}();
	function identity$1(s$1) {
		return s$1;
	}
	/**
	* Because behavior goes wacky when you set `__proto__` on objects, we
	* have to prefix all the strings in our set with an arbitrary character.
	*
	* See https://github.com/mozilla/source-map/pull/31 and
	* https://github.com/mozilla/source-map/issues/30
	*
	* @param String aStr
	*/
	function toSetString(aStr) {
		if (isProtoString(aStr)) return "$" + aStr;
		return aStr;
	}
	exports$1.toSetString = supportsNullProto ? identity$1 : toSetString;
	function fromSetString(aStr) {
		if (isProtoString(aStr)) return aStr.slice(1);
		return aStr;
	}
	exports$1.fromSetString = supportsNullProto ? identity$1 : fromSetString;
	function isProtoString(s$1) {
		if (!s$1) return false;
		var length = s$1.length;
		if (length < 9) return false;
		if (s$1.charCodeAt(length - 1) !== 95 || s$1.charCodeAt(length - 2) !== 95 || s$1.charCodeAt(length - 3) !== 111 || s$1.charCodeAt(length - 4) !== 116 || s$1.charCodeAt(length - 5) !== 111 || s$1.charCodeAt(length - 6) !== 114 || s$1.charCodeAt(length - 7) !== 112 || s$1.charCodeAt(length - 8) !== 95 || s$1.charCodeAt(length - 9) !== 95) return false;
		for (var i$1 = length - 10; i$1 >= 0; i$1--) if (s$1.charCodeAt(i$1) !== 36) return false;
		return true;
	}
	/**
	* Comparator between two mappings where the original positions are compared.
	*
	* Optionally pass in `true` as `onlyCompareGenerated` to consider two
	* mappings with the same original source/line/column, but different generated
	* line and column the same. Useful when searching for a mapping with a
	* stubbed out mapping.
	*/
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		var cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports$1.compareByOriginalPositions = compareByOriginalPositions;
	function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
		var cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports$1.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
	/**
	* Comparator between two mappings with deflated source and name indices where
	* the generated positions are compared.
	*
	* Optionally pass in `true` as `onlyCompareGenerated` to consider two
	* mappings with the same generated line and column, but different
	* source/name/original line and column the same. Useful when searching for a
	* mapping with a stubbed out mapping.
	*/
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports$1.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
	function strcmp(aStr1, aStr2) {
		if (aStr1 === aStr2) return 0;
		if (aStr1 === null) return 1;
		if (aStr2 === null) return -1;
		if (aStr1 > aStr2) return 1;
		return -1;
	}
	/**
	* Comparator between two mappings with inflated source and name strings where
	* the generated positions are compared.
	*/
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) return cmp;
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) return cmp;
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) return cmp;
		return strcmp(mappingA.name, mappingB.name);
	}
	exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	/**
	* Strip any JSON XSSI avoidance prefix from the string (as documented
	* in the source maps specification), and then parse the string as
	* JSON.
	*/
	function parseSourceMapInput(str) {
		return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
	}
	exports$1.parseSourceMapInput = parseSourceMapInput;
	/**
	* Compute the URL of a source given the the source root, the source's
	* URL, and the source map's URL.
	*/
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		sourceURL = sourceURL || "";
		if (sourceRoot) {
			if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") sourceRoot += "/";
			sourceURL = sourceRoot + sourceURL;
		}
		if (sourceMapURL) {
			var parsed = urlParse(sourceMapURL);
			if (!parsed) throw new Error("sourceMapURL could not be parsed");
			if (parsed.path) {
				var index = parsed.path.lastIndexOf("/");
				if (index >= 0) parsed.path = parsed.path.substring(0, index + 1);
			}
			sourceURL = join$1(urlGenerate(parsed), sourceURL);
		}
		return normalize$1(sourceURL);
	}
	exports$1.computeSourceURL = computeSourceURL;
} });
var require_array_set = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js"(exports$1) {
	var util$4 = require_util();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	/**
	* A data structure which is a combination of an array and a set. Adding a new
	* member is O(1), testing for membership is O(1), and finding the index of an
	* element is O(1). Removing elements from the set is not supported. Only
	* strings are supported for membership.
	*/
	function ArraySet$2() {
		this._array = [];
		this._set = hasNativeMap ? new Map() : Object.create(null);
	}
	/**
	* Static method for creating ArraySet instances from an existing array.
	*/
	ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
		var set = new ArraySet$2();
		for (var i$1 = 0, len = aArray.length; i$1 < len; i$1++) set.add(aArray[i$1], aAllowDuplicates);
		return set;
	};
	/**
	* Return how many unique items are in this ArraySet. If duplicates have been
	* added, than those do not count towards the size.
	*
	* @returns Number
	*/
	ArraySet$2.prototype.size = function ArraySet_size() {
		return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	/**
	* Add the given string to this set.
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
		var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
		var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
		var idx = this._array.length;
		if (!isDuplicate || aAllowDuplicates) this._array.push(aStr);
		if (!isDuplicate) if (hasNativeMap) this._set.set(aStr, idx);
else this._set[sStr] = idx;
	};
	/**
	* Is the given string a member of this set?
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.has = function ArraySet_has(aStr) {
		if (hasNativeMap) return this._set.has(aStr);
else {
			var sStr = util$4.toSetString(aStr);
			return has.call(this._set, sStr);
		}
	};
	/**
	* What is the index of the given string in the array?
	*
	* @param String aStr
	*/
	ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
		if (hasNativeMap) {
			var idx = this._set.get(aStr);
			if (idx >= 0) return idx;
		} else {
			var sStr = util$4.toSetString(aStr);
			if (has.call(this._set, sStr)) return this._set[sStr];
		}
		throw new Error("\"" + aStr + "\" is not in the set.");
	};
	/**
	* What is the element at the given index?
	*
	* @param Number aIdx
	*/
	ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
		if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
		throw new Error("No element indexed by " + aIdx);
	};
	/**
	* Returns the array representation of this set (which has the proper indices
	* indicated by indexOf). Note that this is a copy of the internal array used
	* for storing the members so that no one can mess with internal state.
	*/
	ArraySet$2.prototype.toArray = function ArraySet_toArray() {
		return this._array.slice();
	};
	exports$1.ArraySet = ArraySet$2;
} });
var require_mapping_list = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js"(exports$1) {
	var util$3 = require_util();
	/**
	* Determine whether mappingB is after mappingA with respect to generated
	* position.
	*/
	function generatedPositionAfter(mappingA, mappingB) {
		var lineA = mappingA.generatedLine;
		var lineB = mappingB.generatedLine;
		var columnA = mappingA.generatedColumn;
		var columnB = mappingB.generatedColumn;
		return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	/**
	* A data structure to provide a sorted view of accumulated mappings in a
	* performance conscious manner. It trades a neglibable overhead in general
	* case for a large speedup in case of mappings being added in order.
	*/
	function MappingList$1() {
		this._array = [];
		this._sorted = true;
		this._last = {
			generatedLine: -1,
			generatedColumn: 0
		};
	}
	/**
	* Iterate through internal items. This method takes the same arguments that
	* `Array.prototype.forEach` takes.
	*
	* NOTE: The order of the mappings is NOT guaranteed.
	*/
	MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
		this._array.forEach(aCallback, aThisArg);
	};
	/**
	* Add the given source mapping.
	*
	* @param Object aMapping
	*/
	MappingList$1.prototype.add = function MappingList_add(aMapping) {
		if (generatedPositionAfter(this._last, aMapping)) {
			this._last = aMapping;
			this._array.push(aMapping);
		} else {
			this._sorted = false;
			this._array.push(aMapping);
		}
	};
	/**
	* Returns the flat, sorted array of mappings. The mappings are sorted by
	* generated position.
	*
	* WARNING: This method returns internal data without copying, for
	* performance. The return value must NOT be mutated, and should be treated as
	* an immutable borrow. If you want to take ownership, you must make your own
	* copy.
	*/
	MappingList$1.prototype.toArray = function MappingList_toArray() {
		if (!this._sorted) {
			this._array.sort(util$3.compareByGeneratedPositionsInflated);
			this._sorted = true;
		}
		return this._array;
	};
	exports$1.MappingList = MappingList$1;
} });
var require_source_map_generator = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js"(exports$1) {
	var base64VLQ$1 = require_base64_vlq();
	var util$2 = require_util();
	var ArraySet$1 = require_array_set().ArraySet;
	var MappingList = require_mapping_list().MappingList;
	/**
	* An instance of the SourceMapGenerator represents a source map which is
	* being built incrementally. You may pass an object with the following
	* properties:
	*
	*   - file: The filename of the generated source.
	*   - sourceRoot: A root for all relative URLs in this source map.
	*/
	function SourceMapGenerator$4(aArgs) {
		if (!aArgs) aArgs = {};
		this._file = util$2.getArg(aArgs, "file", null);
		this._sourceRoot = util$2.getArg(aArgs, "sourceRoot", null);
		this._skipValidation = util$2.getArg(aArgs, "skipValidation", false);
		this._ignoreInvalidMapping = util$2.getArg(aArgs, "ignoreInvalidMapping", false);
		this._sources = new ArraySet$1();
		this._names = new ArraySet$1();
		this._mappings = new MappingList();
		this._sourcesContents = null;
	}
	SourceMapGenerator$4.prototype._version = 3;
	/**
	* Creates a new SourceMapGenerator based on a SourceMapConsumer
	*
	* @param aSourceMapConsumer The SourceMap.
	*/
	SourceMapGenerator$4.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
		var sourceRoot = aSourceMapConsumer.sourceRoot;
		var generator = new SourceMapGenerator$4(Object.assign(generatorOps || {}, {
			file: aSourceMapConsumer.file,
			sourceRoot
		}));
		aSourceMapConsumer.eachMapping(function(mapping) {
			var newMapping = { generated: {
				line: mapping.generatedLine,
				column: mapping.generatedColumn
			} };
			if (mapping.source != null) {
				newMapping.source = mapping.source;
				if (sourceRoot != null) newMapping.source = util$2.relative(sourceRoot, newMapping.source);
				newMapping.original = {
					line: mapping.originalLine,
					column: mapping.originalColumn
				};
				if (mapping.name != null) newMapping.name = mapping.name;
			}
			generator.addMapping(newMapping);
		});
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var sourceRelative = sourceFile;
			if (sourceRoot !== null) sourceRelative = util$2.relative(sourceRoot, sourceFile);
			if (!generator._sources.has(sourceRelative)) generator._sources.add(sourceRelative);
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) generator.setSourceContent(sourceFile, content);
		});
		return generator;
	};
	/**
	* Add a single mapping from original source line and column to the generated
	* source's line and column for this source map being created. The mapping
	* object should have the following properties:
	*
	*   - generated: An object with the generated line and column positions.
	*   - original: An object with the original line and column positions.
	*   - source: The original source file (relative to the sourceRoot).
	*   - name: An optional original token name for this mapping.
	*/
	SourceMapGenerator$4.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
		var generated = util$2.getArg(aArgs, "generated");
		var original = util$2.getArg(aArgs, "original", null);
		var source = util$2.getArg(aArgs, "source", null);
		var name = util$2.getArg(aArgs, "name", null);
		if (!this._skipValidation) {
			if (this._validateMapping(generated, original, source, name) === false) return;
		}
		if (source != null) {
			source = String(source);
			if (!this._sources.has(source)) this._sources.add(source);
		}
		if (name != null) {
			name = String(name);
			if (!this._names.has(name)) this._names.add(name);
		}
		this._mappings.add({
			generatedLine: generated.line,
			generatedColumn: generated.column,
			originalLine: original != null && original.line,
			originalColumn: original != null && original.column,
			source,
			name
		});
	};
	/**
	* Set the source content for a source file.
	*/
	SourceMapGenerator$4.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
		var source = aSourceFile;
		if (this._sourceRoot != null) source = util$2.relative(this._sourceRoot, source);
		if (aSourceContent != null) {
			if (!this._sourcesContents) this._sourcesContents = Object.create(null);
			this._sourcesContents[util$2.toSetString(source)] = aSourceContent;
		} else if (this._sourcesContents) {
			delete this._sourcesContents[util$2.toSetString(source)];
			if (Object.keys(this._sourcesContents).length === 0) this._sourcesContents = null;
		}
	};
	/**
	* Applies the mappings of a sub-source-map for a specific source file to the
	* source map being generated. Each mapping to the supplied source file is
	* rewritten using the supplied source map. Note: The resolution for the
	* resulting mappings is the minimium of this map and the supplied map.
	*
	* @param aSourceMapConsumer The source map to be applied.
	* @param aSourceFile Optional. The filename of the source file.
	*        If omitted, SourceMapConsumer's file property will be used.
	* @param aSourceMapPath Optional. The dirname of the path to the source map
	*        to be applied. If relative, it is relative to the SourceMapConsumer.
	*        This parameter is needed when the two source maps aren't in the same
	*        directory, and the source map to be applied contains relative source
	*        paths. If so, those relative source paths need to be rewritten
	*        relative to the SourceMapGenerator.
	*/
	SourceMapGenerator$4.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
		var sourceFile = aSourceFile;
		if (aSourceFile == null) {
			if (aSourceMapConsumer.file == null) throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's \"file\" property. Both were omitted.");
			sourceFile = aSourceMapConsumer.file;
		}
		var sourceRoot = this._sourceRoot;
		if (sourceRoot != null) sourceFile = util$2.relative(sourceRoot, sourceFile);
		var newSources = new ArraySet$1();
		var newNames = new ArraySet$1();
		this._mappings.unsortedForEach(function(mapping) {
			if (mapping.source === sourceFile && mapping.originalLine != null) {
				var original = aSourceMapConsumer.originalPositionFor({
					line: mapping.originalLine,
					column: mapping.originalColumn
				});
				if (original.source != null) {
					mapping.source = original.source;
					if (aSourceMapPath != null) mapping.source = util$2.join(aSourceMapPath, mapping.source);
					if (sourceRoot != null) mapping.source = util$2.relative(sourceRoot, mapping.source);
					mapping.originalLine = original.line;
					mapping.originalColumn = original.column;
					if (original.name != null) mapping.name = original.name;
				}
			}
			var source = mapping.source;
			if (source != null && !newSources.has(source)) newSources.add(source);
			var name = mapping.name;
			if (name != null && !newNames.has(name)) newNames.add(name);
		}, this);
		this._sources = newSources;
		this._names = newNames;
		aSourceMapConsumer.sources.forEach(function(sourceFile$1) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile$1);
			if (content != null) {
				if (aSourceMapPath != null) sourceFile$1 = util$2.join(aSourceMapPath, sourceFile$1);
				if (sourceRoot != null) sourceFile$1 = util$2.relative(sourceRoot, sourceFile$1);
				this.setSourceContent(sourceFile$1, content);
			}
		}, this);
	};
	/**
	* A mapping can have one of the three levels of data:
	*
	*   1. Just the generated position.
	*   2. The Generated position, original position, and original source.
	*   3. Generated and original position, original source, as well as a name
	*      token.
	*
	* To maintain consistency, we validate that any new mapping being added falls
	* in to one of these categories.
	*/
	SourceMapGenerator$4.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
		if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
			var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) console.warn(message);
				return false;
			} else throw new Error(message);
		}
		if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) return;
else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
else {
			var message = "Invalid mapping: " + JSON.stringify({
				generated: aGenerated,
				source: aSource,
				original: aOriginal,
				name: aName
			});
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) console.warn(message);
				return false;
			} else throw new Error(message);
		}
	};
	/**
	* Serialize the accumulated mappings in to the stream of base 64 VLQs
	* specified by the source map format.
	*/
	SourceMapGenerator$4.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
		var previousGeneratedColumn = 0;
		var previousGeneratedLine = 1;
		var previousOriginalColumn = 0;
		var previousOriginalLine = 0;
		var previousName = 0;
		var previousSource = 0;
		var result = "";
		var next;
		var mapping;
		var nameIdx;
		var sourceIdx;
		var mappings = this._mappings.toArray();
		for (var i$1 = 0, len = mappings.length; i$1 < len; i$1++) {
			mapping = mappings[i$1];
			next = "";
			if (mapping.generatedLine !== previousGeneratedLine) {
				previousGeneratedColumn = 0;
				while (mapping.generatedLine !== previousGeneratedLine) {
					next += ";";
					previousGeneratedLine++;
				}
			} else if (i$1 > 0) {
				if (!util$2.compareByGeneratedPositionsInflated(mapping, mappings[i$1 - 1])) continue;
				next += ",";
			}
			next += base64VLQ$1.encode(mapping.generatedColumn - previousGeneratedColumn);
			previousGeneratedColumn = mapping.generatedColumn;
			if (mapping.source != null) {
				sourceIdx = this._sources.indexOf(mapping.source);
				next += base64VLQ$1.encode(sourceIdx - previousSource);
				previousSource = sourceIdx;
				next += base64VLQ$1.encode(mapping.originalLine - 1 - previousOriginalLine);
				previousOriginalLine = mapping.originalLine - 1;
				next += base64VLQ$1.encode(mapping.originalColumn - previousOriginalColumn);
				previousOriginalColumn = mapping.originalColumn;
				if (mapping.name != null) {
					nameIdx = this._names.indexOf(mapping.name);
					next += base64VLQ$1.encode(nameIdx - previousName);
					previousName = nameIdx;
				}
			}
			result += next;
		}
		return result;
	};
	SourceMapGenerator$4.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
		return aSources.map(function(source) {
			if (!this._sourcesContents) return null;
			if (aSourceRoot != null) source = util$2.relative(aSourceRoot, source);
			var key = util$2.toSetString(source);
			return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
		}, this);
	};
	/**
	* Externalize the source map.
	*/
	SourceMapGenerator$4.prototype.toJSON = function SourceMapGenerator_toJSON() {
		var map = {
			version: this._version,
			sources: this._sources.toArray(),
			names: this._names.toArray(),
			mappings: this._serializeMappings()
		};
		if (this._file != null) map.file = this._file;
		if (this._sourceRoot != null) map.sourceRoot = this._sourceRoot;
		if (this._sourcesContents) map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
		return map;
	};
	/**
	* Render the source map being generated to a string.
	*/
	SourceMapGenerator$4.prototype.toString = function SourceMapGenerator_toString() {
		return JSON.stringify(this.toJSON());
	};
	exports$1.SourceMapGenerator = SourceMapGenerator$4;
} });
var require_binary_search = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/binary-search.js"(exports$1) {
	exports$1.GREATEST_LOWER_BOUND = 1;
	exports$1.LEAST_UPPER_BOUND = 2;
	/**
	* Recursive implementation of binary search.
	*
	* @param aLow Indices here and lower do not contain the needle.
	* @param aHigh Indices here and higher do not contain the needle.
	* @param aNeedle The element being searched for.
	* @param aHaystack The non-empty array being searched.
	* @param aCompare Function which takes two elements and returns -1, 0, or 1.
	* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*/
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		var cmp = aCompare(aNeedle, aHaystack[mid], true);
		if (cmp === 0) return mid;
else if (cmp > 0) {
			if (aHigh - mid > 1) return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports$1.LEAST_UPPER_BOUND) return aHigh < aHaystack.length ? aHigh : -1;
else return mid;
		} else {
			if (mid - aLow > 1) return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
			if (aBias == exports$1.LEAST_UPPER_BOUND) return mid;
else return aLow < 0 ? -1 : aLow;
		}
	}
	/**
	* This is an implementation of binary search which will always try and return
	* the index of the closest element if there is no exact hit. This is because
	* mappings between original and generated line/col pairs are single points,
	* and there is an implicit region between each of them, so a miss just means
	* that you aren't on the very start of a region.
	*
	* @param aNeedle The element you are looking for.
	* @param aHaystack The array that is being searched.
	* @param aCompare A function which takes the needle and an element in the
	*     array and returns -1, 0, or 1 depending on whether the needle is less
	*     than, equal to, or greater than the element, respectively.
	* @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	*/
	exports$1.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		if (aHaystack.length === 0) return -1;
		var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports$1.GREATEST_LOWER_BOUND);
		if (index < 0) return -1;
		while (index - 1 >= 0) {
			if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) break;
			--index;
		}
		return index;
	};
} });
var require_quick_sort = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/quick-sort.js"(exports$1) {
	function SortTemplate(comparator) {
		/**
		* Swap the elements indexed by `x` and `y` in the array `ary`.
		*
		* @param {Array} ary
		*        The array.
		* @param {Number} x
		*        The index of the first item.
		* @param {Number} y
		*        The index of the second item.
		*/
		function swap(ary, x$1, y) {
			var temp = ary[x$1];
			ary[x$1] = ary[y];
			ary[y] = temp;
		}
		/**
		* Returns a random integer within the range `low .. high` inclusive.
		*
		* @param {Number} low
		*        The lower bound on the range.
		* @param {Number} high
		*        The upper bound on the range.
		*/
		function randomIntInRange(low, high) {
			return Math.round(low + Math.random() * (high - low));
		}
		/**
		* The Quick Sort algorithm.
		*
		* @param {Array} ary
		*        An array to sort.
		* @param {function} comparator
		*        Function to use to compare two items.
		* @param {Number} p
		*        Start index of the array
		* @param {Number} r
		*        End index of the array
		*/
		function doQuickSort(ary, comparator$1, p$1, r) {
			if (p$1 < r) {
				var pivotIndex = randomIntInRange(p$1, r);
				var i$1 = p$1 - 1;
				swap(ary, pivotIndex, r);
				var pivot = ary[r];
				for (var j = p$1; j < r; j++) if (comparator$1(ary[j], pivot, false) <= 0) {
					i$1 += 1;
					swap(ary, i$1, j);
				}
				swap(ary, i$1 + 1, j);
				var q$1 = i$1 + 1;
				doQuickSort(ary, comparator$1, p$1, q$1 - 1);
				doQuickSort(ary, comparator$1, q$1 + 1, r);
			}
		}
		return doQuickSort;
	}
	function cloneSort(comparator) {
		let template = SortTemplate.toString();
		let templateFn = new Function(`return ${template}`)();
		return templateFn(comparator);
	}
	/**
	* Sort the given array in-place with the given comparator function.
	*
	* @param {Array} ary
	*        An array to sort.
	* @param {function} comparator
	*        Function to use to compare two items.
	*/
	let sortCache = new WeakMap();
	exports$1.quickSort = function(ary, comparator, start = 0) {
		let doQuickSort = sortCache.get(comparator);
		if (doQuickSort === void 0) {
			doQuickSort = cloneSort(comparator);
			sortCache.set(comparator, doQuickSort);
		}
		doQuickSort(ary, comparator, start, ary.length - 1);
	};
} });
var require_source_map_consumer = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-consumer.js"(exports$1) {
	var util$1 = require_util();
	var binarySearch = require_binary_search();
	var ArraySet = require_array_set().ArraySet;
	var base64VLQ = require_base64_vlq();
	var quickSort = require_quick_sort().quickSort;
	function SourceMapConsumer$3(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	SourceMapConsumer$3.fromSourceMap = function(aSourceMap, aSourceMapURL) {
		return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	SourceMapConsumer$3.prototype._version = 3;
	SourceMapConsumer$3.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer$3.prototype, "_generatedMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__generatedMappings;
		}
	});
	SourceMapConsumer$3.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer$3.prototype, "_originalMappings", {
		configurable: true,
		enumerable: true,
		get: function() {
			if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
			return this.__originalMappings;
		}
	});
	SourceMapConsumer$3.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
		var c$1 = aStr.charAt(index);
		return c$1 === ";" || c$1 === ",";
	};
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	SourceMapConsumer$3.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		throw new Error("Subclasses must implement _parseMappings");
	};
	SourceMapConsumer$3.GENERATED_ORDER = 1;
	SourceMapConsumer$3.ORIGINAL_ORDER = 2;
	SourceMapConsumer$3.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer$3.LEAST_UPPER_BOUND = 2;
	/**
	* Iterate over each mapping between an original source/line/column and a
	* generated line/column in this source map.
	*
	* @param Function aCallback
	*        The function that is called with each mapping.
	* @param Object aContext
	*        Optional. If specified, this object will be the value of `this` every
	*        time that `aCallback` is called.
	* @param aOrder
	*        Either `SourceMapConsumer.GENERATED_ORDER` or
	*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	*        iterate over the mappings sorted by the generated file's line/column
	*        order or the original's source/line/column order, respectively. Defaults to
	*        `SourceMapConsumer.GENERATED_ORDER`.
	*/
	SourceMapConsumer$3.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
		var context = aContext || null;
		var order = aOrder || SourceMapConsumer$3.GENERATED_ORDER;
		var mappings;
		switch (order) {
			case SourceMapConsumer$3.GENERATED_ORDER:
				mappings = this._generatedMappings;
				break;
			case SourceMapConsumer$3.ORIGINAL_ORDER:
				mappings = this._originalMappings;
				break;
			default: throw new Error("Unknown order of iteration.");
		}
		var sourceRoot = this.sourceRoot;
		var boundCallback = aCallback.bind(context);
		var names = this._names;
		var sources = this._sources;
		var sourceMapURL = this._sourceMapURL;
		for (var i$1 = 0, n$1 = mappings.length; i$1 < n$1; i$1++) {
			var mapping = mappings[i$1];
			var source = mapping.source === null ? null : sources.at(mapping.source);
			if (source !== null) source = util$1.computeSourceURL(sourceRoot, source, sourceMapURL);
			boundCallback({
				source,
				generatedLine: mapping.generatedLine,
				generatedColumn: mapping.generatedColumn,
				originalLine: mapping.originalLine,
				originalColumn: mapping.originalColumn,
				name: mapping.name === null ? null : names.at(mapping.name)
			});
		}
	};
	/**
	* Returns all generated line and column information for the original source,
	* line, and column provided. If no column is provided, returns all mappings
	* corresponding to a either the line we are searching for or the next
	* closest line that has any mappings. Otherwise, returns all mappings
	* corresponding to the given line and either the column we are searching for
	* or the next closest column that has any offsets.
	*
	* The only argument is an object with the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number is 1-based.
	*   - column: Optional. the column number in the original source.
	*    The column number is 0-based.
	*
	* and an array of objects is returned, each with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*    line number is 1-based.
	*   - column: The column number in the generated source, or null.
	*    The column number is 0-based.
	*/
	SourceMapConsumer$3.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
		var line = util$1.getArg(aArgs, "line");
		var needle = {
			source: util$1.getArg(aArgs, "source"),
			originalLine: line,
			originalColumn: util$1.getArg(aArgs, "column", 0)
		};
		needle.source = this._findSourceIndex(needle.source);
		if (needle.source < 0) return [];
		var mappings = [];
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (aArgs.column === undefined) {
				var originalLine = mapping.originalLine;
				while (mapping && mapping.originalLine === originalLine) {
					mappings.push({
						line: util$1.getArg(mapping, "generatedLine", null),
						column: util$1.getArg(mapping, "generatedColumn", null),
						lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			} else {
				var originalColumn = mapping.originalColumn;
				while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
					mappings.push({
						line: util$1.getArg(mapping, "generatedLine", null),
						column: util$1.getArg(mapping, "generatedColumn", null),
						lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
					});
					mapping = this._originalMappings[++index];
				}
			}
		}
		return mappings;
	};
	exports$1.SourceMapConsumer = SourceMapConsumer$3;
	/**
	* A BasicSourceMapConsumer instance represents a parsed source map which we can
	* query for information about the original file positions by giving it a file
	* position in the generated source.
	*
	* The first parameter is the raw source map (either as a JSON string, or
	* already parsed to an object). According to the spec, source maps have the
	* following attributes:
	*
	*   - version: Which version of the source map spec this map is following.
	*   - sources: An array of URLs to the original source files.
	*   - names: An array of identifiers which can be referrenced by individual mappings.
	*   - sourceRoot: Optional. The URL root from which all sources are relative.
	*   - sourcesContent: Optional. An array of contents of the original source files.
	*   - mappings: A string of base64 VLQs which contain the actual mappings.
	*   - file: Optional. The generated file this source map is associated with.
	*
	* Here is an example source map, taken from the source map spec[0]:
	*
	*     {
	*       version : 3,
	*       file: "out.js",
	*       sourceRoot : "",
	*       sources: ["foo.js", "bar.js"],
	*       names: ["src", "maps", "are", "fun"],
	*       mappings: "AA,AB;;ABCDE;"
	*     }
	*
	* The second parameter, if given, is a string whose value is the URL
	* at which the source map was found.  This URL is used to compute the
	* sources array.
	*
	* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	*/
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		var version$1 = util$1.getArg(sourceMap, "version");
		var sources = util$1.getArg(sourceMap, "sources");
		var names = util$1.getArg(sourceMap, "names", []);
		var sourceRoot = util$1.getArg(sourceMap, "sourceRoot", null);
		var sourcesContent = util$1.getArg(sourceMap, "sourcesContent", null);
		var mappings = util$1.getArg(sourceMap, "mappings");
		var file = util$1.getArg(sourceMap, "file", null);
		if (version$1 != this._version) throw new Error("Unsupported version: " + version$1);
		if (sourceRoot) sourceRoot = util$1.normalize(sourceRoot);
		sources = sources.map(String).map(util$1.normalize).map(function(source) {
			return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source) ? util$1.relative(sourceRoot, source) : source;
		});
		this._names = ArraySet.fromArray(names.map(String), true);
		this._sources = ArraySet.fromArray(sources, true);
		this._absoluteSources = this._sources.toArray().map(function(s$1) {
			return util$1.computeSourceURL(sourceRoot, s$1, aSourceMapURL);
		});
		this.sourceRoot = sourceRoot;
		this.sourcesContent = sourcesContent;
		this._mappings = mappings;
		this._sourceMapURL = aSourceMapURL;
		this.file = file;
	}
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$3.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$3;
	/**
	* Utility function to find the index of a source.  Returns -1 if not
	* found.
	*/
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
		if (this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
		var i$1;
		for (i$1 = 0; i$1 < this._absoluteSources.length; ++i$1) if (this._absoluteSources[i$1] == aSource) return i$1;
		return -1;
	};
	/**
	* Create a BasicSourceMapConsumer from a SourceMapGenerator.
	*
	* @param SourceMapGenerator aSourceMap
	*        The source map that will be consumed.
	* @param String aSourceMapURL
	*        The URL at which the source map can be found (optional)
	* @returns BasicSourceMapConsumer
	*/
	BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
		var smc = Object.create(BasicSourceMapConsumer.prototype);
		var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
		var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
		smc.sourceRoot = aSourceMap._sourceRoot;
		smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
		smc.file = aSourceMap._file;
		smc._sourceMapURL = aSourceMapURL;
		smc._absoluteSources = smc._sources.toArray().map(function(s$1) {
			return util$1.computeSourceURL(smc.sourceRoot, s$1, aSourceMapURL);
		});
		var generatedMappings = aSourceMap._mappings.toArray().slice();
		var destGeneratedMappings = smc.__generatedMappings = [];
		var destOriginalMappings = smc.__originalMappings = [];
		for (var i$1 = 0, length = generatedMappings.length; i$1 < length; i$1++) {
			var srcMapping = generatedMappings[i$1];
			var destMapping = new Mapping();
			destMapping.generatedLine = srcMapping.generatedLine;
			destMapping.generatedColumn = srcMapping.generatedColumn;
			if (srcMapping.source) {
				destMapping.source = sources.indexOf(srcMapping.source);
				destMapping.originalLine = srcMapping.originalLine;
				destMapping.originalColumn = srcMapping.originalColumn;
				if (srcMapping.name) destMapping.name = names.indexOf(srcMapping.name);
				destOriginalMappings.push(destMapping);
			}
			destGeneratedMappings.push(destMapping);
		}
		quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);
		return smc;
	};
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	BasicSourceMapConsumer.prototype._version = 3;
	/**
	* The list of original sources.
	*/
	Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
		return this._absoluteSources.slice();
	} });
	/**
	* Provide the JIT with a nice shape / hidden class.
	*/
	function Mapping() {
		this.generatedLine = 0;
		this.generatedColumn = 0;
		this.source = null;
		this.originalLine = null;
		this.originalColumn = null;
		this.name = null;
	}
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	const compareGenerated = util$1.compareByGeneratedPositionsDeflatedNoLine;
	function sortGenerated(array, start) {
		let l$1$1 = array.length;
		let n$1 = array.length - start;
		if (n$1 <= 1) return;
else if (n$1 == 2) {
			let a = array[start];
			let b = array[start + 1];
			if (compareGenerated(a, b) > 0) {
				array[start] = b;
				array[start + 1] = a;
			}
		} else if (n$1 < 20) for (let i$1 = start; i$1 < l$1$1; i$1++) for (let j = i$1; j > start; j--) {
			let a = array[j - 1];
			let b = array[j];
			if (compareGenerated(a, b) <= 0) break;
			array[j - 1] = b;
			array[j] = a;
		}
else quickSort(array, compareGenerated, start);
	}
	BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		var generatedLine = 1;
		var previousGeneratedColumn = 0;
		var previousOriginalLine = 0;
		var previousOriginalColumn = 0;
		var previousSource = 0;
		var previousName = 0;
		var length = aStr.length;
		var index = 0;
		var cachedSegments = {};
		var temp = {};
		var originalMappings = [];
		var generatedMappings = [];
		var mapping, str, segment, end, value;
		let subarrayStart = 0;
		while (index < length) if (aStr.charAt(index) === ";") {
			generatedLine++;
			index++;
			previousGeneratedColumn = 0;
			sortGenerated(generatedMappings, subarrayStart);
			subarrayStart = generatedMappings.length;
		} else if (aStr.charAt(index) === ",") index++;
else {
			mapping = new Mapping();
			mapping.generatedLine = generatedLine;
			for (end = index; end < length; end++) if (this._charIsMappingSeparator(aStr, end)) break;
			str = aStr.slice(index, end);
			segment = [];
			while (index < end) {
				base64VLQ.decode(aStr, index, temp);
				value = temp.value;
				index = temp.rest;
				segment.push(value);
			}
			if (segment.length === 2) throw new Error("Found a source, but no line and column");
			if (segment.length === 3) throw new Error("Found a source and line, but no column");
			mapping.generatedColumn = previousGeneratedColumn + segment[0];
			previousGeneratedColumn = mapping.generatedColumn;
			if (segment.length > 1) {
				mapping.source = previousSource + segment[1];
				previousSource += segment[1];
				mapping.originalLine = previousOriginalLine + segment[2];
				previousOriginalLine = mapping.originalLine;
				mapping.originalLine += 1;
				mapping.originalColumn = previousOriginalColumn + segment[3];
				previousOriginalColumn = mapping.originalColumn;
				if (segment.length > 4) {
					mapping.name = previousName + segment[4];
					previousName += segment[4];
				}
			}
			generatedMappings.push(mapping);
			if (typeof mapping.originalLine === "number") {
				let currentSource = mapping.source;
				while (originalMappings.length <= currentSource) originalMappings.push(null);
				if (originalMappings[currentSource] === null) originalMappings[currentSource] = [];
				originalMappings[currentSource].push(mapping);
			}
		}
		sortGenerated(generatedMappings, subarrayStart);
		this.__generatedMappings = generatedMappings;
		for (var i$1 = 0; i$1 < originalMappings.length; i$1++) if (originalMappings[i$1] != null) quickSort(originalMappings[i$1], util$1.compareByOriginalPositionsNoSource);
		this.__originalMappings = [].concat(...originalMappings);
	};
	/**
	* Find the mapping that best matches the hypothetical "needle" mapping that
	* we are searching for in the given "haystack" of mappings.
	*/
	BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
		if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
		if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
		return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	};
	/**
	* Compute the last column for each generated mapping. The last column is
	* inclusive.
	*/
	BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
		for (var index = 0; index < this._generatedMappings.length; ++index) {
			var mapping = this._generatedMappings[index];
			if (index + 1 < this._generatedMappings.length) {
				var nextMapping = this._generatedMappings[index + 1];
				if (mapping.generatedLine === nextMapping.generatedLine) {
					mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
					continue;
				}
			}
			mapping.lastGeneratedColumn = Infinity;
		}
	};
	/**
	* Returns the original source, line, and column information for the generated
	* source's line and column positions provided. The only argument is an object
	* with the following properties:
	*
	*   - line: The line number in the generated source.  The line number
	*     is 1-based.
	*   - column: The column number in the generated source.  The column
	*     number is 0-based.
	*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	*
	* and an object is returned with the following properties:
	*
	*   - source: The original source file, or null.
	*   - line: The line number in the original source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the original source, or null.  The
	*     column number is 0-based.
	*   - name: The original identifier, or null.
	*/
	BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$1.getArg(aArgs, "line"),
			generatedColumn: util$1.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, "bias", SourceMapConsumer$3.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._generatedMappings[index];
			if (mapping.generatedLine === needle.generatedLine) {
				var source = util$1.getArg(mapping, "source", null);
				if (source !== null) {
					source = this._sources.at(source);
					source = util$1.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
				}
				var name = util$1.getArg(mapping, "name", null);
				if (name !== null) name = this._names.at(name);
				return {
					source,
					line: util$1.getArg(mapping, "originalLine", null),
					column: util$1.getArg(mapping, "originalColumn", null),
					name
				};
			}
		}
		return {
			source: null,
			line: null,
			column: null,
			name: null
		};
	};
	/**
	* Return true if we have the source content for every source in the source
	* map, false otherwise.
	*/
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
		if (!this.sourcesContent) return false;
		return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
			return sc == null;
		});
	};
	/**
	* Returns the original source content. The only argument is the url of the
	* original source file. Returns null if no original source content is
	* available.
	*/
	BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		if (!this.sourcesContent) return null;
		var index = this._findSourceIndex(aSource);
		if (index >= 0) return this.sourcesContent[index];
		var relativeSource = aSource;
		if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
		var url;
		if (this.sourceRoot != null && (url = util$1.urlParse(this.sourceRoot))) {
			var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
			if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
			if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
		}
		if (nullOnMissing) return null;
else throw new Error("\"" + relativeSource + "\" is not in the SourceMap.");
	};
	/**
	* Returns the generated line and column information for the original source,
	* line, and column positions provided. The only argument is an object with
	* the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number
	*     is 1-based.
	*   - column: The column number in the original source.  The column
	*     number is 0-based.
	*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	*     closest element that is smaller than or greater than the one we are
	*     searching for, respectively, if the exact element cannot be found.
	*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	*
	* and an object is returned with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the generated source, or null.
	*     The column number is 0-based.
	*/
	BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
		var source = util$1.getArg(aArgs, "source");
		source = this._findSourceIndex(source);
		if (source < 0) return {
			line: null,
			column: null,
			lastColumn: null
		};
		var needle = {
			source,
			originalLine: util$1.getArg(aArgs, "line"),
			originalColumn: util$1.getArg(aArgs, "column")
		};
		var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, "bias", SourceMapConsumer$3.GREATEST_LOWER_BOUND));
		if (index >= 0) {
			var mapping = this._originalMappings[index];
			if (mapping.source === needle.source) return {
				line: util$1.getArg(mapping, "generatedLine", null),
				column: util$1.getArg(mapping, "generatedColumn", null),
				lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
			};
		}
		return {
			line: null,
			column: null,
			lastColumn: null
		};
	};
	exports$1.BasicSourceMapConsumer = BasicSourceMapConsumer;
	/**
	* An IndexedSourceMapConsumer instance represents a parsed source map which
	* we can query for information. It differs from BasicSourceMapConsumer in
	* that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	* input.
	*
	* The first parameter is a raw source map (either as a JSON string, or already
	* parsed to an object). According to the spec for indexed source maps, they
	* have the following attributes:
	*
	*   - version: Which version of the source map spec this map is following.
	*   - file: Optional. The generated file this source map is associated with.
	*   - sections: A list of section definitions.
	*
	* Each value under the "sections" field has two fields:
	*   - offset: The offset into the original specified at which this section
	*       begins to apply, defined as an object with a "line" and "column"
	*       field.
	*   - map: A source map definition. This source map could also be indexed,
	*       but doesn't have to be.
	*
	* Instead of the "map" field, it's also possible to have a "url" field
	* specifying a URL to retrieve a source map from, but that's currently
	* unsupported.
	*
	* Here's an example source map, taken from the source map spec[0], but
	* modified to omit a section which uses the "url" field.
	*
	*  {
	*    version : 3,
	*    file: "app.js",
	*    sections: [{
	*      offset: {line:100, column:10},
	*      map: {
	*        version : 3,
	*        file: "section.js",
	*        sources: ["foo.js", "bar.js"],
	*        names: ["src", "maps", "are", "fun"],
	*        mappings: "AAAA,E;;ABCDE;"
	*      }
	*    }],
	*  }
	*
	* The second parameter, if given, is a string whose value is the URL
	* at which the source map was found.  This URL is used to compute the
	* sources array.
	*
	* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	*/
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
		var version$1 = util$1.getArg(sourceMap, "version");
		var sections = util$1.getArg(sourceMap, "sections");
		if (version$1 != this._version) throw new Error("Unsupported version: " + version$1);
		this._sources = new ArraySet();
		this._names = new ArraySet();
		var lastOffset = {
			line: -1,
			column: 0
		};
		this._sections = sections.map(function(s$1) {
			if (s$1.url) throw new Error("Support for url field in sections not implemented.");
			var offset = util$1.getArg(s$1, "offset");
			var offsetLine = util$1.getArg(offset, "line");
			var offsetColumn = util$1.getArg(offset, "column");
			if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
			lastOffset = offset;
			return {
				generatedOffset: {
					generatedLine: offsetLine + 1,
					generatedColumn: offsetColumn + 1
				},
				consumer: new SourceMapConsumer$3(util$1.getArg(s$1, "map"), aSourceMapURL)
			};
		});
	}
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$3.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$3;
	/**
	* The version of the source mapping spec that we are consuming.
	*/
	IndexedSourceMapConsumer.prototype._version = 3;
	/**
	* The list of original sources.
	*/
	Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
		var sources = [];
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) for (var j = 0; j < this._sections[i$1].consumer.sources.length; j++) sources.push(this._sections[i$1].consumer.sources[j]);
		return sources;
	} });
	/**
	* Returns the original source, line, and column information for the generated
	* source's line and column positions provided. The only argument is an object
	* with the following properties:
	*
	*   - line: The line number in the generated source.  The line number
	*     is 1-based.
	*   - column: The column number in the generated source.  The column
	*     number is 0-based.
	*
	* and an object is returned with the following properties:
	*
	*   - source: The original source file, or null.
	*   - line: The line number in the original source, or null.  The
	*     line number is 1-based.
	*   - column: The column number in the original source, or null.  The
	*     column number is 0-based.
	*   - name: The original identifier, or null.
	*/
	IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
		var needle = {
			generatedLine: util$1.getArg(aArgs, "line"),
			generatedColumn: util$1.getArg(aArgs, "column")
		};
		var sectionIndex = binarySearch.search(needle, this._sections, function(needle$1, section$1) {
			var cmp = needle$1.generatedLine - section$1.generatedOffset.generatedLine;
			if (cmp) return cmp;
			return needle$1.generatedColumn - section$1.generatedOffset.generatedColumn;
		});
		var section = this._sections[sectionIndex];
		if (!section) return {
			source: null,
			line: null,
			column: null,
			name: null
		};
		return section.consumer.originalPositionFor({
			line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
			column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
			bias: aArgs.bias
		});
	};
	/**
	* Return true if we have the source content for every source in the source
	* map, false otherwise.
	*/
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
		return this._sections.every(function(s$1) {
			return s$1.consumer.hasContentsOfAllSources();
		});
	};
	/**
	* Returns the original source content. The only argument is the url of the
	* original source file. Returns null if no original source content is
	* available.
	*/
	IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
			var section = this._sections[i$1];
			var content = section.consumer.sourceContentFor(aSource, true);
			if (content || content === "") return content;
		}
		if (nullOnMissing) return null;
else throw new Error("\"" + aSource + "\" is not in the SourceMap.");
	};
	/**
	* Returns the generated line and column information for the original source,
	* line, and column positions provided. The only argument is an object with
	* the following properties:
	*
	*   - source: The filename of the original source.
	*   - line: The line number in the original source.  The line number
	*     is 1-based.
	*   - column: The column number in the original source.  The column
	*     number is 0-based.
	*
	* and an object is returned with the following properties:
	*
	*   - line: The line number in the generated source, or null.  The
	*     line number is 1-based. 
	*   - column: The column number in the generated source, or null.
	*     The column number is 0-based.
	*/
	IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
			var section = this._sections[i$1];
			if (section.consumer._findSourceIndex(util$1.getArg(aArgs, "source")) === -1) continue;
			var generatedPosition = section.consumer.generatedPositionFor(aArgs);
			if (generatedPosition) {
				var ret = {
					line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
					column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
				};
				return ret;
			}
		}
		return {
			line: null,
			column: null
		};
	};
	/**
	* Parse the mappings in a string in to a data structure which we can easily
	* query (the ordered arrays in the `this.__generatedMappings` and
	* `this.__originalMappings` properties).
	*/
	IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		this.__generatedMappings = [];
		this.__originalMappings = [];
		for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
			var section = this._sections[i$1];
			var sectionMappings = section.consumer._generatedMappings;
			for (var j = 0; j < sectionMappings.length; j++) {
				var mapping = sectionMappings[j];
				var source = section.consumer._sources.at(mapping.source);
				if (source !== null) source = util$1.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
				this._sources.add(source);
				source = this._sources.indexOf(source);
				var name = null;
				if (mapping.name) {
					name = section.consumer._names.at(mapping.name);
					this._names.add(name);
					name = this._names.indexOf(name);
				}
				var adjustedMapping = {
					source,
					generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
					generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
					originalLine: mapping.originalLine,
					originalColumn: mapping.originalColumn,
					name
				};
				this.__generatedMappings.push(adjustedMapping);
				if (typeof adjustedMapping.originalLine === "number") this.__originalMappings.push(adjustedMapping);
			}
		}
		quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
		quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
	};
	exports$1.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
} });
var require_source_node = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-node.js"(exports$1) {
	var SourceMapGenerator$3 = require_source_map_generator().SourceMapGenerator;
	var util = require_util();
	var REGEX_NEWLINE = /(\r?\n)/;
	var NEWLINE_CODE = 10;
	var isSourceNode = "$$$isSourceNode$$$";
	/**
	* SourceNodes provide a way to abstract over interpolating/concatenating
	* snippets of generated JavaScript source code while maintaining the line and
	* column information associated with the original source code.
	*
	* @param aLine The original line number.
	* @param aColumn The original column number.
	* @param aSource The original source's filename.
	* @param aChunks Optional. An array of strings which are snippets of
	*        generated JS, or other SourceNodes.
	* @param aName The original identifier.
	*/
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
		this.children = [];
		this.sourceContents = {};
		this.line = aLine == null ? null : aLine;
		this.column = aColumn == null ? null : aColumn;
		this.source = aSource == null ? null : aSource;
		this.name = aName == null ? null : aName;
		this[isSourceNode] = true;
		if (aChunks != null) this.add(aChunks);
	}
	/**
	* Creates a SourceNode from generated code and a SourceMapConsumer.
	*
	* @param aGeneratedCode The generated code
	* @param aSourceMapConsumer The SourceMap for the generated code
	* @param aRelativePath Optional. The path that relative sources in the
	*        SourceMapConsumer should be relative to.
	*/
	SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
		var node = new SourceNode();
		var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
		var remainingLinesIndex = 0;
		var shiftNextLine = function() {
			var lineContents = getNextLine();
			var newLine = getNextLine() || "";
			return lineContents + newLine;
			function getNextLine() {
				return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
			}
		};
		var lastGeneratedLine = 1, lastGeneratedColumn = 0;
		var lastMapping = null;
		aSourceMapConsumer.eachMapping(function(mapping) {
			if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) {
				addMappingWithCode(lastMapping, shiftNextLine());
				lastGeneratedLine++;
				lastGeneratedColumn = 0;
			} else {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
				addMappingWithCode(lastMapping, code);
				lastMapping = mapping;
				return;
			}
			while (lastGeneratedLine < mapping.generatedLine) {
				node.add(shiftNextLine());
				lastGeneratedLine++;
			}
			if (lastGeneratedColumn < mapping.generatedColumn) {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				node.add(nextLine.substr(0, mapping.generatedColumn));
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
			}
			lastMapping = mapping;
		}, this);
		if (remainingLinesIndex < remainingLines.length) {
			if (lastMapping) addMappingWithCode(lastMapping, shiftNextLine());
			node.add(remainingLines.splice(remainingLinesIndex).join(""));
		}
		aSourceMapConsumer.sources.forEach(function(sourceFile) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				if (aRelativePath != null) sourceFile = util.join(aRelativePath, sourceFile);
				node.setSourceContent(sourceFile, content);
			}
		});
		return node;
		function addMappingWithCode(mapping, code) {
			if (mapping === null || mapping.source === undefined) node.add(code);
else {
				var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
				node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
			}
		}
	};
	/**
	* Add a chunk of generated JS to this source node.
	*
	* @param aChunk A string snippet of generated JS code, another instance of
	*        SourceNode, or an array where each member is one of those things.
	*/
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
		if (Array.isArray(aChunk)) aChunk.forEach(function(chunk) {
			this.add(chunk);
		}, this);
else if (aChunk[isSourceNode] || typeof aChunk === "string") {
			if (aChunk) this.children.push(aChunk);
		} else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	/**
	* Add a chunk of generated JS to the beginning of this source node.
	*
	* @param aChunk A string snippet of generated JS code, another instance of
	*        SourceNode, or an array where each member is one of those things.
	*/
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
		if (Array.isArray(aChunk)) for (var i$1 = aChunk.length - 1; i$1 >= 0; i$1--) this.prepend(aChunk[i$1]);
else if (aChunk[isSourceNode] || typeof aChunk === "string") this.children.unshift(aChunk);
else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
		return this;
	};
	/**
	* Walk over the tree of JS snippets in this node and its children. The
	* walking function is called once for each snippet of JS and is passed that
	* snippet and the its original associated source's line/column location.
	*
	* @param aFn The traversal function.
	*/
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
		var chunk;
		for (var i$1 = 0, len = this.children.length; i$1 < len; i$1++) {
			chunk = this.children[i$1];
			if (chunk[isSourceNode]) chunk.walk(aFn);
else if (chunk !== "") aFn(chunk, {
				source: this.source,
				line: this.line,
				column: this.column,
				name: this.name
			});
		}
	};
	/**
	* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	* each of `this.children`.
	*
	* @param aSep The separator.
	*/
	SourceNode.prototype.join = function SourceNode_join(aSep) {
		var newChildren;
		var i$1;
		var len = this.children.length;
		if (len > 0) {
			newChildren = [];
			for (i$1 = 0; i$1 < len - 1; i$1++) {
				newChildren.push(this.children[i$1]);
				newChildren.push(aSep);
			}
			newChildren.push(this.children[i$1]);
			this.children = newChildren;
		}
		return this;
	};
	/**
	* Call String.prototype.replace on the very right-most source snippet. Useful
	* for trimming whitespace from the end of a source node, etc.
	*
	* @param aPattern The pattern to replace.
	* @param aReplacement The thing to replace the pattern with.
	*/
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
		var lastChild = this.children[this.children.length - 1];
		if (lastChild[isSourceNode]) lastChild.replaceRight(aPattern, aReplacement);
else if (typeof lastChild === "string") this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
else this.children.push("".replace(aPattern, aReplacement));
		return this;
	};
	/**
	* Set the source content for a source file. This will be added to the SourceMapGenerator
	* in the sourcesContent field.
	*
	* @param aSourceFile The filename of the source file
	* @param aSourceContent The content of the source file
	*/
	SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
		this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	};
	/**
	* Walk over the tree of SourceNodes. The walking function is called for each
	* source file content and is passed the filename and source content.
	*
	* @param aFn The traversal function.
	*/
	SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
		for (var i$1 = 0, len = this.children.length; i$1 < len; i$1++) if (this.children[i$1][isSourceNode]) this.children[i$1].walkSourceContents(aFn);
		var sources = Object.keys(this.sourceContents);
		for (var i$1 = 0, len = sources.length; i$1 < len; i$1++) aFn(util.fromSetString(sources[i$1]), this.sourceContents[sources[i$1]]);
	};
	/**
	* Return the string representation of this source node. Walks over the tree
	* and concatenates all the various snippets together to one string.
	*/
	SourceNode.prototype.toString = function SourceNode_toString() {
		var str = "";
		this.walk(function(chunk) {
			str += chunk;
		});
		return str;
	};
	/**
	* Returns the string representation of this source node along with a source
	* map.
	*/
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
		var generated = {
			code: "",
			line: 1,
			column: 0
		};
		var map = new SourceMapGenerator$3(aArgs);
		var sourceMappingActive = false;
		var lastOriginalSource = null;
		var lastOriginalLine = null;
		var lastOriginalColumn = null;
		var lastOriginalName = null;
		this.walk(function(chunk, original) {
			generated.code += chunk;
			if (original.source !== null && original.line !== null && original.column !== null) {
				if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) map.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
				lastOriginalSource = original.source;
				lastOriginalLine = original.line;
				lastOriginalColumn = original.column;
				lastOriginalName = original.name;
				sourceMappingActive = true;
			} else if (sourceMappingActive) {
				map.addMapping({ generated: {
					line: generated.line,
					column: generated.column
				} });
				lastOriginalSource = null;
				sourceMappingActive = false;
			}
			for (var idx = 0, length = chunk.length; idx < length; idx++) if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
				generated.line++;
				generated.column = 0;
				if (idx + 1 === length) {
					lastOriginalSource = null;
					sourceMappingActive = false;
				} else if (sourceMappingActive) map.addMapping({
					source: original.source,
					original: {
						line: original.line,
						column: original.column
					},
					generated: {
						line: generated.line,
						column: generated.column
					},
					name: original.name
				});
			} else generated.column++;
		});
		this.walkSourceContents(function(sourceFile, sourceContent) {
			map.setSourceContent(sourceFile, sourceContent);
		});
		return {
			code: generated.code,
			map
		};
	};
	exports$1.SourceNode = SourceNode;
} });
var require_source_map = __commonJS({ "node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js"(exports$1) {
	exports$1.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
	exports$1.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
	exports$1.SourceNode = require_source_node().SourceNode;
} });
var require_previous_map = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/previous-map.js"(exports$1, module) {
	let { existsSync: existsSync$1, readFileSync } = __require("fs");
	let { dirname: dirname$1$1, join: join$1 } = __require("path");
	let { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$2 } = require_source_map();
	function fromBase64(str) {
		if (Buffer) return Buffer.from(str, "base64").toString();
else return window.atob(str);
	}
	var PreviousMap$2 = class {
		constructor(css, opts) {
			if (opts.map === false) return;
			this.loadAnnotation(css);
			this.inline = this.startWith(this.annotation, "data:");
			let prev = opts.map ? opts.map.prev : undefined;
			let text$1 = this.loadMap(opts.from, prev);
			if (!this.mapFile && opts.from) this.mapFile = opts.from;
			if (this.mapFile) this.root = dirname$1$1(this.mapFile);
			if (text$1) this.text = text$1;
		}
		consumer() {
			if (!this.consumerCache) this.consumerCache = new SourceMapConsumer$2(this.text);
			return this.consumerCache;
		}
		decodeInline(text$1) {
			let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
			let baseUri = /^data:application\/json;base64,/;
			let charsetUri = /^data:application\/json;charset=utf-?8,/;
			let uri = /^data:application\/json,/;
			let uriMatch = text$1.match(charsetUri) || text$1.match(uri);
			if (uriMatch) return decodeURIComponent(text$1.substr(uriMatch[0].length));
			let baseUriMatch = text$1.match(baseCharsetUri) || text$1.match(baseUri);
			if (baseUriMatch) return fromBase64(text$1.substr(baseUriMatch[0].length));
			let encoding = text$1.match(/data:application\/json;([^,]+),/)[1];
			throw new Error("Unsupported source map encoding " + encoding);
		}
		getAnnotationURL(sourceMapString) {
			return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
		}
		isMap(map) {
			if (typeof map !== "object") return false;
			return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
		}
		loadAnnotation(css) {
			let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
			if (!comments) return;
			let start = css.lastIndexOf(comments.pop());
			let end = css.indexOf("*/", start);
			if (start > -1 && end > -1) this.annotation = this.getAnnotationURL(css.substring(start, end));
		}
		loadFile(path$2) {
			this.root = dirname$1$1(path$2);
			if (existsSync$1(path$2)) {
				this.mapFile = path$2;
				return readFileSync(path$2, "utf-8").toString().trim();
			}
		}
		loadMap(file, prev) {
			if (prev === false) return false;
			if (prev) if (typeof prev === "string") return prev;
else if (typeof prev === "function") {
				let prevPath = prev(file);
				if (prevPath) {
					let map = this.loadFile(prevPath);
					if (!map) throw new Error("Unable to load previous source map: " + prevPath.toString());
					return map;
				}
			} else if (prev instanceof SourceMapConsumer$2) return SourceMapGenerator$2.fromSourceMap(prev).toString();
else if (prev instanceof SourceMapGenerator$2) return prev.toString();
else if (this.isMap(prev)) return JSON.stringify(prev);
else throw new Error("Unsupported previous source map format: " + prev.toString());
else if (this.inline) return this.decodeInline(this.annotation);
else if (this.annotation) {
				let map = this.annotation;
				if (file) map = join$1(dirname$1$1(file), map);
				return this.loadFile(map);
			}
		}
		startWith(string, start) {
			if (!string) return false;
			return string.substr(0, start.length) === start;
		}
		withContent() {
			return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
		}
	};
	module.exports = PreviousMap$2;
	PreviousMap$2.default = PreviousMap$2;
} });
var require_input = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/input.js"(exports$1, module) {
	let { nanoid } = require_non_secure();
	let { isAbsolute: isAbsolute$1, resolve: resolve$1$1 } = __require("path");
	let { SourceMapConsumer: SourceMapConsumer$1, SourceMapGenerator: SourceMapGenerator$1 } = require_source_map();
	let { fileURLToPath: fileURLToPath$1, pathToFileURL: pathToFileURL$1 } = __require("url");
	let CssSyntaxError$2 = require_css_syntax_error();
	let PreviousMap$1 = require_previous_map();
	let terminalHighlight = require_terminal_highlight();
	let fromOffsetCache = Symbol("fromOffsetCache");
	let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
	let pathAvailable$1 = Boolean(resolve$1$1 && isAbsolute$1);
	var Input$5 = class {
		get from() {
			return this.file || this.id;
		}
		constructor(css, opts = {}) {
			if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) throw new Error(`PostCSS received ${css} instead of CSS string`);
			this.css = css.toString();
			if (this.css[0] === "﻿" || this.css[0] === "￾") {
				this.hasBOM = true;
				this.css = this.css.slice(1);
			} else this.hasBOM = false;
			this.document = this.css;
			if (opts.document) this.document = opts.document.toString();
			if (opts.from) if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute$1(opts.from)) this.file = opts.from;
else this.file = resolve$1$1(opts.from);
			if (pathAvailable$1 && sourceMapAvailable$1) {
				let map = new PreviousMap$1(this.css, opts);
				if (map.text) {
					this.map = map;
					let file = map.consumer().file;
					if (!this.file && file) this.file = this.mapResolve(file);
				}
			}
			if (!this.file) this.id = "<input css " + nanoid(6) + ">";
			if (this.map) this.map.file = this.from;
		}
		error(message, line, column, opts = {}) {
			let endColumn, endLine, result;
			if (line && typeof line === "object") {
				let start = line;
				let end = column;
				if (typeof start.offset === "number") {
					let pos = this.fromOffset(start.offset);
					line = pos.line;
					column = pos.col;
				} else {
					line = start.line;
					column = start.column;
				}
				if (typeof end.offset === "number") {
					let pos = this.fromOffset(end.offset);
					endLine = pos.line;
					endColumn = pos.col;
				} else {
					endLine = end.line;
					endColumn = end.column;
				}
			} else if (!column) {
				let pos = this.fromOffset(line);
				line = pos.line;
				column = pos.col;
			}
			let origin = this.origin(line, column, endLine, endColumn);
			if (origin) result = new CssSyntaxError$2(message, origin.endLine === undefined ? origin.line : {
				column: origin.column,
				line: origin.line
			}, origin.endLine === undefined ? origin.column : {
				column: origin.endColumn,
				line: origin.endLine
			}, origin.source, origin.file, opts.plugin);
else result = new CssSyntaxError$2(message, endLine === undefined ? line : {
				column,
				line
			}, endLine === undefined ? column : {
				column: endColumn,
				line: endLine
			}, this.css, this.file, opts.plugin);
			result.input = {
				column,
				endColumn,
				endLine,
				line,
				source: this.css
			};
			if (this.file) {
				if (pathToFileURL$1) result.input.url = pathToFileURL$1(this.file).toString();
				result.input.file = this.file;
			}
			return result;
		}
		fromOffset(offset) {
			let lastLine, lineToIndex;
			if (!this[fromOffsetCache]) {
				let lines = this.css.split("\n");
				lineToIndex = new Array(lines.length);
				let prevIndex = 0;
				for (let i$1 = 0, l$1$1 = lines.length; i$1 < l$1$1; i$1++) {
					lineToIndex[i$1] = prevIndex;
					prevIndex += lines[i$1].length + 1;
				}
				this[fromOffsetCache] = lineToIndex;
			} else lineToIndex = this[fromOffsetCache];
			lastLine = lineToIndex[lineToIndex.length - 1];
			let min = 0;
			if (offset >= lastLine) min = lineToIndex.length - 1;
else {
				let max = lineToIndex.length - 2;
				let mid;
				while (min < max) {
					mid = min + (max - min >> 1);
					if (offset < lineToIndex[mid]) max = mid - 1;
else if (offset >= lineToIndex[mid + 1]) min = mid + 1;
else {
						min = mid;
						break;
					}
				}
			}
			return {
				col: offset - lineToIndex[min] + 1,
				line: min + 1
			};
		}
		mapResolve(file) {
			if (/^\w+:\/\//.test(file)) return file;
			return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
		}
		origin(line, column, endLine, endColumn) {
			if (!this.map) return false;
			let consumer = this.map.consumer();
			let from$1 = consumer.originalPositionFor({
				column,
				line
			});
			if (!from$1.source) return false;
			let to;
			if (typeof endLine === "number") to = consumer.originalPositionFor({
				column: endColumn,
				line: endLine
			});
			let fromUrl;
			if (isAbsolute$1(from$1.source)) fromUrl = pathToFileURL$1(from$1.source);
else fromUrl = new URL(from$1.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));
			let result = {
				column: from$1.column,
				endColumn: to && to.column,
				endLine: to && to.line,
				line: from$1.line,
				url: fromUrl.toString()
			};
			if (fromUrl.protocol === "file:") if (fileURLToPath$1) result.file = fileURLToPath$1(fromUrl);
else throw new Error(`file: protocol is not available in this PostCSS build`);
			let source = consumer.sourceContentFor(from$1.source);
			if (source) result.source = source;
			return result;
		}
		toJSON() {
			let json = {};
			for (let name of [
				"hasBOM",
				"css",
				"file",
				"id"
			]) if (this[name] != null) json[name] = this[name];
			if (this.map) {
				json.map = { ...this.map };
				if (json.map.consumerCache) json.map.consumerCache = undefined;
			}
			return json;
		}
	};
	module.exports = Input$5;
	Input$5.default = Input$5;
	if (terminalHighlight && terminalHighlight.registerInput) terminalHighlight.registerInput(Input$5);
} });
var require_root = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/root.js"(exports$1, module) {
	let Container$5 = require_container();
	let LazyResult$3, Processor$3;
	var Root$6 = class extends Container$5 {
		constructor(defaults) {
			super(defaults);
			this.type = "root";
			if (!this.nodes) this.nodes = [];
		}
		normalize(child, sample, type) {
			let nodes = super.normalize(child);
			if (sample) {
				if (type === "prepend") if (this.nodes.length > 1) sample.raws.before = this.nodes[1].raws.before;
else delete sample.raws.before;
else if (this.first !== sample) for (let node of nodes) node.raws.before = sample.raws.before;
			}
			return nodes;
		}
		removeChild(child, ignore) {
			let index = this.index(child);
			if (!ignore && index === 0 && this.nodes.length > 1) this.nodes[1].raws.before = this.nodes[index].raws.before;
			return super.removeChild(child);
		}
		toResult(opts = {}) {
			let lazy = new LazyResult$3(new Processor$3(), this, opts);
			return lazy.stringify();
		}
	};
	Root$6.registerLazyResult = (dependant) => {
		LazyResult$3 = dependant;
	};
	Root$6.registerProcessor = (dependant) => {
		Processor$3 = dependant;
	};
	module.exports = Root$6;
	Root$6.default = Root$6;
	Container$5.registerRoot(Root$6);
} });
var require_list = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/list.js"(exports$1, module) {
	let list$4 = {
		comma(string) {
			return list$4.split(string, [","], true);
		},
		space(string) {
			let spaces = [
				" ",
				"\n",
				"	"
			];
			return list$4.split(string, spaces);
		},
		split(string, separators, last) {
			let array = [];
			let current = "";
			let split = false;
			let func = 0;
			let inQuote = false;
			let prevQuote = "";
			let escape$1 = false;
			for (let letter of string) {
				if (escape$1) escape$1 = false;
else if (letter === "\\") escape$1 = true;
else if (inQuote) {
					if (letter === prevQuote) inQuote = false;
				} else if (letter === "\"" || letter === "'") {
					inQuote = true;
					prevQuote = letter;
				} else if (letter === "(") func += 1;
else if (letter === ")") {
					if (func > 0) func -= 1;
				} else if (func === 0) {
					if (separators.includes(letter)) split = true;
				}
				if (split) {
					if (current !== "") array.push(current.trim());
					current = "";
					split = false;
				} else current += letter;
			}
			if (last || current !== "") array.push(current.trim());
			return array;
		}
	};
	module.exports = list$4;
	list$4.default = list$4;
} });
var require_rule = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/rule.js"(exports$1, module) {
	let Container$4 = require_container();
	let list$3 = require_list();
	var Rule$4 = class extends Container$4 {
		get selectors() {
			return list$3.comma(this.selector);
		}
		set selectors(values) {
			let match = this.selector ? this.selector.match(/,\s*/) : null;
			let sep$1 = match ? match[0] : "," + this.raw("between", "beforeOpen");
			this.selector = values.join(sep$1);
		}
		constructor(defaults) {
			super(defaults);
			this.type = "rule";
			if (!this.nodes) this.nodes = [];
		}
	};
	module.exports = Rule$4;
	Rule$4.default = Rule$4;
	Container$4.registerRule(Rule$4);
} });
var require_fromJSON = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/fromJSON.js"(exports$1, module) {
	let AtRule$3 = require_at_rule();
	let Comment$3 = require_comment();
	let Declaration$3 = require_declaration();
	let Input$4 = require_input();
	let PreviousMap = require_previous_map();
	let Root$5 = require_root();
	let Rule$3 = require_rule();
	function fromJSON$2(json, inputs) {
		if (Array.isArray(json)) return json.map((n$1) => fromJSON$2(n$1));
		let { inputs: ownInputs,...defaults } = json;
		if (ownInputs) {
			inputs = [];
			for (let input of ownInputs) {
				let inputHydrated = {
					...input,
					__proto__: Input$4.prototype
				};
				if (inputHydrated.map) inputHydrated.map = {
					...inputHydrated.map,
					__proto__: PreviousMap.prototype
				};
				inputs.push(inputHydrated);
			}
		}
		if (defaults.nodes) defaults.nodes = json.nodes.map((n$1) => fromJSON$2(n$1, inputs));
		if (defaults.source) {
			let { inputId,...source } = defaults.source;
			defaults.source = source;
			if (inputId != null) defaults.source.input = inputs[inputId];
		}
		if (defaults.type === "root") return new Root$5(defaults);
else if (defaults.type === "decl") return new Declaration$3(defaults);
else if (defaults.type === "rule") return new Rule$3(defaults);
else if (defaults.type === "comment") return new Comment$3(defaults);
else if (defaults.type === "atrule") return new AtRule$3(defaults);
else throw new Error("Unknown node type: " + json.type);
	}
	module.exports = fromJSON$2;
	fromJSON$2.default = fromJSON$2;
} });
var require_map_generator = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/map-generator.js"(exports$1, module) {
	let { dirname: dirname$2, relative, resolve: resolve$2, sep } = __require("path");
	let { SourceMapConsumer, SourceMapGenerator } = require_source_map();
	let { pathToFileURL } = __require("url");
	let Input$3 = require_input();
	let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	let pathAvailable = Boolean(dirname$2 && resolve$2 && relative && sep);
	var MapGenerator$2 = class {
		constructor(stringify$6, root$1, opts, cssString) {
			this.stringify = stringify$6;
			this.mapOpts = opts.map || {};
			this.root = root$1;
			this.opts = opts;
			this.css = cssString;
			this.originalCSS = cssString;
			this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
			this.memoizedFileURLs = new Map();
			this.memoizedPaths = new Map();
			this.memoizedURLs = new Map();
		}
		addAnnotation() {
			let content;
			if (this.isInline()) content = "data:application/json;base64," + this.toBase64(this.map.toString());
else if (typeof this.mapOpts.annotation === "string") content = this.mapOpts.annotation;
else if (typeof this.mapOpts.annotation === "function") content = this.mapOpts.annotation(this.opts.to, this.root);
else content = this.outputFile() + ".map";
			let eol = "\n";
			if (this.css.includes("\r\n")) eol = "\r\n";
			this.css += eol + "/*# sourceMappingURL=" + content + " */";
		}
		applyPrevMaps() {
			for (let prev of this.previous()) {
				let from$1 = this.toUrl(this.path(prev.file));
				let root$1 = prev.root || dirname$2(prev.file);
				let map;
				if (this.mapOpts.sourcesContent === false) {
					map = new SourceMapConsumer(prev.text);
					if (map.sourcesContent) map.sourcesContent = null;
				} else map = prev.consumer();
				this.map.applySourceMap(map, from$1, this.toUrl(this.path(root$1)));
			}
		}
		clearAnnotation() {
			if (this.mapOpts.annotation === false) return;
			if (this.root) {
				let node;
				for (let i$1 = this.root.nodes.length - 1; i$1 >= 0; i$1--) {
					node = this.root.nodes[i$1];
					if (node.type !== "comment") continue;
					if (node.text.startsWith("# sourceMappingURL=")) this.root.removeChild(i$1);
				}
			} else if (this.css) this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
		}
		generate() {
			this.clearAnnotation();
			if (pathAvailable && sourceMapAvailable && this.isMap()) return this.generateMap();
else {
				let result = "";
				this.stringify(this.root, (i$1) => {
					result += i$1;
				});
				return [result];
			}
		}
		generateMap() {
			if (this.root) this.generateString();
else if (this.previous().length === 1) {
				let prev = this.previous()[0].consumer();
				prev.file = this.outputFile();
				this.map = SourceMapGenerator.fromSourceMap(prev, { ignoreInvalidMapping: true });
			} else {
				this.map = new SourceMapGenerator({
					file: this.outputFile(),
					ignoreInvalidMapping: true
				});
				this.map.addMapping({
					generated: {
						column: 0,
						line: 1
					},
					original: {
						column: 0,
						line: 1
					},
					source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
				});
			}
			if (this.isSourcesContent()) this.setSourcesContent();
			if (this.root && this.previous().length > 0) this.applyPrevMaps();
			if (this.isAnnotation()) this.addAnnotation();
			if (this.isInline()) return [this.css];
else return [this.css, this.map];
		}
		generateString() {
			this.css = "";
			this.map = new SourceMapGenerator({
				file: this.outputFile(),
				ignoreInvalidMapping: true
			});
			let line = 1;
			let column = 1;
			let noSource = "<no source>";
			let mapping = {
				generated: {
					column: 0,
					line: 0
				},
				original: {
					column: 0,
					line: 0
				},
				source: ""
			};
			let last, lines;
			this.stringify(this.root, (str, node, type) => {
				this.css += str;
				if (node && type !== "end") {
					mapping.generated.line = line;
					mapping.generated.column = column - 1;
					if (node.source && node.source.start) {
						mapping.source = this.sourcePath(node);
						mapping.original.line = node.source.start.line;
						mapping.original.column = node.source.start.column - 1;
						this.map.addMapping(mapping);
					} else {
						mapping.source = noSource;
						mapping.original.line = 1;
						mapping.original.column = 0;
						this.map.addMapping(mapping);
					}
				}
				lines = str.match(/\n/g);
				if (lines) {
					line += lines.length;
					last = str.lastIndexOf("\n");
					column = str.length - last;
				} else column += str.length;
				if (node && type !== "start") {
					let p$1 = node.parent || { raws: {} };
					let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
					if (!childless || node !== p$1.last || p$1.raws.semicolon) if (node.source && node.source.end) {
						mapping.source = this.sourcePath(node);
						mapping.original.line = node.source.end.line;
						mapping.original.column = node.source.end.column - 1;
						mapping.generated.line = line;
						mapping.generated.column = column - 2;
						this.map.addMapping(mapping);
					} else {
						mapping.source = noSource;
						mapping.original.line = 1;
						mapping.original.column = 0;
						mapping.generated.line = line;
						mapping.generated.column = column - 1;
						this.map.addMapping(mapping);
					}
				}
			});
		}
		isAnnotation() {
			if (this.isInline()) return true;
			if (typeof this.mapOpts.annotation !== "undefined") return this.mapOpts.annotation;
			if (this.previous().length) return this.previous().some((i$1) => i$1.annotation);
			return true;
		}
		isInline() {
			if (typeof this.mapOpts.inline !== "undefined") return this.mapOpts.inline;
			let annotation = this.mapOpts.annotation;
			if (typeof annotation !== "undefined" && annotation !== true) return false;
			if (this.previous().length) return this.previous().some((i$1) => i$1.inline);
			return true;
		}
		isMap() {
			if (typeof this.opts.map !== "undefined") return !!this.opts.map;
			return this.previous().length > 0;
		}
		isSourcesContent() {
			if (typeof this.mapOpts.sourcesContent !== "undefined") return this.mapOpts.sourcesContent;
			if (this.previous().length) return this.previous().some((i$1) => i$1.withContent());
			return true;
		}
		outputFile() {
			if (this.opts.to) return this.path(this.opts.to);
else if (this.opts.from) return this.path(this.opts.from);
else return "to.css";
		}
		path(file) {
			if (this.mapOpts.absolute) return file;
			if (file.charCodeAt(0) === 60) return file;
			if (/^\w+:\/\//.test(file)) return file;
			let cached = this.memoizedPaths.get(file);
			if (cached) return cached;
			let from$1 = this.opts.to ? dirname$2(this.opts.to) : ".";
			if (typeof this.mapOpts.annotation === "string") from$1 = dirname$2(resolve$2(from$1, this.mapOpts.annotation));
			let path$2 = relative(from$1, file);
			this.memoizedPaths.set(file, path$2);
			return path$2;
		}
		previous() {
			if (!this.previousMaps) {
				this.previousMaps = [];
				if (this.root) this.root.walk((node) => {
					if (node.source && node.source.input.map) {
						let map = node.source.input.map;
						if (!this.previousMaps.includes(map)) this.previousMaps.push(map);
					}
				});
else {
					let input = new Input$3(this.originalCSS, this.opts);
					if (input.map) this.previousMaps.push(input.map);
				}
			}
			return this.previousMaps;
		}
		setSourcesContent() {
			let already = {};
			if (this.root) this.root.walk((node) => {
				if (node.source) {
					let from$1 = node.source.input.from;
					if (from$1 && !already[from$1]) {
						already[from$1] = true;
						let fromUrl = this.usesFileUrls ? this.toFileUrl(from$1) : this.toUrl(this.path(from$1));
						this.map.setSourceContent(fromUrl, node.source.input.css);
					}
				}
			});
else if (this.css) {
				let from$1 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
				this.map.setSourceContent(from$1, this.css);
			}
		}
		sourcePath(node) {
			if (this.mapOpts.from) return this.toUrl(this.mapOpts.from);
else if (this.usesFileUrls) return this.toFileUrl(node.source.input.from);
else return this.toUrl(this.path(node.source.input.from));
		}
		toBase64(str) {
			if (Buffer) return Buffer.from(str).toString("base64");
else return window.btoa(unescape(encodeURIComponent(str)));
		}
		toFileUrl(path$2) {
			let cached = this.memoizedFileURLs.get(path$2);
			if (cached) return cached;
			if (pathToFileURL) {
				let fileURL = pathToFileURL(path$2).toString();
				this.memoizedFileURLs.set(path$2, fileURL);
				return fileURL;
			} else throw new Error("`map.absolute` option is not available in this PostCSS build");
		}
		toUrl(path$2) {
			let cached = this.memoizedURLs.get(path$2);
			if (cached) return cached;
			if (sep === "\\") path$2 = path$2.replace(/\\/g, "/");
			let url = encodeURI(path$2).replace(/[#?]/g, encodeURIComponent);
			this.memoizedURLs.set(path$2, url);
			return url;
		}
	};
	module.exports = MapGenerator$2;
} });
var require_parser = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/parser.js"(exports$1, module) {
	let AtRule$2 = require_at_rule();
	let Comment$2 = require_comment();
	let Declaration$2 = require_declaration();
	let Root$4 = require_root();
	let Rule$2 = require_rule();
	let tokenizer$1 = require_tokenize();
	const SAFE_COMMENT_NEIGHBOR = {
		empty: true,
		space: true
	};
	function findLastWithPosition(tokens) {
		for (let i$1 = tokens.length - 1; i$1 >= 0; i$1--) {
			let token = tokens[i$1];
			let pos = token[3] || token[2];
			if (pos) return pos;
		}
	}
	var Parser$2 = class {
		constructor(input) {
			this.input = input;
			this.root = new Root$4();
			this.current = this.root;
			this.spaces = "";
			this.semicolon = false;
			this.createTokenizer();
			this.root.source = {
				input,
				start: {
					column: 1,
					line: 1,
					offset: 0
				}
			};
		}
		atrule(token) {
			let node = new AtRule$2();
			node.name = token[1].slice(1);
			if (node.name === "") this.unnamedAtrule(node, token);
			this.init(node, token[2]);
			let type;
			let prev;
			let shift;
			let last = false;
			let open = false;
			let params = [];
			let brackets = [];
			while (!this.tokenizer.endOfFile()) {
				token = this.tokenizer.nextToken();
				type = token[0];
				if (type === "(" || type === "[") brackets.push(type === "(" ? ")" : "]");
else if (type === "{" && brackets.length > 0) brackets.push("}");
else if (type === brackets[brackets.length - 1]) brackets.pop();
				if (brackets.length === 0) if (type === ";") {
					node.source.end = this.getPosition(token[2]);
					node.source.end.offset++;
					this.semicolon = true;
					break;
				} else if (type === "{") {
					open = true;
					break;
				} else if (type === "}") {
					if (params.length > 0) {
						shift = params.length - 1;
						prev = params[shift];
						while (prev && prev[0] === "space") prev = params[--shift];
						if (prev) {
							node.source.end = this.getPosition(prev[3] || prev[2]);
							node.source.end.offset++;
						}
					}
					this.end(token);
					break;
				} else params.push(token);
else params.push(token);
				if (this.tokenizer.endOfFile()) {
					last = true;
					break;
				}
			}
			node.raws.between = this.spacesAndCommentsFromEnd(params);
			if (params.length) {
				node.raws.afterName = this.spacesAndCommentsFromStart(params);
				this.raw(node, "params", params);
				if (last) {
					token = params[params.length - 1];
					node.source.end = this.getPosition(token[3] || token[2]);
					node.source.end.offset++;
					this.spaces = node.raws.between;
					node.raws.between = "";
				}
			} else {
				node.raws.afterName = "";
				node.params = "";
			}
			if (open) {
				node.nodes = [];
				this.current = node;
			}
		}
		checkMissedSemicolon(tokens) {
			let colon = this.colon(tokens);
			if (colon === false) return;
			let founded = 0;
			let token;
			for (let j = colon - 1; j >= 0; j--) {
				token = tokens[j];
				if (token[0] !== "space") {
					founded += 1;
					if (founded === 2) break;
				}
			}
			throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
		}
		colon(tokens) {
			let brackets = 0;
			let prev, token, type;
			for (let [i$1, element] of tokens.entries()) {
				token = element;
				type = token[0];
				if (type === "(") brackets += 1;
				if (type === ")") brackets -= 1;
				if (brackets === 0 && type === ":") if (!prev) this.doubleColon(token);
else if (prev[0] === "word" && prev[1] === "progid") continue;
else return i$1;
				prev = token;
			}
			return false;
		}
		comment(token) {
			let node = new Comment$2();
			this.init(node, token[2]);
			node.source.end = this.getPosition(token[3] || token[2]);
			node.source.end.offset++;
			let text$1 = token[1].slice(2, -2);
			if (/^\s*$/.test(text$1)) {
				node.text = "";
				node.raws.left = text$1;
				node.raws.right = "";
			} else {
				let match = text$1.match(/^(\s*)([^]*\S)(\s*)$/);
				node.text = match[2];
				node.raws.left = match[1];
				node.raws.right = match[3];
			}
		}
		createTokenizer() {
			this.tokenizer = tokenizer$1(this.input);
		}
		decl(tokens, customProperty) {
			let node = new Declaration$2();
			this.init(node, tokens[0][2]);
			let last = tokens[tokens.length - 1];
			if (last[0] === ";") {
				this.semicolon = true;
				tokens.pop();
			}
			node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
			node.source.end.offset++;
			while (tokens[0][0] !== "word") {
				if (tokens.length === 1) this.unknownWord(tokens);
				node.raws.before += tokens.shift()[1];
			}
			node.source.start = this.getPosition(tokens[0][2]);
			node.prop = "";
			while (tokens.length) {
				let type = tokens[0][0];
				if (type === ":" || type === "space" || type === "comment") break;
				node.prop += tokens.shift()[1];
			}
			node.raws.between = "";
			let token;
			while (tokens.length) {
				token = tokens.shift();
				if (token[0] === ":") {
					node.raws.between += token[1];
					break;
				} else {
					if (token[0] === "word" && /\w/.test(token[1])) this.unknownWord([token]);
					node.raws.between += token[1];
				}
			}
			if (node.prop[0] === "_" || node.prop[0] === "*") {
				node.raws.before += node.prop[0];
				node.prop = node.prop.slice(1);
			}
			let firstSpaces = [];
			let next;
			while (tokens.length) {
				next = tokens[0][0];
				if (next !== "space" && next !== "comment") break;
				firstSpaces.push(tokens.shift());
			}
			this.precheckMissedSemicolon(tokens);
			for (let i$1 = tokens.length - 1; i$1 >= 0; i$1--) {
				token = tokens[i$1];
				if (token[1].toLowerCase() === "!important") {
					node.important = true;
					let string = this.stringFrom(tokens, i$1);
					string = this.spacesFromEnd(tokens) + string;
					if (string !== " !important") node.raws.important = string;
					break;
				} else if (token[1].toLowerCase() === "important") {
					let cache = tokens.slice(0);
					let str = "";
					for (let j = i$1; j > 0; j--) {
						let type = cache[j][0];
						if (str.trim().startsWith("!") && type !== "space") break;
						str = cache.pop()[1] + str;
					}
					if (str.trim().startsWith("!")) {
						node.important = true;
						node.raws.important = str;
						tokens = cache;
					}
				}
				if (token[0] !== "space" && token[0] !== "comment") break;
			}
			let hasWord = tokens.some((i$1) => i$1[0] !== "space" && i$1[0] !== "comment");
			if (hasWord) {
				node.raws.between += firstSpaces.map((i$1) => i$1[1]).join("");
				firstSpaces = [];
			}
			this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
			if (node.value.includes(":") && !customProperty) this.checkMissedSemicolon(tokens);
		}
		doubleColon(token) {
			throw this.input.error("Double colon", { offset: token[2] }, { offset: token[2] + token[1].length });
		}
		emptyRule(token) {
			let node = new Rule$2();
			this.init(node, token[2]);
			node.selector = "";
			node.raws.between = "";
			this.current = node;
		}
		end(token) {
			if (this.current.nodes && this.current.nodes.length) this.current.raws.semicolon = this.semicolon;
			this.semicolon = false;
			this.current.raws.after = (this.current.raws.after || "") + this.spaces;
			this.spaces = "";
			if (this.current.parent) {
				this.current.source.end = this.getPosition(token[2]);
				this.current.source.end.offset++;
				this.current = this.current.parent;
			} else this.unexpectedClose(token);
		}
		endFile() {
			if (this.current.parent) this.unclosedBlock();
			if (this.current.nodes && this.current.nodes.length) this.current.raws.semicolon = this.semicolon;
			this.current.raws.after = (this.current.raws.after || "") + this.spaces;
			this.root.source.end = this.getPosition(this.tokenizer.position());
		}
		freeSemicolon(token) {
			this.spaces += token[1];
			if (this.current.nodes) {
				let prev = this.current.nodes[this.current.nodes.length - 1];
				if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
					prev.raws.ownSemicolon = this.spaces;
					this.spaces = "";
					prev.source.end = this.getPosition(token[2]);
					prev.source.end.offset += prev.raws.ownSemicolon.length;
				}
			}
		}
		getPosition(offset) {
			let pos = this.input.fromOffset(offset);
			return {
				column: pos.col,
				line: pos.line,
				offset
			};
		}
		init(node, offset) {
			this.current.push(node);
			node.source = {
				input: this.input,
				start: this.getPosition(offset)
			};
			node.raws.before = this.spaces;
			this.spaces = "";
			if (node.type !== "comment") this.semicolon = false;
		}
		other(start) {
			let end = false;
			let type = null;
			let colon = false;
			let bracket = null;
			let brackets = [];
			let customProperty = start[1].startsWith("--");
			let tokens = [];
			let token = start;
			while (token) {
				type = token[0];
				tokens.push(token);
				if (type === "(" || type === "[") {
					if (!bracket) bracket = token;
					brackets.push(type === "(" ? ")" : "]");
				} else if (customProperty && colon && type === "{") {
					if (!bracket) bracket = token;
					brackets.push("}");
				} else if (brackets.length === 0) {
					if (type === ";") if (colon) {
						this.decl(tokens, customProperty);
						return;
					} else break;
else if (type === "{") {
						this.rule(tokens);
						return;
					} else if (type === "}") {
						this.tokenizer.back(tokens.pop());
						end = true;
						break;
					} else if (type === ":") colon = true;
				} else if (type === brackets[brackets.length - 1]) {
					brackets.pop();
					if (brackets.length === 0) bracket = null;
				}
				token = this.tokenizer.nextToken();
			}
			if (this.tokenizer.endOfFile()) end = true;
			if (brackets.length > 0) this.unclosedBracket(bracket);
			if (end && colon) {
				if (!customProperty) while (tokens.length) {
					token = tokens[tokens.length - 1][0];
					if (token !== "space" && token !== "comment") break;
					this.tokenizer.back(tokens.pop());
				}
				this.decl(tokens, customProperty);
			} else this.unknownWord(tokens);
		}
		parse() {
			let token;
			while (!this.tokenizer.endOfFile()) {
				token = this.tokenizer.nextToken();
				switch (token[0]) {
					case "space":
						this.spaces += token[1];
						break;
					case ";":
						this.freeSemicolon(token);
						break;
					case "}":
						this.end(token);
						break;
					case "comment":
						this.comment(token);
						break;
					case "at-word":
						this.atrule(token);
						break;
					case "{":
						this.emptyRule(token);
						break;
					default:
						this.other(token);
						break;
				}
			}
			this.endFile();
		}
		precheckMissedSemicolon() {}
		raw(node, prop, tokens, customProperty) {
			let token, type;
			let length = tokens.length;
			let value = "";
			let clean = true;
			let next, prev;
			for (let i$1 = 0; i$1 < length; i$1 += 1) {
				token = tokens[i$1];
				type = token[0];
				if (type === "space" && i$1 === length - 1 && !customProperty) clean = false;
else if (type === "comment") {
					prev = tokens[i$1 - 1] ? tokens[i$1 - 1][0] : "empty";
					next = tokens[i$1 + 1] ? tokens[i$1 + 1][0] : "empty";
					if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) if (value.slice(-1) === ",") clean = false;
else value += token[1];
else clean = false;
				} else value += token[1];
			}
			if (!clean) {
				let raw = tokens.reduce((all, i$1) => all + i$1[1], "");
				node.raws[prop] = {
					raw,
					value
				};
			}
			node[prop] = value;
		}
		rule(tokens) {
			tokens.pop();
			let node = new Rule$2();
			this.init(node, tokens[0][2]);
			node.raws.between = this.spacesAndCommentsFromEnd(tokens);
			this.raw(node, "selector", tokens);
			this.current = node;
		}
		spacesAndCommentsFromEnd(tokens) {
			let lastTokenType;
			let spaces = "";
			while (tokens.length) {
				lastTokenType = tokens[tokens.length - 1][0];
				if (lastTokenType !== "space" && lastTokenType !== "comment") break;
				spaces = tokens.pop()[1] + spaces;
			}
			return spaces;
		}
		spacesAndCommentsFromStart(tokens) {
			let next;
			let spaces = "";
			while (tokens.length) {
				next = tokens[0][0];
				if (next !== "space" && next !== "comment") break;
				spaces += tokens.shift()[1];
			}
			return spaces;
		}
		spacesFromEnd(tokens) {
			let lastTokenType;
			let spaces = "";
			while (tokens.length) {
				lastTokenType = tokens[tokens.length - 1][0];
				if (lastTokenType !== "space") break;
				spaces = tokens.pop()[1] + spaces;
			}
			return spaces;
		}
		stringFrom(tokens, from$1) {
			let result = "";
			for (let i$1 = from$1; i$1 < tokens.length; i$1++) result += tokens[i$1][1];
			tokens.splice(from$1, tokens.length - from$1);
			return result;
		}
		unclosedBlock() {
			let pos = this.current.source.start;
			throw this.input.error("Unclosed block", pos.line, pos.column);
		}
		unclosedBracket(bracket) {
			throw this.input.error("Unclosed bracket", { offset: bracket[2] }, { offset: bracket[2] + 1 });
		}
		unexpectedClose(token) {
			throw this.input.error("Unexpected }", { offset: token[2] }, { offset: token[2] + 1 });
		}
		unknownWord(tokens) {
			throw this.input.error("Unknown word " + tokens[0][1], { offset: tokens[0][2] }, { offset: tokens[0][2] + tokens[0][1].length });
		}
		unnamedAtrule(node, token) {
			throw this.input.error("At-rule without name", { offset: token[2] }, { offset: token[2] + token[1].length });
		}
	};
	module.exports = Parser$2;
} });
var require_parse = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/parse.js"(exports$1, module) {
	let Container$3 = require_container();
	let Input$2 = require_input();
	let Parser$1 = require_parser();
	function parse$5(css, opts) {
		let input = new Input$2(css, opts);
		let parser = new Parser$1(input);
		try {
			parser.parse();
		} catch (e) {
			if (process.env.NODE_ENV !== "production") {
				if (e.name === "CssSyntaxError" && opts && opts.from) {
					if (/\.scss$/i.test(opts.from)) e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
else if (/\.sass/i.test(opts.from)) e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
else if (/\.less$/i.test(opts.from)) e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
				}
			}
			throw e;
		}
		return parser.root;
	}
	module.exports = parse$5;
	parse$5.default = parse$5;
	Container$3.registerParse(parse$5);
} });
var require_warning = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/warning.js"(exports$1, module) {
	var Warning$3 = class {
		constructor(text$1, opts = {}) {
			this.type = "warning";
			this.text = text$1;
			if (opts.node && opts.node.source) {
				let range = opts.node.rangeBy(opts);
				this.line = range.start.line;
				this.column = range.start.column;
				this.endLine = range.end.line;
				this.endColumn = range.end.column;
			}
			for (let opt in opts) this[opt] = opts[opt];
		}
		toString() {
			if (this.node) return this.node.error(this.text, {
				index: this.index,
				plugin: this.plugin,
				word: this.word
			}).message;
			if (this.plugin) return this.plugin + ": " + this.text;
			return this.text;
		}
	};
	module.exports = Warning$3;
	Warning$3.default = Warning$3;
} });
var require_result = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/result.js"(exports$1, module) {
	let Warning$2 = require_warning();
	var Result$4 = class {
		get content() {
			return this.css;
		}
		constructor(processor, root$1, opts) {
			this.processor = processor;
			this.messages = [];
			this.root = root$1;
			this.opts = opts;
			this.css = undefined;
			this.map = undefined;
		}
		toString() {
			return this.css;
		}
		warn(text$1, opts = {}) {
			if (!opts.plugin) {
				if (this.lastPlugin && this.lastPlugin.postcssPlugin) opts.plugin = this.lastPlugin.postcssPlugin;
			}
			let warning = new Warning$2(text$1, opts);
			this.messages.push(warning);
			return warning;
		}
		warnings() {
			return this.messages.filter((i$1) => i$1.type === "warning");
		}
	};
	module.exports = Result$4;
	Result$4.default = Result$4;
} });
var require_warn_once = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/warn-once.js"(exports$1, module) {
	let printed = {};
	module.exports = function warnOnce$2(message) {
		if (printed[message]) return;
		printed[message] = true;
		if (typeof console !== "undefined" && console.warn) console.warn(message);
	};
} });
var require_lazy_result = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/lazy-result.js"(exports$1, module) {
	let Container$2 = require_container();
	let Document$3 = require_document();
	let MapGenerator$1 = require_map_generator();
	let parse$4 = require_parse();
	let Result$3 = require_result();
	let Root$3 = require_root();
	let stringify$3 = require_stringify();
	let { isClean, my } = require_symbols();
	let warnOnce$1 = require_warn_once();
	const TYPE_TO_CLASS_NAME = {
		atrule: "AtRule",
		comment: "Comment",
		decl: "Declaration",
		document: "Document",
		root: "Root",
		rule: "Rule"
	};
	const PLUGIN_PROPS = {
		AtRule: true,
		AtRuleExit: true,
		Comment: true,
		CommentExit: true,
		Declaration: true,
		DeclarationExit: true,
		Document: true,
		DocumentExit: true,
		Once: true,
		OnceExit: true,
		postcssPlugin: true,
		prepare: true,
		Root: true,
		RootExit: true,
		Rule: true,
		RuleExit: true
	};
	const NOT_VISITORS = {
		Once: true,
		postcssPlugin: true,
		prepare: true
	};
	const CHILDREN = 0;
	function isPromise(obj) {
		return typeof obj === "object" && typeof obj.then === "function";
	}
	function getEvents(node) {
		let key = false;
		let type = TYPE_TO_CLASS_NAME[node.type];
		if (node.type === "decl") key = node.prop.toLowerCase();
else if (node.type === "atrule") key = node.name.toLowerCase();
		if (key && node.append) return [
			type,
			type + "-" + key,
			CHILDREN,
			type + "Exit",
			type + "Exit-" + key
		];
else if (key) return [
			type,
			type + "-" + key,
			type + "Exit",
			type + "Exit-" + key
		];
else if (node.append) return [
			type,
			CHILDREN,
			type + "Exit"
		];
else return [type, type + "Exit"];
	}
	function toStack(node) {
		let events;
		if (node.type === "document") events = [
			"Document",
			CHILDREN,
			"DocumentExit"
		];
else if (node.type === "root") events = [
			"Root",
			CHILDREN,
			"RootExit"
		];
else events = getEvents(node);
		return {
			eventIndex: 0,
			events,
			iterator: 0,
			node,
			visitorIndex: 0,
			visitors: []
		};
	}
	function cleanMarks(node) {
		node[isClean] = false;
		if (node.nodes) node.nodes.forEach((i$1) => cleanMarks(i$1));
		return node;
	}
	let postcss$2 = {};
	var LazyResult$2 = class LazyResult$2$1 {
		get content() {
			return this.stringify().content;
		}
		get css() {
			return this.stringify().css;
		}
		get map() {
			return this.stringify().map;
		}
		get messages() {
			return this.sync().messages;
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			return this.sync().root;
		}
		get [Symbol.toStringTag]() {
			return "LazyResult";
		}
		constructor(processor, css, opts) {
			this.stringified = false;
			this.processed = false;
			let root$1;
			if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) root$1 = cleanMarks(css);
else if (css instanceof LazyResult$2$1 || css instanceof Result$3) {
				root$1 = cleanMarks(css.root);
				if (css.map) {
					if (typeof opts.map === "undefined") opts.map = {};
					if (!opts.map.inline) opts.map.inline = false;
					opts.map.prev = css.map;
				}
			} else {
				let parser = parse$4;
				if (opts.syntax) parser = opts.syntax.parse;
				if (opts.parser) parser = opts.parser;
				if (parser.parse) parser = parser.parse;
				try {
					root$1 = parser(css, opts);
				} catch (error) {
					this.processed = true;
					this.error = error;
				}
				if (root$1 && !root$1[my]) Container$2.rebuild(root$1);
			}
			this.result = new Result$3(processor, root$1, opts);
			this.helpers = {
				...postcss$2,
				postcss: postcss$2,
				result: this.result
			};
			this.plugins = this.processor.plugins.map((plugin$1) => {
				if (typeof plugin$1 === "object" && plugin$1.prepare) return {
					...plugin$1,
					...plugin$1.prepare(this.result)
				};
else return plugin$1;
			});
		}
		async() {
			if (this.error) return Promise.reject(this.error);
			if (this.processed) return Promise.resolve(this.result);
			if (!this.processing) this.processing = this.runAsync();
			return this.processing;
		}
		catch(onRejected) {
			return this.async().catch(onRejected);
		}
		finally(onFinally) {
			return this.async().then(onFinally, onFinally);
		}
		getAsyncError() {
			throw new Error("Use process(css).then(cb) to work with async plugins");
		}
		handleError(error, node) {
			let plugin$1 = this.result.lastPlugin;
			try {
				if (node) node.addToError(error);
				this.error = error;
				if (error.name === "CssSyntaxError" && !error.plugin) {
					error.plugin = plugin$1.postcssPlugin;
					error.setMessage();
				} else if (plugin$1.postcssVersion) {
					if (process.env.NODE_ENV !== "production") {
						let pluginName = plugin$1.postcssPlugin;
						let pluginVer = plugin$1.postcssVersion;
						let runtimeVer = this.result.processor.version;
						let a = pluginVer.split(".");
						let b = runtimeVer.split(".");
						if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
					}
				}
			} catch (err) {
				if (console && console.error) console.error(err);
			}
			return error;
		}
		prepareVisitors() {
			this.listeners = {};
			let add = (plugin$1, type, cb) => {
				if (!this.listeners[type]) this.listeners[type] = [];
				this.listeners[type].push([plugin$1, cb]);
			};
			for (let plugin$1 of this.plugins) if (typeof plugin$1 === "object") for (let event in plugin$1) {
				if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) throw new Error(`Unknown event ${event} in ${plugin$1.postcssPlugin}. ` + `Try to update PostCSS (${this.processor.version} now).`);
				if (!NOT_VISITORS[event]) {
					if (typeof plugin$1[event] === "object") for (let filter in plugin$1[event]) if (filter === "*") add(plugin$1, event, plugin$1[event][filter]);
else add(plugin$1, event + "-" + filter.toLowerCase(), plugin$1[event][filter]);
else if (typeof plugin$1[event] === "function") add(plugin$1, event, plugin$1[event]);
				}
			}
			this.hasListener = Object.keys(this.listeners).length > 0;
		}
		async runAsync() {
			this.plugin = 0;
			for (let i$1 = 0; i$1 < this.plugins.length; i$1++) {
				let plugin$1 = this.plugins[i$1];
				let promise = this.runOnRoot(plugin$1);
				if (isPromise(promise)) try {
					await promise;
				} catch (error) {
					throw this.handleError(error);
				}
			}
			this.prepareVisitors();
			if (this.hasListener) {
				let root$1 = this.result.root;
				while (!root$1[isClean]) {
					root$1[isClean] = true;
					let stack = [toStack(root$1)];
					while (stack.length > 0) {
						let promise = this.visitTick(stack);
						if (isPromise(promise)) try {
							await promise;
						} catch (e) {
							let node = stack[stack.length - 1].node;
							throw this.handleError(e, node);
						}
					}
				}
				if (this.listeners.OnceExit) for (let [plugin$1, visitor] of this.listeners.OnceExit) {
					this.result.lastPlugin = plugin$1;
					try {
						if (root$1.type === "document") {
							let roots = root$1.nodes.map((subRoot) => visitor(subRoot, this.helpers));
							await Promise.all(roots);
						} else await visitor(root$1, this.helpers);
					} catch (e) {
						throw this.handleError(e);
					}
				}
			}
			this.processed = true;
			return this.stringify();
		}
		runOnRoot(plugin$1) {
			this.result.lastPlugin = plugin$1;
			try {
				if (typeof plugin$1 === "object" && plugin$1.Once) {
					if (this.result.root.type === "document") {
						let roots = this.result.root.nodes.map((root$1) => plugin$1.Once(root$1, this.helpers));
						if (isPromise(roots[0])) return Promise.all(roots);
						return roots;
					}
					return plugin$1.Once(this.result.root, this.helpers);
				} else if (typeof plugin$1 === "function") return plugin$1(this.result.root, this.result);
			} catch (error) {
				throw this.handleError(error);
			}
		}
		stringify() {
			if (this.error) throw this.error;
			if (this.stringified) return this.result;
			this.stringified = true;
			this.sync();
			let opts = this.result.opts;
			let str = stringify$3;
			if (opts.syntax) str = opts.syntax.stringify;
			if (opts.stringifier) str = opts.stringifier;
			if (str.stringify) str = str.stringify;
			let map = new MapGenerator$1(str, this.result.root, this.result.opts);
			let data$1 = map.generate();
			this.result.css = data$1[0];
			this.result.map = data$1[1];
			return this.result;
		}
		sync() {
			if (this.error) throw this.error;
			if (this.processed) return this.result;
			this.processed = true;
			if (this.processing) throw this.getAsyncError();
			for (let plugin$1 of this.plugins) {
				let promise = this.runOnRoot(plugin$1);
				if (isPromise(promise)) throw this.getAsyncError();
			}
			this.prepareVisitors();
			if (this.hasListener) {
				let root$1 = this.result.root;
				while (!root$1[isClean]) {
					root$1[isClean] = true;
					this.walkSync(root$1);
				}
				if (this.listeners.OnceExit) if (root$1.type === "document") for (let subRoot of root$1.nodes) this.visitSync(this.listeners.OnceExit, subRoot);
else this.visitSync(this.listeners.OnceExit, root$1);
			}
			return this.result;
		}
		then(onFulfilled, onRejected) {
			if (process.env.NODE_ENV !== "production") {
				if (!("from" in this.opts)) warnOnce$1("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
			}
			return this.async().then(onFulfilled, onRejected);
		}
		toString() {
			return this.css;
		}
		visitSync(visitors, node) {
			for (let [plugin$1, visitor] of visitors) {
				this.result.lastPlugin = plugin$1;
				let promise;
				try {
					promise = visitor(node, this.helpers);
				} catch (e) {
					throw this.handleError(e, node.proxyOf);
				}
				if (node.type !== "root" && node.type !== "document" && !node.parent) return true;
				if (isPromise(promise)) throw this.getAsyncError();
			}
		}
		visitTick(stack) {
			let visit = stack[stack.length - 1];
			let { node, visitors } = visit;
			if (node.type !== "root" && node.type !== "document" && !node.parent) {
				stack.pop();
				return;
			}
			if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
				let [plugin$1, visitor] = visitors[visit.visitorIndex];
				visit.visitorIndex += 1;
				if (visit.visitorIndex === visitors.length) {
					visit.visitors = [];
					visit.visitorIndex = 0;
				}
				this.result.lastPlugin = plugin$1;
				try {
					return visitor(node.toProxy(), this.helpers);
				} catch (e) {
					throw this.handleError(e, node);
				}
			}
			if (visit.iterator !== 0) {
				let iterator = visit.iterator;
				let child;
				while (child = node.nodes[node.indexes[iterator]]) {
					node.indexes[iterator] += 1;
					if (!child[isClean]) {
						child[isClean] = true;
						stack.push(toStack(child));
						return;
					}
				}
				visit.iterator = 0;
				delete node.indexes[iterator];
			}
			let events = visit.events;
			while (visit.eventIndex < events.length) {
				let event = events[visit.eventIndex];
				visit.eventIndex += 1;
				if (event === CHILDREN) {
					if (node.nodes && node.nodes.length) {
						node[isClean] = true;
						visit.iterator = node.getIterator();
					}
					return;
				} else if (this.listeners[event]) {
					visit.visitors = this.listeners[event];
					return;
				}
			}
			stack.pop();
		}
		walkSync(node) {
			node[isClean] = true;
			let events = getEvents(node);
			for (let event of events) if (event === CHILDREN) {
				if (node.nodes) node.each((child) => {
					if (!child[isClean]) this.walkSync(child);
				});
			} else {
				let visitors = this.listeners[event];
				if (visitors) {
					if (this.visitSync(visitors, node.toProxy())) return;
				}
			}
		}
		warnings() {
			return this.sync().warnings();
		}
	};
	LazyResult$2.registerPostcss = (dependant) => {
		postcss$2 = dependant;
	};
	module.exports = LazyResult$2;
	LazyResult$2.default = LazyResult$2;
	Root$3.registerLazyResult(LazyResult$2);
	Document$3.registerLazyResult(LazyResult$2);
} });
var require_no_work_result = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/no-work-result.js"(exports$1, module) {
	let MapGenerator = require_map_generator();
	let parse$3 = require_parse();
	const Result$2 = require_result();
	let stringify$2 = require_stringify();
	let warnOnce = require_warn_once();
	var NoWorkResult$1 = class {
		get content() {
			return this.result.css;
		}
		get css() {
			return this.result.css;
		}
		get map() {
			return this.result.map;
		}
		get messages() {
			return [];
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			if (this._root) return this._root;
			let root$1;
			let parser = parse$3;
			try {
				root$1 = parser(this._css, this._opts);
			} catch (error) {
				this.error = error;
			}
			if (this.error) throw this.error;
else {
				this._root = root$1;
				return root$1;
			}
		}
		get [Symbol.toStringTag]() {
			return "NoWorkResult";
		}
		constructor(processor, css, opts) {
			css = css.toString();
			this.stringified = false;
			this._processor = processor;
			this._css = css;
			this._opts = opts;
			this._map = undefined;
			let root$1;
			let str = stringify$2;
			this.result = new Result$2(this._processor, root$1, this._opts);
			this.result.css = css;
			let self$1 = this;
			Object.defineProperty(this.result, "root", { get() {
				return self$1.root;
			} });
			let map = new MapGenerator(str, root$1, this._opts, css);
			if (map.isMap()) {
				let [generatedCSS, generatedMap] = map.generate();
				if (generatedCSS) this.result.css = generatedCSS;
				if (generatedMap) this.result.map = generatedMap;
			} else {
				map.clearAnnotation();
				this.result.css = map.css;
			}
		}
		async() {
			if (this.error) return Promise.reject(this.error);
			return Promise.resolve(this.result);
		}
		catch(onRejected) {
			return this.async().catch(onRejected);
		}
		finally(onFinally) {
			return this.async().then(onFinally, onFinally);
		}
		sync() {
			if (this.error) throw this.error;
			return this.result;
		}
		then(onFulfilled, onRejected) {
			if (process.env.NODE_ENV !== "production") {
				if (!("from" in this._opts)) warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
			}
			return this.async().then(onFulfilled, onRejected);
		}
		toString() {
			return this._css;
		}
		warnings() {
			return [];
		}
	};
	module.exports = NoWorkResult$1;
	NoWorkResult$1.default = NoWorkResult$1;
} });
var require_processor = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/processor.js"(exports$1, module) {
	let Document$2 = require_document();
	let LazyResult$1 = require_lazy_result();
	let NoWorkResult = require_no_work_result();
	let Root$2 = require_root();
	var Processor$2 = class {
		constructor(plugins = []) {
			this.version = "8.5.3";
			this.plugins = this.normalize(plugins);
		}
		normalize(plugins) {
			let normalized = [];
			for (let i$1 of plugins) {
				if (i$1.postcss === true) i$1 = i$1();
else if (i$1.postcss) i$1 = i$1.postcss;
				if (typeof i$1 === "object" && Array.isArray(i$1.plugins)) normalized = normalized.concat(i$1.plugins);
else if (typeof i$1 === "object" && i$1.postcssPlugin) normalized.push(i$1);
else if (typeof i$1 === "function") normalized.push(i$1);
else if (typeof i$1 === "object" && (i$1.parse || i$1.stringify)) {
					if (process.env.NODE_ENV !== "production") throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
				} else throw new Error(i$1 + " is not a PostCSS plugin");
			}
			return normalized;
		}
		process(css, opts = {}) {
			if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) return new NoWorkResult(this, css, opts);
else return new LazyResult$1(this, css, opts);
		}
		use(plugin$1) {
			this.plugins = this.plugins.concat(this.normalize([plugin$1]));
			return this;
		}
	};
	module.exports = Processor$2;
	Processor$2.default = Processor$2;
	Root$2.registerProcessor(Processor$2);
	Document$2.registerProcessor(Processor$2);
} });
var require_postcss = __commonJS({ "node_modules/.pnpm/postcss@8.5.3/node_modules/postcss/lib/postcss.js"(exports$1, module) {
	let AtRule$1 = require_at_rule();
	let Comment$1 = require_comment();
	let Container$1 = require_container();
	let CssSyntaxError$1 = require_css_syntax_error();
	let Declaration$1 = require_declaration();
	let Document$1 = require_document();
	let fromJSON$1 = require_fromJSON();
	let Input$1 = require_input();
	let LazyResult = require_lazy_result();
	let list$2 = require_list();
	let Node$2 = require_node();
	let parse$2 = require_parse();
	let Processor$1 = require_processor();
	let Result$1 = require_result();
	let Root$1 = require_root();
	let Rule$1 = require_rule();
	let stringify$1 = require_stringify();
	let Warning$1 = require_warning();
	function postcss$1(...plugins) {
		if (plugins.length === 1 && Array.isArray(plugins[0])) plugins = plugins[0];
		return new Processor$1(plugins);
	}
	postcss$1.plugin = function plugin$1(name, initializer) {
		let warningPrinted = false;
		function creator(...args) {
			if (console && console.warn && !warningPrinted) {
				warningPrinted = true;
				console.warn(name + ": postcss.plugin was deprecated. Migration guide:\n" + "https://evilmartians.com/chronicles/postcss-8-plugin-migration");
				if (process.env.LANG && process.env.LANG.startsWith("cn")) console.warn(name + ": 里面 postcss.plugin 被弃用. 迁移指南:\n" + "https://www.w3ctech.com/topic/2226");
			}
			let transformer = initializer(...args);
			transformer.postcssPlugin = name;
			transformer.postcssVersion = new Processor$1().version;
			return transformer;
		}
		let cache;
		Object.defineProperty(creator, "postcss", { get() {
			if (!cache) cache = creator();
			return cache;
		} });
		creator.process = function(css, processOpts, pluginOpts) {
			return postcss$1([creator(pluginOpts)]).process(css, processOpts);
		};
		return creator;
	};
	postcss$1.stringify = stringify$1;
	postcss$1.parse = parse$2;
	postcss$1.fromJSON = fromJSON$1;
	postcss$1.list = list$2;
	postcss$1.comment = (defaults) => new Comment$1(defaults);
	postcss$1.atRule = (defaults) => new AtRule$1(defaults);
	postcss$1.decl = (defaults) => new Declaration$1(defaults);
	postcss$1.rule = (defaults) => new Rule$1(defaults);
	postcss$1.root = (defaults) => new Root$1(defaults);
	postcss$1.document = (defaults) => new Document$1(defaults);
	postcss$1.CssSyntaxError = CssSyntaxError$1;
	postcss$1.Declaration = Declaration$1;
	postcss$1.Container = Container$1;
	postcss$1.Processor = Processor$1;
	postcss$1.Document = Document$1;
	postcss$1.Comment = Comment$1;
	postcss$1.Warning = Warning$1;
	postcss$1.AtRule = AtRule$1;
	postcss$1.Result = Result$1;
	postcss$1.Input = Input$1;
	postcss$1.Rule = Rule$1;
	postcss$1.Root = Root$1;
	postcss$1.Node = Node$2;
	LazyResult.registerPostcss(postcss$1);
	module.exports = postcss$1;
	postcss$1.default = postcss$1;
} });
var import_postcss = __toESM(require_postcss(), 1);
const stringify = import_postcss.default.stringify;
const fromJSON = import_postcss.default.fromJSON;
const plugin = import_postcss.default.plugin;
const parse$1 = import_postcss.default.parse;
const list$1 = import_postcss.default.list;
const document = import_postcss.default.document;
const comment = import_postcss.default.comment;
const atRule = import_postcss.default.atRule;
const rule = import_postcss.default.rule;
const decl = import_postcss.default.decl;
const root = import_postcss.default.root;
const CssSyntaxError = import_postcss.default.CssSyntaxError;
const Declaration = import_postcss.default.Declaration;
const Container = import_postcss.default.Container;
const Processor = import_postcss.default.Processor;
const Document = import_postcss.default.Document;
const Comment = import_postcss.default.Comment;
const Warning = import_postcss.default.Warning;
const AtRule = import_postcss.default.AtRule;
const Result = import_postcss.default.Result;
const Input = import_postcss.default.Input;
const Rule = import_postcss.default.Rule;
const Root = import_postcss.default.Root;
const Node$1 = import_postcss.default.Node;
var require_silver_fleece_umd = __commonJS({ "node_modules/.pnpm/silver-fleece@1.2.1/node_modules/silver-fleece/dist/silver-fleece.umd.js"(exports$1, module) {
	(function(global$1, factory) {
		typeof exports$1 === "object" && typeof module !== "undefined" ? factory(exports$1) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global$1 = typeof globalThis !== "undefined" ? globalThis : global$1 || self, factory(global$1.fleece = {}));
	})(exports$1, function(exports$1$1) {
		"use strict";
		/******************************************************************************
		
		Copyright (c) Microsoft Corporation.
		
		
		
		Permission to use, copy, modify, and/or distribute this software for any
		
		purpose with or without fee is hereby granted.
		
		
		
		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
		
		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
		
		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
		
		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
		
		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
		
		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
		
		PERFORMANCE OF THIS SOFTWARE.
		
		***************************************************************************** */
		var extendStatics = function(d, b) {
			extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
				d$1.__proto__ = b$1;
			} || function(d$1, b$1) {
				for (var p$1 in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p$1)) d$1[p$1] = b$1[p$1];
			};
			return extendStatics(d, b);
		};
		function __extends(d, b) {
			if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			extendStatics(d, b);
			function __() {
				this.constructor = d;
			}
			d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		}
		typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
			var e = new Error(message);
			return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
		};
		var whitespace = /\s/;
		var number = /-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/;
		function spaces(n$1) {
			var result = "";
			while (n$1--) result += " ";
			return result;
		}
		function rangeContains(range, index) {
			return range.start <= index && index < range.end;
		}
		function getLocator$1(source, options) {
			if (options === void 0) options = {};
			var _a$1 = options.offsetLine, offsetLine = _a$1 === void 0 ? 0 : _a$1, _b = options.offsetColumn, offsetColumn = _b === void 0 ? 0 : _b;
			var start = 0;
			var ranges = source.split("\n").map(function(line, i$2) {
				var end = start + line.length + 1;
				var range = {
					start,
					end,
					line: i$2
				};
				start = end;
				return range;
			});
			var i$1 = 0;
			function locator(search, index) {
				if (typeof search === "string") search = source.indexOf(search, index !== null && index !== void 0 ? index : 0);
				if (search === -1) return undefined;
				var range = ranges[i$1];
				var d = search >= range.end ? 1 : -1;
				while (range) {
					if (rangeContains(range, search)) return {
						line: offsetLine + range.line,
						column: offsetColumn + search - range.start,
						character: search
					};
					i$1 += d;
					range = ranges[i$1];
				}
			}
			return locator;
		}
		function locate(source, search, options) {
			return getLocator$1(source, options)(search, options && options.startIndex);
		}
		function parse$7(str, opts) {
			var parser = new Parser$4(str, opts);
			return parser.value;
		}
		function noop() {}
		var ParseError = function(_super) {
			__extends(ParseError$1, _super);
			function ParseError$1(message, pos, loc) {
				var _this = _super.call(this, message) || this;
				_this.pos = pos;
				_this.loc = loc;
				return _this;
			}
			return ParseError$1;
		}(Error);
		var Parser$4 = function() {
			function Parser$5(str, opts) {
				this.str = str;
				this.index = 0;
				this.onComment = opts && opts.onComment || noop;
				this.onValue = opts && opts.onValue || noop;
				this.value = this.readValue();
				this.readWhitespaceOrComment();
				if (this.index < this.str.length) throw new Error("Unexpected character '".concat(this.peek(), "'"));
			}
			Parser$5.prototype.readWhitespaceOrComment = function() {
				while (this.index < this.str.length && whitespace.test(this.str[this.index])) this.index++;
				var start = this.index;
				if (this.eat("/")) {
					if (this.eat("/")) {
						var text$1 = this.readUntil(/(?:\r\n|\n|\r)/);
						this.onComment({
							start,
							end: this.index,
							type: "Comment",
							text: text$1,
							block: false
						});
						this.eat("\n");
					} else if (this.eat("*")) {
						var text$1 = this.readUntil(/\*\//);
						this.onComment({
							start,
							end: this.index,
							type: "Comment",
							text: text$1,
							block: true
						});
						this.eat("*/", true);
					}
				} else return;
				this.readWhitespaceOrComment();
			};
			Parser$5.prototype.error = function(message, index) {
				if (index === void 0) index = this.index;
				var loc = locate(this.str, index, { offsetLine: 1 });
				throw new ParseError(message, index, loc);
			};
			Parser$5.prototype.eat = function(str, required) {
				if (this.str.slice(this.index, this.index + str.length) === str) {
					this.index += str.length;
					return str;
				}
				if (required) this.error("Expected '".concat(str, "' instead of '").concat(this.str[this.index], "'"));
				return null;
			};
			Parser$5.prototype.peek = function() {
				return this.str[this.index];
			};
			Parser$5.prototype.read = function(pattern) {
				var match = pattern.exec(this.str.slice(this.index));
				if (!match || match.index !== 0) return null;
				this.index += match[0].length;
				return match[0];
			};
			Parser$5.prototype.readUntil = function(pattern) {
				if (this.index >= this.str.length) this.error("Unexpected end of input");
				var start = this.index;
				var match = pattern.exec(this.str.slice(start));
				if (match) {
					var start_1 = this.index;
					this.index = start_1 + match.index;
					return this.str.slice(start_1, this.index);
				}
				this.index = this.str.length;
				return this.str.slice(start);
			};
			Parser$5.prototype.readArray = function() {
				var start = this.index;
				if (!this.eat("[")) return null;
				var array = {
					start,
					end: null,
					type: "ArrayExpression",
					elements: []
				};
				this.readWhitespaceOrComment();
				while (this.peek() !== "]") {
					array.elements.push(this.readValue());
					this.readWhitespaceOrComment();
					if (!this.eat(",")) break;
					this.readWhitespaceOrComment();
				}
				if (!this.eat("]")) this.error("Expected ']' instead of '".concat(this.str[this.index], "'"));
				array.end = this.index;
				return array;
			};
			Parser$5.prototype.readBoolean = function() {
				var start = this.index;
				var raw = this.read(/^(true|false)/);
				if (raw) return {
					start,
					end: this.index,
					type: "Literal",
					raw,
					value: raw === "true"
				};
			};
			Parser$5.prototype.readNull = function() {
				var start = this.index;
				if (this.eat("null")) return {
					start,
					end: this.index,
					type: "Literal",
					raw: "null",
					value: null
				};
			};
			Parser$5.prototype.readLiteral = function() {
				return this.readBoolean() || this.readNumber() || this.readString() || this.readNull();
			};
			Parser$5.prototype.readNumber = function() {
				var start = this.index;
				var raw = this.read(number);
				if (raw) return {
					start,
					end: this.index,
					type: "Literal",
					raw,
					value: Number(raw)
				};
			};
			Parser$5.prototype.readObject = function() {
				var start = this.index;
				if (!this.eat("{")) return;
				var object = {
					start,
					end: null,
					type: "ObjectExpression",
					properties: []
				};
				this.readWhitespaceOrComment();
				while (this.peek() !== "}") {
					object.properties.push(this.readProperty());
					this.readWhitespaceOrComment();
					if (!this.eat(",")) break;
					this.readWhitespaceOrComment();
				}
				this.eat("}", true);
				object.end = this.index;
				return object;
			};
			Parser$5.prototype.readProperty = function() {
				this.readWhitespaceOrComment();
				var property = {
					start: this.index,
					end: null,
					type: "Property",
					key: this.readPropertyKey(),
					value: this.readValue()
				};
				property.end = this.index;
				return property;
			};
			Parser$5.prototype.readPropertyKey = function() {
				var key = this.readString();
				if (!key) this.error("Bad identifier");
				if (key.type === "Literal") key.name = String(key.value);
				this.readWhitespaceOrComment();
				this.eat(":", true);
				return key;
			};
			Parser$5.prototype.readString = function() {
				var start = this.index;
				var quote$1 = this.eat("\"");
				if (!quote$1) return;
				var end = this.str.indexOf("\"", start + 1);
				while (end > 0 && this.str[end - 1] === "\\") end = this.str.indexOf("\"", end + 1);
				if (end === -1) this.error("Unexpected end of input");
				end++;
				this.index = end;
				var raw = this.str.slice(start, end);
				return {
					start,
					end,
					type: "Literal",
					raw,
					value: JSON.parse(raw)
				};
			};
			Parser$5.prototype.readValue = function() {
				this.readWhitespaceOrComment();
				var value = this.readArray() || this.readObject() || this.readLiteral();
				if (value) {
					this.onValue(value);
					return value;
				}
				this.error("Unexpected EOF");
			};
			return Parser$5;
		}();
		function evaluate(str, opts) {
			var ast = parse$7(str, opts);
			return getValue(ast);
		}
		function getValue(node) {
			if (node.type === "Literal") return node.value;
			if (node.type === "ArrayExpression") return node.elements.map(getValue);
			if (node.type === "ObjectExpression") {
				var obj_1 = {};
				node.properties.forEach(function(prop) {
					obj_1[prop.key.name] = getValue(prop.value);
				});
				return obj_1;
			}
		}
		function stringify$6(value, options) {
			var indentString = options && options.spaces ? spaces(options.spaces) : "	";
			return stringifyValue(value, "\n", indentString, true);
		}
		function stringifyProperty(key, value, indentation, indentString, newlines) {
			return JSON.stringify(key) + ": " + stringifyValue(value, indentation, indentString, newlines);
		}
		function stringifyValue(value, indentation, indentString, newlines) {
			var type = typeof value;
			if (type === "boolean" || type === "number" || type === "string" || type === null) return JSON.stringify(value);
else if (Array.isArray(value)) {
				var elements = value.map(function(element) {
					return stringifyValue(element, indentation + indentString, indentString, true);
				});
				if (newlines) return "[".concat(indentation + indentString) + elements.join(",".concat(indentation + indentString)) + "".concat(indentation, "]");
				return "[ ".concat(elements.join(", "), " ]");
			} else if (type === "object") {
				var keys$1 = Object.keys(value);
				var properties = keys$1.map(function(key) {
					return stringifyProperty(key, value[key], indentation + indentString, indentString, newlines);
				});
				if (newlines) return "{".concat(indentation + indentString) + properties.join(",".concat(indentation + indentString)) + "".concat(indentation, "}");
				return "{ ".concat(properties.join(", "), " }");
			}
			throw new Error("Cannot stringify ".concat(type));
		}
		function patch(str, value) {
			var indentString = guessIndentString$1(str);
			var root$1 = parse$7(str);
			var newlines = /\n/.test(str.slice(root$1.start, root$1.end)) || root$1.type === "ArrayExpression" && root$1.elements.length === 0 || root$1.type === "ObjectExpression" && root$1.properties.length === 0;
			return str.slice(0, root$1.start) + patchValue(root$1, value, str, "\n", indentString, newlines) + str.slice(root$1.end);
		}
		function patchValue(node, value, str, indentation, indentString, newlines) {
			var type = typeof value;
			if (type === "string") return JSON.stringify(value);
			if (type === "number") return patchNumber(node.raw, value);
			if (type === "boolean" || value === null) return String(value);
			if (Array.isArray(value)) {
				if (node.type === "ArrayExpression") return patchArray(node, value, str, indentation, indentString);
				return stringifyValue(value, indentation, indentString, newlines);
			}
			if (type === "object") {
				if (node.type === "ObjectExpression") return patchObject(node, value, str, indentation, indentString);
				return stringifyValue(value, indentation, indentString, newlines);
			}
			throw new Error("Cannot stringify ".concat(type, "s"));
		}
		function patchNumber(raw, value) {
			return String(value);
		}
		function patchArray(node, value, str, indentation, indentString, newlines) {
			if (value.length === 0) return node.elements.length === 0 ? str.slice(node.start, node.end) : "[]";
			var precedingWhitespace = getPrecedingWhitespace(str, node.start);
			var empty$2 = precedingWhitespace === "";
			var newline$1 = empty$2 || /\n/.test(precedingWhitespace);
			if (node.elements.length === 0) return stringifyValue(value, indentation, indentString, newline$1);
			var i$1 = 0;
			var c$1 = node.start;
			var patched = "";
			var newlinesInsideValue = str.slice(node.start, node.end).split("\n").length > 1;
			for (; i$1 < value.length; i$1 += 1) {
				var element = node.elements[i$1];
				if (element) {
					patched += str.slice(c$1, element.start) + patchValue(element, value[i$1], str, indentation, indentString, newlinesInsideValue);
					c$1 = element.end;
				} else if (newlinesInsideValue) patched += ",".concat(indentation + indentString) + stringifyValue(value[i$1], indentation, indentString, true);
else patched += ", " + stringifyValue(value[i$1], indentation, indentString, false);
			}
			if (i$1 < node.elements.length) c$1 = node.elements[node.elements.length - 1].end;
			patched += str.slice(c$1, node.end);
			return patched;
		}
		function patchObject(node, value, str, indentation, indentString, newlines) {
			var keys$1 = Object.keys(value);
			if (keys$1.length === 0) return node.properties.length === 0 ? str.slice(node.start, node.end) : "{}";
			var existingProperties = {};
			node.properties.forEach(function(prop) {
				existingProperties[prop.key.name] = prop;
			});
			var precedingWhitespace = getPrecedingWhitespace(str, node.start);
			var empty$2 = precedingWhitespace === "";
			var newline$1 = empty$2 || /\n/.test(precedingWhitespace);
			if (node.properties.length === 0) return stringifyValue(value, indentation, indentString, newline$1);
			var i$1 = 0;
			var c$1 = node.start;
			var patched = "";
			var newlinesInsideValue = /\n/.test(str.slice(node.start, node.end));
			var started = false;
			var intro$1 = str.slice(node.start, node.properties[0].start);
			for (; i$1 < node.properties.length; i$1 += 1) {
				var property = node.properties[i$1];
				var propertyValue = value[property.key.name];
				indentation = getIndentation(str, property.start);
				if (propertyValue !== undefined) {
					patched += started ? str.slice(c$1, property.value.start) : intro$1 + str.slice(property.key.start, property.value.start);
					patched += patchValue(property.value, propertyValue, str, indentation, indentString, newlinesInsideValue);
					started = true;
				}
				c$1 = property.end;
			}
			keys$1.forEach(function(key) {
				if (key in existingProperties) return;
				var propertyValue$1 = value[key];
				patched += (started ? "," + (newlinesInsideValue ? indentation : " ") : intro$1) + stringifyProperty(key, propertyValue$1, indentation, indentString, newlinesInsideValue);
				started = true;
			});
			patched += str.slice(c$1, node.end);
			return patched;
		}
		function getIndentation(str, i$1) {
			while (i$1 > 0 && !whitespace.test(str[i$1 - 1])) i$1 -= 1;
			var end = i$1;
			while (i$1 > 0 && whitespace.test(str[i$1 - 1])) i$1 -= 1;
			return str.slice(i$1, end);
		}
		function getPrecedingWhitespace(str, i$1) {
			var end = i$1;
			while (i$1 > 0 && whitespace.test(str[i$1])) i$1 -= 1;
			return str.slice(i$1, end);
		}
		function guessIndentString$1(str) {
			var lines = str.split("\n");
			var tabs = 0;
			var spaces$1 = 0;
			var minSpaces = 8;
			lines.forEach(function(line) {
				var match = /^(?: +|\t+)/.exec(line);
				if (!match) return;
				var whitespace$1 = match[0];
				if (whitespace$1.length === line.length) return;
				if (whitespace$1[0] === "	") tabs += 1;
else {
					spaces$1 += 1;
					if (whitespace$1.length > 1 && whitespace$1.length < minSpaces) minSpaces = whitespace$1.length;
				}
			});
			if (spaces$1 > tabs) {
				var result = "";
				while (minSpaces--) result += " ";
				return result;
			} else return "	";
		}
		exports$1$1.evaluate = evaluate;
		exports$1$1.parse = parse$7;
		exports$1$1.patch = patch;
		exports$1$1.stringify = stringify$6;
	});
} });
/** @import { TSESTree } from '@typescript-eslint/types' */
/** @import { Command, Dedent, Handlers, Location, Indent, Newline, NodeWithComments, State, TypeAnnotationNodes } from './types' */
/** @type {Newline} */
const newline = { type: "Newline" };
/** @type {Indent} */
const indent$1 = { type: "Indent" };
/** @type {Dedent} */
const dedent = { type: "Dedent" };
/**
* @returns {Command[]}
*/
function create_sequence() {
	return [];
}
/**
* Rough estimate of the combined width of a group of commands
* @param {Command[]} commands
* @param {number} from
* @param {number} to
*/
function measure(commands, from$1, to = commands.length) {
	let total = 0;
	for (let i$1 = from$1; i$1 < to; i$1 += 1) {
		const command = commands[i$1];
		if (typeof command === "string") total += command.length;
else if (Array.isArray(command)) total += command.length === 0 ? 2 : measure(command, 0);
	}
	return total;
}
function handle(node, state) {
	const node_with_comments = node;
	const handler = handlers[node.type];
	if (!handler) throw new Error(`Not implemented ${node.type}`);
	if (node_with_comments.leadingComments) prepend_comments(node_with_comments.leadingComments, state, false);
	handler(node, state);
	if (node_with_comments.trailingComments) state.comments.push(node_with_comments.trailingComments[0]);
}
/**
* @param {number} line
* @param {number} column
* @returns {Location}
*/
function l(line, column) {
	return {
		type: "Location",
		line,
		column
	};
}
/**
* @param {string} content
* @param {TSESTree.Node} node
* @returns {string | Command[]}
*/
function c(content, node) {
	return node.loc ? [
		l(node.loc.start.line, node.loc.start.column),
		content,
		l(node.loc.end.line, node.loc.end.column)
	] : content;
}
/**
* @param {TSESTree.Comment[]} comments
* @param {State} state
* @param {boolean} newlines
*/
function prepend_comments(comments, state, newlines) {
	for (const comment$1 of comments) {
		state.commands.push({
			type: "Comment",
			comment: comment$1
		});
		if (newlines || comment$1.type === "Line" || /\n/.test(comment$1.value)) state.commands.push(newline);
else state.commands.push(" ");
	}
}
/**
* @param {string} string
* @param {'\'' | '"'} char
*/
function quote(string, char) {
	let out = char;
	for (const c$1 of string) if (c$1 === "\\") out += "\\\\";
else if (c$1 === char) out += "\\" + c$1;
else if (c$1 === "\n") out += "\\n";
else if (c$1 === "\r") out += "\\r";
else out += c$1;
	return out + char;
}
const OPERATOR_PRECEDENCE = {
	"||": 2,
	"&&": 3,
	"??": 4,
	"|": 5,
	"^": 6,
	"&": 7,
	"==": 8,
	"!=": 8,
	"===": 8,
	"!==": 8,
	"<": 9,
	">": 9,
	"<=": 9,
	">=": 9,
	in: 9,
	instanceof: 9,
	"<<": 10,
	">>": 10,
	">>>": 10,
	"+": 11,
	"-": 11,
	"*": 12,
	"%": 12,
	"/": 12,
	"**": 13
};
/** @type {Record<TSESTree.Expression['type'] | 'Super' | 'RestElement', number>} */
const EXPRESSIONS_PRECEDENCE = {
	JSXFragment: 20,
	JSXElement: 20,
	ArrayPattern: 20,
	ObjectPattern: 20,
	ArrayExpression: 20,
	TaggedTemplateExpression: 20,
	ThisExpression: 20,
	Identifier: 20,
	TemplateLiteral: 20,
	Super: 20,
	SequenceExpression: 20,
	MemberExpression: 19,
	MetaProperty: 19,
	CallExpression: 19,
	ChainExpression: 19,
	ImportExpression: 19,
	NewExpression: 19,
	Literal: 18,
	TSSatisfiesExpression: 18,
	TSInstantiationExpression: 18,
	TSNonNullExpression: 18,
	TSTypeAssertion: 18,
	AwaitExpression: 17,
	ClassExpression: 17,
	FunctionExpression: 17,
	ObjectExpression: 17,
	TSAsExpression: 16,
	UpdateExpression: 16,
	UnaryExpression: 15,
	BinaryExpression: 14,
	LogicalExpression: 13,
	ConditionalExpression: 4,
	ArrowFunctionExpression: 3,
	AssignmentExpression: 3,
	YieldExpression: 2,
	RestElement: 1
};
/**
*
* @param {TSESTree.Expression | TSESTree.PrivateIdentifier} node
* @param {TSESTree.BinaryExpression | TSESTree.LogicalExpression} parent
* @param {boolean} is_right
* @returns
*/
function needs_parens(node, parent, is_right) {
	if (node.type === "PrivateIdentifier") return false;
	if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) return true;
	const precedence = EXPRESSIONS_PRECEDENCE[node.type];
	const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
	if (precedence !== parent_precedence) return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
	if (precedence !== 13 && precedence !== 14) return false;
	if (node.operator === "**" && parent.operator === "**") return !is_right;
	if (is_right) return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parent.operator];
	return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parent.operator];
}
/** @param {TSESTree.Node} node */
function has_call_expression(node) {
	while (node) if (node.type === "CallExpression") return true;
else if (node.type === "MemberExpression") node = node.object;
else return false;
}
const grouped_expression_types = [
	"ImportDeclaration",
	"VariableDeclaration",
	"ExportDefaultDeclaration",
	"ExportNamedDeclaration"
];
/**
* @param {TSESTree.Node[]} nodes
* @param {State} state
*/
const handle_body = (nodes, state) => {
	let last_statement = { type: "EmptyStatement" };
	let first = true;
	let needs_margin = false;
	for (const statement of nodes) {
		if (statement.type === "EmptyStatement") continue;
		const margin = create_sequence();
		if (!first) state.commands.push(margin, newline);
		first = false;
		const statement_with_comments = statement;
		const leading_comments = statement_with_comments.leadingComments;
		delete statement_with_comments.leadingComments;
		if (leading_comments && leading_comments.length > 0) prepend_comments(leading_comments, state, true);
		const child_state = {
			...state,
			multiline: false
		};
		handle(statement, child_state);
		if (child_state.multiline || needs_margin || (grouped_expression_types.includes(statement.type) || grouped_expression_types.includes(last_statement.type)) && last_statement.type !== statement.type) margin.push("\n");
		let add_newline = false;
		while (state.comments.length) {
			const comment$1 = state.comments.shift();
			state.commands.push(add_newline ? newline : " ", {
				type: "Comment",
				comment: comment$1
			});
			add_newline = comment$1.type === "Line";
		}
		needs_margin = child_state.multiline;
		last_statement = statement;
	}
};
/**
* @param {TSESTree.VariableDeclaration} node
* @param {State} state
*/
const handle_var_declaration = (node, state) => {
	const index = state.commands.length;
	const open = create_sequence();
	const join$2 = create_sequence();
	const child_state = {
		...state,
		multiline: false
	};
	state.commands.push(`${node.kind} `, open);
	let first = true;
	for (const d of node.declarations) {
		if (!first) state.commands.push(join$2);
		first = false;
		handle(d, child_state);
	}
	const multiline = child_state.multiline || node.declarations.length > 1 && measure(state.commands, index) > 50;
	if (multiline) {
		state.multiline = true;
		if (node.declarations.length > 1) open.push(indent$1);
		join$2.push(",", newline);
		if (node.declarations.length > 1) state.commands.push(dedent);
	} else join$2.push(", ");
};
/**
* @template {TSESTree.Node} T
* @param {Array<T | null>} nodes
* @param {State} state
* @param {boolean} spaces
* @param {(node: T, state: State) => void} fn
*/
function sequence(nodes, state, spaces, fn, separator = ",") {
	if (nodes.length === 0) return;
	const index = state.commands.length;
	const open = create_sequence();
	const join$2 = create_sequence();
	const close = create_sequence();
	state.commands.push(open);
	const child_state = {
		...state,
		multiline: false
	};
	let prev;
	for (let i$1 = 0; i$1 < nodes.length; i$1 += 1) {
		const node = nodes[i$1];
		const is_first = i$1 === 0;
		const is_last = i$1 === nodes.length - 1;
		if (node) {
			if (!is_first && !prev) state.commands.push(join$2);
			fn(node, child_state);
			if (!is_last) state.commands.push(separator);
			if (state.comments.length > 0) {
				state.commands.push(" ");
				while (state.comments.length) {
					const comment$1 = state.comments.shift();
					state.commands.push({
						type: "Comment",
						comment: comment$1
					});
					if (!is_last) state.commands.push(join$2);
				}
				child_state.multiline = true;
			} else if (!is_last) state.commands.push(join$2);
		} else state.commands.push(separator);
		prev = node;
	}
	state.commands.push(close);
	const multiline = child_state.multiline || measure(state.commands, index) > 50;
	if (multiline) {
		state.multiline = true;
		open.push(indent$1, newline);
		join$2.push(newline);
		close.push(dedent, newline);
	} else {
		if (spaces) open.push(" ");
		join$2.push(" ");
		if (spaces) close.push(" ");
	}
}
/**
* @param {TypeAnnotationNodes} node
* @param {State} state
*/
function handle_type_annotation(node, state) {
	switch (node.type) {
		case "TSNumberKeyword":
			state.commands.push("number");
			break;
		case "TSStringKeyword":
			state.commands.push("string");
			break;
		case "TSBooleanKeyword":
			state.commands.push("boolean");
			break;
		case "TSAnyKeyword":
			state.commands.push("any");
			break;
		case "TSVoidKeyword":
			state.commands.push("void");
			break;
		case "TSUnknownKeyword":
			state.commands.push("unknown");
			break;
		case "TSNeverKeyword":
			state.commands.push("never");
			break;
		case "TSArrayType":
			handle_type_annotation(node.elementType, state);
			state.commands.push("[]");
			break;
		case "TSTypeAnnotation":
			state.commands.push(": ");
			handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSTypeLiteral":
			state.commands.push("{ ");
			sequence(node.members, state, false, handle_type_annotation, ";");
			state.commands.push(" }");
			break;
		case "TSPropertySignature":
			handle(node.key, state);
			if (node.optional) state.commands.push("?");
			if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSTypeReference":
			handle(node.typeName, state);
			if (node.typeArguments) handle_type_annotation(node.typeArguments, state);
			break;
		case "TSTypeParameterInstantiation":
		case "TSTypeParameterDeclaration":
			state.commands.push("<");
			for (let i$1 = 0; i$1 < node.params.length; i$1++) {
				handle_type_annotation(node.params[i$1], state);
				if (i$1 != node.params.length - 1) state.commands.push(", ");
			}
			state.commands.push(">");
			break;
		case "TSTypeParameter":
			state.commands.push(node.name);
			if (node.constraint) {
				state.commands.push(" extends ");
				handle_type_annotation(node.constraint, state);
			}
			break;
		case "TSTypeQuery":
			state.commands.push("typeof ");
			handle(node.exprName, state);
			break;
		case "TSEnumMember":
			handle(node.id, state);
			if (node.initializer) {
				state.commands.push(" = ");
				handle(node.initializer, state);
			}
			break;
		case "TSFunctionType":
			if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
			const parameters = node.parameters;
			state.commands.push("(");
			sequence(parameters, state, false, handle);
			state.commands.push(") => ");
			handle_type_annotation(node.typeAnnotation.typeAnnotation, state);
			break;
		case "TSIndexSignature":
			const indexParameters = node.parameters;
			state.commands.push("[");
			sequence(indexParameters, state, false, handle);
			state.commands.push("]");
			handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSMethodSignature":
			handle(node.key, state);
			const parametersSignature = node.parameters;
			state.commands.push("(");
			sequence(parametersSignature, state, false, handle);
			state.commands.push(")");
			handle_type_annotation(node.typeAnnotation, state);
			break;
		case "TSExpressionWithTypeArguments":
			handle(node.expression, state);
			break;
		case "TSTupleType":
			state.commands.push("[");
			sequence(node.elementTypes, state, false, handle_type_annotation);
			state.commands.push("]");
			break;
		case "TSNamedTupleMember":
			handle(node.label, state);
			state.commands.push(": ");
			handle_type_annotation(node.elementType, state);
			break;
		case "TSUnionType":
			sequence(node.types, state, false, handle_type_annotation, " |");
			break;
		case "TSIntersectionType":
			sequence(node.types, state, false, handle_type_annotation, " &");
			break;
		case "TSLiteralType":
			handle(node.literal, state);
			break;
		case "TSConditionalType":
			handle_type_annotation(node.checkType, state);
			state.commands.push(" extends ");
			handle_type_annotation(node.extendsType, state);
			state.commands.push(" ? ");
			handle_type_annotation(node.trueType, state);
			state.commands.push(" : ");
			handle_type_annotation(node.falseType, state);
			break;
		case "TSIndexedAccessType":
			handle_type_annotation(node.objectType, state);
			state.commands.push("[");
			handle_type_annotation(node.indexType, state);
			state.commands.push("]");
			break;
		case "TSImportType":
			state.commands.push("import(");
			handle(node.argument, state);
			state.commands.push(")");
			if (node.qualifier) {
				state.commands.push(".");
				handle(node.qualifier, state);
			}
			break;
		default: throw new Error(`Not implemented type annotation ${node.type}`);
	}
}
/** @satisfies {Record<string, (node: any, state: State) => undefined>} */
const shared = {
	"ArrayExpression|ArrayPattern": (node, state) => {
		state.commands.push("[");
		sequence(node.elements, state, false, handle);
		state.commands.push("]");
	},
	"BinaryExpression|LogicalExpression": (node, state) => {
		if (needs_parens(node.left, node, false)) {
			state.commands.push("(");
			handle(node.left, state);
			state.commands.push(")");
		} else handle(node.left, state);
		state.commands.push(` ${node.operator} `);
		if (needs_parens(node.right, node, true)) {
			state.commands.push("(");
			handle(node.right, state);
			state.commands.push(")");
		} else handle(node.right, state);
	},
	"BlockStatement|ClassBody": (node, state) => {
		if (node.loc) {
			const { line, column } = node.loc.start;
			state.commands.push(l(line, column), "{", l(line, column + 1));
		} else state.commands.push("{");
		if (node.body.length > 0) {
			state.multiline = true;
			state.commands.push(indent$1, newline);
			handle_body(node.body, state);
			state.commands.push(dedent, newline);
		}
		if (node.loc) {
			const { line, column } = node.loc.end;
			state.commands.push(l(line, column - 1), "}", l(line, column));
		} else state.commands.push("}");
	},
	"CallExpression|NewExpression": (node, state) => {
		if (node.type === "NewExpression") state.commands.push("new ");
		const needs_parens$1 = EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || node.type === "NewExpression" && has_call_expression(node.callee);
		if (needs_parens$1) {
			state.commands.push("(");
			handle(node.callee, state);
			state.commands.push(")");
		} else handle(node.callee, state);
		if (node.optional) state.commands.push("?.");
		if (node.typeArguments) handle_type_annotation(node.typeArguments, state);
		const open = create_sequence();
		const join$2 = create_sequence();
		const close = create_sequence();
		state.commands.push("(", open);
		const child_state = {
			...state,
			multiline: false
		};
		const final_state = {
			...state,
			multiline: false
		};
		for (let i$1 = 0; i$1 < node.arguments.length; i$1 += 1) {
			if (i$1 > 0) if (state.comments.length > 0) {
				state.commands.push(", ");
				while (state.comments.length) {
					const comment$1 = state.comments.shift();
					state.commands.push({
						type: "Comment",
						comment: comment$1
					});
					if (comment$1.type === "Line") {
						child_state.multiline = true;
						state.commands.push(newline);
					} else state.commands.push(" ");
				}
			} else state.commands.push(join$2);
			const p$1 = node.arguments[i$1];
			handle(p$1, i$1 === node.arguments.length - 1 ? final_state : child_state);
		}
		state.commands.push(close, ")");
		const multiline = child_state.multiline;
		if (multiline || final_state.multiline) state.multiline = true;
		if (multiline) {
			open.push(indent$1, newline);
			join$2.push(",", newline);
			close.push(dedent, newline);
		} else join$2.push(", ");
	},
	"ClassDeclaration|ClassExpression": (node, state) => {
		state.commands.push("class ");
		if (node.id) {
			handle(node.id, state);
			state.commands.push(" ");
		}
		if (node.superClass) {
			state.commands.push("extends ");
			handle(node.superClass, state);
			state.commands.push(" ");
		}
		if (node.implements) {
			state.commands.push("implements ");
			sequence(node.implements, state, false, handle_type_annotation);
		}
		handle(node.body, state);
	},
	"ForInStatement|ForOfStatement": (node, state) => {
		state.commands.push("for ");
		if (node.type === "ForOfStatement" && node.await) state.commands.push("await ");
		state.commands.push("(");
		if (node.left.type === "VariableDeclaration") handle_var_declaration(node.left, state);
else handle(node.left, state);
		state.commands.push(node.type === "ForInStatement" ? ` in ` : ` of `);
		handle(node.right, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	"FunctionDeclaration|FunctionExpression": (node, state) => {
		if (node.async) state.commands.push("async ");
		state.commands.push(node.generator ? "function* " : "function ");
		if (node.id) handle(node.id, state);
		if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
		state.commands.push("(");
		sequence(node.params, state, false, handle);
		state.commands.push(")");
		if (node.returnType) handle_type_annotation(node.returnType, state);
		state.commands.push(" ");
		handle(node.body, state);
	},
	"RestElement|SpreadElement": (node, state) => {
		state.commands.push("...");
		handle(node.argument, state);
		if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
	}
};
/** @type {Handlers} */
const handlers = {
	ArrayExpression: shared["ArrayExpression|ArrayPattern"],
	ArrayPattern: shared["ArrayExpression|ArrayPattern"],
	ArrowFunctionExpression: (node, state) => {
		if (node.async) state.commands.push("async ");
		state.commands.push("(");
		sequence(node.params, state, false, handle);
		state.commands.push(") => ");
		if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern" || node.body.type === "LogicalExpression" && node.body.left.type === "ObjectExpression" || node.body.type === "ConditionalExpression" && node.body.test.type === "ObjectExpression") {
			state.commands.push("(");
			handle(node.body, state);
			state.commands.push(")");
		} else handle(node.body, state);
	},
	AssignmentExpression(node, state) {
		handle(node.left, state);
		state.commands.push(` ${node.operator} `);
		handle(node.right, state);
	},
	AssignmentPattern(node, state) {
		handle(node.left, state);
		state.commands.push(" = ");
		handle(node.right, state);
	},
	AwaitExpression(node, state) {
		if (node.argument) {
			const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
			if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
				state.commands.push("await (");
				handle(node.argument, state);
				state.commands.push(")");
			} else {
				state.commands.push("await ");
				handle(node.argument, state);
			}
		} else state.commands.push("await");
	},
	BinaryExpression: shared["BinaryExpression|LogicalExpression"],
	BlockStatement: shared["BlockStatement|ClassBody"],
	BreakStatement(node, state) {
		if (node.label) {
			state.commands.push("break ");
			handle(node.label, state);
			state.commands.push(";");
		} else state.commands.push("break;");
	},
	CallExpression: shared["CallExpression|NewExpression"],
	ChainExpression(node, state) {
		handle(node.expression, state);
	},
	ClassBody: shared["BlockStatement|ClassBody"],
	ClassDeclaration: shared["ClassDeclaration|ClassExpression"],
	ClassExpression: shared["ClassDeclaration|ClassExpression"],
	ConditionalExpression(node, state) {
		if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) handle(node.test, state);
else {
			state.commands.push("(");
			handle(node.test, state);
			state.commands.push(")");
		}
		const if_true = create_sequence();
		const if_false = create_sequence();
		const child_state = {
			...state,
			multiline: false
		};
		state.commands.push(if_true);
		handle(node.consequent, child_state);
		state.commands.push(if_false);
		handle(node.alternate, child_state);
		const multiline = child_state.multiline;
		if (multiline) {
			if_true.push(indent$1, newline, "? ");
			if_false.push(newline, ": ");
			state.commands.push(dedent);
		} else {
			if_true.push(" ? ");
			if_false.push(" : ");
		}
	},
	ContinueStatement(node, state) {
		if (node.label) {
			state.commands.push("continue ");
			handle(node.label, state);
			state.commands.push(";");
		} else state.commands.push("continue;");
	},
	DebuggerStatement(node, state) {
		state.commands.push(c("debugger", node), ";");
	},
	Decorator(node, state) {
		state.commands.push("@");
		handle(node.expression, state);
		state.commands.push(newline);
	},
	DoWhileStatement(node, state) {
		state.commands.push("do ");
		handle(node.body, state);
		state.commands.push(" while (");
		handle(node.test, state);
		state.commands.push(");");
	},
	EmptyStatement(node, state) {
		state.commands.push(";");
	},
	ExportAllDeclaration(node, state) {
		state.commands.push("export * ");
		if (node.exported) {
			state.commands.push("as ");
			handle(node.exported, state);
		}
		state.commands.push(" from ");
		handle(node.source, state);
		state.commands.push(";");
	},
	ExportDefaultDeclaration(node, state) {
		state.commands.push("export default ");
		handle(node.declaration, state);
		if (node.declaration.type !== "FunctionDeclaration") state.commands.push(";");
	},
	ExportNamedDeclaration(node, state) {
		state.commands.push("export ");
		if (node.declaration) {
			handle(node.declaration, state);
			return;
		}
		state.commands.push("{");
		sequence(node.specifiers, state, true, (s$1, state$1) => {
			handle(s$1.local, state$1);
			if (s$1.local.name !== s$1.exported.name) {
				state$1.commands.push(" as ");
				handle(s$1.exported, state$1);
			}
		});
		state.commands.push("}");
		if (node.source) {
			state.commands.push(" from ");
			handle(node.source, state);
		}
		state.commands.push(";");
	},
	ExpressionStatement(node, state) {
		if (node.expression.type === "ObjectExpression" || node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern" || node.expression.type === "FunctionExpression") {
			state.commands.push("(");
			handle(node.expression, state);
			state.commands.push(");");
			return;
		}
		handle(node.expression, state);
		state.commands.push(";");
	},
	ForStatement: (node, state) => {
		state.commands.push("for (");
		if (node.init) if (node.init.type === "VariableDeclaration") handle_var_declaration(node.init, state);
else handle(node.init, state);
		state.commands.push("; ");
		if (node.test) handle(node.test, state);
		state.commands.push("; ");
		if (node.update) handle(node.update, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	ForInStatement: shared["ForInStatement|ForOfStatement"],
	ForOfStatement: shared["ForInStatement|ForOfStatement"],
	FunctionDeclaration: shared["FunctionDeclaration|FunctionExpression"],
	FunctionExpression: shared["FunctionDeclaration|FunctionExpression"],
	Identifier(node, state) {
		let name = node.name;
		state.commands.push(c(name, node));
		if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
	},
	IfStatement(node, state) {
		state.commands.push("if (");
		handle(node.test, state);
		state.commands.push(") ");
		handle(node.consequent, state);
		if (node.alternate) {
			state.commands.push(" else ");
			handle(node.alternate, state);
		}
	},
	ImportDeclaration(node, state) {
		if (node.specifiers.length === 0) {
			state.commands.push("import ");
			handle(node.source, state);
			state.commands.push(";");
			return;
		}
		/** @type {TSESTree.ImportNamespaceSpecifier | null} */
		let namespace_specifier = null;
		/** @type {TSESTree.ImportDefaultSpecifier | null} */
		let default_specifier = null;
		/** @type {TSESTree.ImportSpecifier[]} */
		const named_specifiers = [];
		for (const s$1 of node.specifiers) if (s$1.type === "ImportNamespaceSpecifier") namespace_specifier = s$1;
else if (s$1.type === "ImportDefaultSpecifier") default_specifier = s$1;
else named_specifiers.push(s$1);
		state.commands.push("import ");
		if (node.importKind == "type") state.commands.push("type ");
		if (default_specifier) {
			state.commands.push(c(default_specifier.local.name, default_specifier));
			if (namespace_specifier || named_specifiers.length > 0) state.commands.push(", ");
		}
		if (namespace_specifier) state.commands.push(c("* as " + namespace_specifier.local.name, namespace_specifier));
		if (named_specifiers.length > 0) {
			state.commands.push("{");
			sequence(named_specifiers, state, true, (s$1, state$1) => {
				if (s$1.local.name !== s$1.imported.name) {
					handle(s$1.imported, state$1);
					state$1.commands.push(" as ");
				}
				if (s$1.importKind == "type") state$1.commands.push("type ");
				handle(s$1.local, state$1);
			});
			state.commands.push("}");
		}
		state.commands.push(" from ");
		handle(node.source, state);
		state.commands.push(";");
	},
	ImportExpression(node, state) {
		state.commands.push("import(");
		handle(node.source, state);
		state.commands.push(")");
	},
	LabeledStatement(node, state) {
		handle(node.label, state);
		state.commands.push(": ");
		handle(node.body, state);
	},
	Literal(node, state) {
		const value = node.raw || (typeof node.value === "string" ? quote(node.value, state.quote) : String(node.value));
		state.commands.push(c(value, node));
	},
	LogicalExpression: shared["BinaryExpression|LogicalExpression"],
	MemberExpression(node, state) {
		if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
			state.commands.push("(");
			handle(node.object, state);
			state.commands.push(")");
		} else handle(node.object, state);
		if (node.computed) {
			if (node.optional) state.commands.push("?.");
			state.commands.push("[");
			handle(node.property, state);
			state.commands.push("]");
		} else {
			state.commands.push(node.optional ? "?." : ".");
			handle(node.property, state);
		}
	},
	MetaProperty(node, state) {
		handle(node.meta, state);
		state.commands.push(".");
		handle(node.property, state);
	},
	MethodDefinition(node, state) {
		if (node.decorators) for (const decorator of node.decorators) handle(decorator, state);
		if (node.static) state.commands.push("static ");
		if (node.kind === "get" || node.kind === "set") state.commands.push(node.kind + " ");
		if (node.value.async) state.commands.push("async ");
		if (node.value.generator) state.commands.push("*");
		if (node.computed) state.commands.push("[");
		handle(node.key, state);
		if (node.computed) state.commands.push("]");
		state.commands.push("(");
		sequence(node.value.params, state, false, handle);
		state.commands.push(") ");
		if (node.value.body) handle(node.value.body, state);
	},
	NewExpression: shared["CallExpression|NewExpression"],
	ObjectExpression(node, state) {
		state.commands.push("{");
		sequence(node.properties, state, true, (p$1, state$1) => {
			if (p$1.type === "Property" && p$1.value.type === "FunctionExpression") {
				const fn = p$1.value;
				if (p$1.kind === "get" || p$1.kind === "set") state$1.commands.push(p$1.kind + " ");
else {
					if (fn.async) state$1.commands.push("async ");
					if (fn.generator) state$1.commands.push("*");
				}
				if (p$1.computed) state$1.commands.push("[");
				handle(p$1.key, state$1);
				if (p$1.computed) state$1.commands.push("]");
				state$1.commands.push("(");
				sequence(fn.params, state$1, false, handle);
				state$1.commands.push(") ");
				handle(fn.body, state$1);
			} else handle(p$1, state$1);
		});
		state.commands.push("}");
	},
	ObjectPattern(node, state) {
		state.commands.push("{");
		sequence(node.properties, state, true, handle);
		state.commands.push("}");
		if (node.typeAnnotation) handle_type_annotation(node.typeAnnotation, state);
	},
	ParenthesizedExpression(node, state) {
		return handle(node.expression, state);
	},
	PrivateIdentifier(node, state) {
		state.commands.push("#", c(node.name, node));
	},
	Program(node, state) {
		handle_body(node.body, state);
	},
	Property(node, state) {
		const value = node.value.type === "AssignmentPattern" ? node.value.left : node.value;
		const shorthand = !node.computed && node.kind === "init" && node.key.type === "Identifier" && value.type === "Identifier" && node.key.name === value.name;
		if (shorthand) {
			handle(node.value, state);
			return;
		}
		if (node.computed) state.commands.push("[");
		handle(node.key, state);
		state.commands.push(node.computed ? "]: " : ": ");
		handle(node.value, state);
	},
	PropertyDefinition(node, state) {
		if (node.accessibility) state.commands.push(node.accessibility, " ");
		if (node.static) state.commands.push("static ");
		if (node.computed) {
			state.commands.push("[");
			handle(node.key, state);
			state.commands.push("]");
		} else handle(node.key, state);
		if (node.typeAnnotation) {
			state.commands.push(": ");
			handle_type_annotation(node.typeAnnotation.typeAnnotation, state);
		}
		if (node.value) {
			state.commands.push(" = ");
			handle(node.value, state);
		}
		state.commands.push(";");
	},
	RestElement: shared["RestElement|SpreadElement"],
	ReturnStatement(node, state) {
		if (node.argument) {
			const argumentWithComment = node.argument;
			const contains_comment = argumentWithComment.leadingComments && argumentWithComment.leadingComments.some((comment$1) => comment$1.type === "Line");
			state.commands.push(contains_comment ? "return (" : "return ");
			handle(node.argument, state);
			state.commands.push(contains_comment ? ");" : ";");
		} else state.commands.push("return;");
	},
	SequenceExpression(node, state) {
		state.commands.push("(");
		sequence(node.expressions, state, false, handle);
		state.commands.push(")");
	},
	SpreadElement: shared["RestElement|SpreadElement"],
	StaticBlock(node, state) {
		state.commands.push(indent$1, "static {", newline);
		handle_body(node.body, state);
		state.commands.push(dedent, newline, "}");
	},
	Super(node, state) {
		state.commands.push(c("super", node));
	},
	SwitchStatement(node, state) {
		state.commands.push("switch (");
		handle(node.discriminant, state);
		state.commands.push(") {", indent$1);
		let first = true;
		for (const block$1 of node.cases) {
			if (!first) state.commands.push("\n");
			first = false;
			if (block$1.test) {
				state.commands.push(newline, `case `);
				handle(block$1.test, state);
				state.commands.push(":");
			} else state.commands.push(newline, `default:`);
			state.commands.push(indent$1);
			for (const statement of block$1.consequent) {
				state.commands.push(newline);
				handle(statement, state);
			}
			state.commands.push(dedent);
		}
		state.commands.push(dedent, newline, `}`);
	},
	TaggedTemplateExpression(node, state) {
		handle(node.tag, state);
		handle(node.quasi, state);
	},
	TemplateLiteral(node, state) {
		state.commands.push("`");
		const { quasis, expressions } = node;
		for (let i$1 = 0; i$1 < expressions.length; i$1++) {
			const raw$1 = quasis[i$1].value.raw;
			state.commands.push(raw$1, "\${");
			handle(expressions[i$1], state);
			state.commands.push("}");
			if (/\n/.test(raw$1)) state.multiline = true;
		}
		const raw = quasis[quasis.length - 1].value.raw;
		state.commands.push(raw, "`");
		if (/\n/.test(raw)) state.multiline = true;
	},
	ThisExpression(node, state) {
		state.commands.push(c("this", node));
	},
	ThrowStatement(node, state) {
		state.commands.push("throw ");
		if (node.argument) handle(node.argument, state);
		state.commands.push(";");
	},
	TryStatement(node, state) {
		state.commands.push("try ");
		handle(node.block, state);
		if (node.handler) {
			if (node.handler.param) {
				state.commands.push(" catch(");
				handle(node.handler.param, state);
				state.commands.push(") ");
			} else state.commands.push(" catch ");
			handle(node.handler.body, state);
		}
		if (node.finalizer) {
			state.commands.push(" finally ");
			handle(node.finalizer, state);
		}
	},
	TSAsExpression(node, state) {
		if (node.expression) {
			const needs_parens$1 = EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSAsExpression;
			if (needs_parens$1) {
				state.commands.push("(");
				handle(node.expression, state);
				state.commands.push(")");
			} else handle(node.expression, state);
		}
		state.commands.push(" as ");
		handle_type_annotation(node.typeAnnotation, state);
	},
	TSEnumDeclaration(node, state) {
		state.commands.push("enum ");
		handle(node.id, state);
		state.commands.push(" {", indent$1, newline);
		sequence(node.members, state, false, handle_type_annotation);
		state.commands.push(dedent, newline, "}", newline);
	},
	TSModuleBlock(node, state) {
		state.commands.push(" {", indent$1, newline);
		handle_body(node.body, state);
		state.commands.push(dedent, newline, "}");
	},
	TSModuleDeclaration(node, state) {
		if (node.declare) state.commands.push("declare ");
else state.commands.push("namespace ");
		handle(node.id, state);
		if (!node.body) return;
		handle(node.body, state);
	},
	TSNonNullExpression(node, state) {
		handle(node.expression, state);
		state.commands.push("!");
	},
	TSInterfaceBody(node, state) {
		sequence(node.body, state, true, handle_type_annotation, ";");
	},
	TSInterfaceDeclaration(node, state) {
		state.commands.push("interface ");
		handle(node.id, state);
		if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
		if (node.extends) {
			state.commands.push(" extends ");
			sequence(node.extends, state, false, handle_type_annotation);
		}
		state.commands.push(" {");
		handle(node.body, state);
		state.commands.push("}");
	},
	TSSatisfiesExpression(node, state) {
		if (node.expression) {
			const needs_parens$1 = EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSSatisfiesExpression;
			if (needs_parens$1) {
				state.commands.push("(");
				handle(node.expression, state);
				state.commands.push(")");
			} else handle(node.expression, state);
		}
		state.commands.push(" satisfies ");
		handle_type_annotation(node.typeAnnotation, state);
	},
	TSTypeAliasDeclaration(node, state) {
		state.commands.push("type ");
		handle(node.id, state);
		if (node.typeParameters) handle_type_annotation(node.typeParameters, state);
		state.commands.push(" = ");
		handle_type_annotation(node.typeAnnotation, state);
		state.commands.push(";");
	},
	TSQualifiedName(node, state) {
		handle(node.left, state);
		state.commands.push(".");
		handle(node.right, state);
	},
	UnaryExpression(node, state) {
		state.commands.push(node.operator);
		if (node.operator.length > 1) state.commands.push(" ");
		if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
			state.commands.push("(");
			handle(node.argument, state);
			state.commands.push(")");
		} else handle(node.argument, state);
	},
	UpdateExpression(node, state) {
		if (node.prefix) {
			state.commands.push(node.operator);
			handle(node.argument, state);
		} else {
			handle(node.argument, state);
			state.commands.push(node.operator);
		}
	},
	VariableDeclaration(node, state) {
		handle_var_declaration(node, state);
		state.commands.push(";");
	},
	VariableDeclarator(node, state) {
		handle(node.id, state);
		if (node.init) {
			state.commands.push(" = ");
			handle(node.init, state);
		}
	},
	WhileStatement(node, state) {
		state.commands.push("while (");
		handle(node.test, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	WithStatement(node, state) {
		state.commands.push("with (");
		handle(node.object, state);
		state.commands.push(") ");
		handle(node.body, state);
	},
	YieldExpression(node, state) {
		if (node.argument) {
			state.commands.push(node.delegate ? `yield* ` : `yield `);
			handle(node.argument, state);
		} else state.commands.push(node.delegate ? `yield*` : `yield`);
	}
};
const comma = ",".charCodeAt(0);
const semicolon = ";".charCodeAt(0);
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar = new Uint8Array(64);
const charToInt = new Uint8Array(128);
for (let i$1 = 0; i$1 < chars.length; i$1++) {
	const c$1 = chars.charCodeAt(i$1);
	intToChar[i$1] = c$1;
	charToInt[c$1] = i$1;
}
function encodeInteger(builder, num, relative$2) {
	let delta = num - relative$2;
	delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
	do {
		let clamped = delta & 31;
		delta >>>= 5;
		if (delta > 0) clamped |= 32;
		builder.write(intToChar[clamped]);
	} while (delta > 0);
	return num;
}
const bufLength = 16384;
const td = typeof TextDecoder !== "undefined" ? /* #__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? { decode(buf) {
	const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
	return out.toString();
} } : { decode(buf) {
	let out = "";
	for (let i$1 = 0; i$1 < buf.length; i$1++) out += String.fromCharCode(buf[i$1]);
	return out;
} };
var StringWriter = class {
	constructor() {
		this.pos = 0;
		this.out = "";
		this.buffer = new Uint8Array(bufLength);
	}
	write(v) {
		const { buffer } = this;
		buffer[this.pos++] = v;
		if (this.pos === bufLength) {
			this.out += td.decode(buffer);
			this.pos = 0;
		}
	}
	flush() {
		const { buffer, out, pos } = this;
		return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
	}
};
function encode(decoded) {
	const writer = new StringWriter();
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	for (let i$1 = 0; i$1 < decoded.length; i$1++) {
		const line = decoded[i$1];
		if (i$1 > 0) writer.write(semicolon);
		if (line.length === 0) continue;
		let genColumn = 0;
		for (let j = 0; j < line.length; j++) {
			const segment = line[j];
			if (j > 0) writer.write(comma);
			genColumn = encodeInteger(writer, segment[0], genColumn);
			if (segment.length === 1) continue;
			sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
			sourceLine = encodeInteger(writer, segment[2], sourceLine);
			sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
			if (segment.length === 4) continue;
			namesIndex = encodeInteger(writer, segment[4], namesIndex);
		}
	}
	return writer.flush();
}
/** @type {(str: string) => string} str */
let btoa$1 = () => {
	throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") btoa$1 = (str) => window.btoa(unescape(encodeURIComponent(str)));
else if (typeof Buffer === "function") btoa$1 = (str) => Buffer.from(str, "utf-8").toString("base64");
function print(node, opts = {}) {
	if (Array.isArray(node)) return print({
		type: "Program",
		body: node,
		sourceType: "module"
	}, opts);
	/** @type {State} */
	const state = {
		commands: [],
		comments: [],
		multiline: false,
		quote: opts.quotes === "double" ? "\"" : "'"
	};
	handle(node, state);
	/** @typedef {[number, number, number, number]} Segment */
	let code = "";
	let current_column = 0;
	/** @type {Segment[][]} */
	let mappings = [];
	/** @type {Segment[]} */
	let current_line = [];
	/** @param {string} str */
	function append(str) {
		code += str;
		for (let i$1 = 0; i$1 < str.length; i$1 += 1) if (str[i$1] === "\n") {
			mappings.push(current_line);
			current_line = [];
			current_column = 0;
		} else current_column += 1;
	}
	let newline$1 = "\n";
	const indent$1$1 = opts.indent ?? "	";
	/** @param {Command} command */
	function run(command) {
		if (typeof command === "string") {
			append(command);
			return;
		}
		if (Array.isArray(command)) {
			for (let i$1 = 0; i$1 < command.length; i$1 += 1) run(command[i$1]);
			return;
		}
		switch (command.type) {
			case "Location":
				current_line.push([
					current_column,
					0,
					command.line - 1,
					command.column
				]);
				break;
			case "Newline":
				append(newline$1);
				break;
			case "Indent":
				newline$1 += indent$1$1;
				break;
			case "Dedent":
				newline$1 = newline$1.slice(0, -indent$1$1.length);
				break;
			case "Comment":
				if (command.comment.type === "Line") append(`//${command.comment.value}`);
else append(`/*${command.comment.value.replace(/\n/g, newline$1)}*/`);
				break;
		}
	}
	for (let i$1 = 0; i$1 < state.commands.length; i$1 += 1) run(state.commands[i$1]);
	mappings.push(current_line);
	const map = {
		version: 3,
		names: [],
		sources: [opts.sourceMapSource || null],
		sourcesContent: [opts.sourceMapContent || null],
		mappings: opts.sourceMapEncodeMappings == undefined || opts.sourceMapEncodeMappings ? encode(mappings) : mappings
	};
	Object.defineProperties(map, {
		toString: {
			enumerable: false,
			value: function toString$1$1() {
				return JSON.stringify(this);
			}
		},
		toUrl: {
			enumerable: false,
			value: function toUrl() {
				return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
			}
		}
	});
	return {
		code,
		map
	};
}
var acorn_exports = {};
__export(acorn_exports, {
	Node: () => Node,
	Parser: () => Parser,
	Position: () => Position,
	SourceLocation: () => SourceLocation,
	TokContext: () => TokContext,
	Token: () => Token,
	TokenType: () => TokenType,
	defaultOptions: () => defaultOptions,
	getLineInfo: () => getLineInfo,
	isIdentifierChar: () => isIdentifierChar,
	isIdentifierStart: () => isIdentifierStart,
	isNewLine: () => isNewLine,
	keywordTypes: () => keywords,
	lineBreak: () => lineBreak,
	lineBreakG: () => lineBreakG,
	nonASCIIwhitespace: () => nonASCIIwhitespace,
	parse: () => parse,
	parseExpressionAt: () => parseExpressionAt,
	tokContexts: () => types,
	tokTypes: () => types$1,
	tokenizer: () => tokenizer,
	version: () => version
});
var astralIdentifierCodes = [
	509,
	0,
	227,
	0,
	150,
	4,
	294,
	9,
	1368,
	2,
	2,
	1,
	6,
	3,
	41,
	2,
	5,
	0,
	166,
	1,
	574,
	3,
	9,
	9,
	7,
	9,
	32,
	4,
	318,
	1,
	80,
	3,
	71,
	10,
	50,
	3,
	123,
	2,
	54,
	14,
	32,
	10,
	3,
	1,
	11,
	3,
	46,
	10,
	8,
	0,
	46,
	9,
	7,
	2,
	37,
	13,
	2,
	9,
	6,
	1,
	45,
	0,
	13,
	2,
	49,
	13,
	9,
	3,
	2,
	11,
	83,
	11,
	7,
	0,
	3,
	0,
	158,
	11,
	6,
	9,
	7,
	3,
	56,
	1,
	2,
	6,
	3,
	1,
	3,
	2,
	10,
	0,
	11,
	1,
	3,
	6,
	4,
	4,
	68,
	8,
	2,
	0,
	3,
	0,
	2,
	3,
	2,
	4,
	2,
	0,
	15,
	1,
	83,
	17,
	10,
	9,
	5,
	0,
	82,
	19,
	13,
	9,
	214,
	6,
	3,
	8,
	28,
	1,
	83,
	16,
	16,
	9,
	82,
	12,
	9,
	9,
	7,
	19,
	58,
	14,
	5,
	9,
	243,
	14,
	166,
	9,
	71,
	5,
	2,
	1,
	3,
	3,
	2,
	0,
	2,
	1,
	13,
	9,
	120,
	6,
	3,
	6,
	4,
	0,
	29,
	9,
	41,
	6,
	2,
	3,
	9,
	0,
	10,
	10,
	47,
	15,
	343,
	9,
	54,
	7,
	2,
	7,
	17,
	9,
	57,
	21,
	2,
	13,
	123,
	5,
	4,
	0,
	2,
	1,
	2,
	6,
	2,
	0,
	9,
	9,
	49,
	4,
	2,
	1,
	2,
	4,
	9,
	9,
	330,
	3,
	10,
	1,
	2,
	0,
	49,
	6,
	4,
	4,
	14,
	10,
	5350,
	0,
	7,
	14,
	11465,
	27,
	2343,
	9,
	87,
	9,
	39,
	4,
	60,
	6,
	26,
	9,
	535,
	9,
	470,
	0,
	2,
	54,
	8,
	3,
	82,
	0,
	12,
	1,
	19628,
	1,
	4178,
	9,
	519,
	45,
	3,
	22,
	543,
	4,
	4,
	5,
	9,
	7,
	3,
	6,
	31,
	3,
	149,
	2,
	1418,
	49,
	513,
	54,
	5,
	49,
	9,
	0,
	15,
	0,
	23,
	4,
	2,
	14,
	1361,
	6,
	2,
	16,
	3,
	6,
	2,
	1,
	2,
	4,
	101,
	0,
	161,
	6,
	10,
	9,
	357,
	0,
	62,
	13,
	499,
	13,
	245,
	1,
	2,
	9,
	726,
	6,
	110,
	6,
	6,
	9,
	4759,
	9,
	787719,
	239
];
var astralIdentifierStartCodes = [
	0,
	11,
	2,
	25,
	2,
	18,
	2,
	1,
	2,
	14,
	3,
	13,
	35,
	122,
	70,
	52,
	268,
	28,
	4,
	48,
	48,
	31,
	14,
	29,
	6,
	37,
	11,
	29,
	3,
	35,
	5,
	7,
	2,
	4,
	43,
	157,
	19,
	35,
	5,
	35,
	5,
	39,
	9,
	51,
	13,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	2,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	4,
	51,
	13,
	310,
	10,
	21,
	11,
	7,
	25,
	5,
	2,
	41,
	2,
	8,
	70,
	5,
	3,
	0,
	2,
	43,
	2,
	1,
	4,
	0,
	3,
	22,
	11,
	22,
	10,
	30,
	66,
	18,
	2,
	1,
	11,
	21,
	11,
	25,
	71,
	55,
	7,
	1,
	65,
	0,
	16,
	3,
	2,
	2,
	2,
	28,
	43,
	28,
	4,
	28,
	36,
	7,
	2,
	27,
	28,
	53,
	11,
	21,
	11,
	18,
	14,
	17,
	111,
	72,
	56,
	50,
	14,
	50,
	14,
	35,
	39,
	27,
	10,
	22,
	251,
	41,
	7,
	1,
	17,
	2,
	60,
	28,
	11,
	0,
	9,
	21,
	43,
	17,
	47,
	20,
	28,
	22,
	13,
	52,
	58,
	1,
	3,
	0,
	14,
	44,
	33,
	24,
	27,
	35,
	30,
	0,
	3,
	0,
	9,
	34,
	4,
	0,
	13,
	47,
	15,
	3,
	22,
	0,
	2,
	0,
	36,
	17,
	2,
	24,
	20,
	1,
	64,
	6,
	2,
	0,
	2,
	3,
	2,
	14,
	2,
	9,
	8,
	46,
	39,
	7,
	3,
	1,
	3,
	21,
	2,
	6,
	2,
	1,
	2,
	4,
	4,
	0,
	19,
	0,
	13,
	4,
	31,
	9,
	2,
	0,
	3,
	0,
	2,
	37,
	2,
	0,
	26,
	0,
	2,
	0,
	45,
	52,
	19,
	3,
	21,
	2,
	31,
	47,
	21,
	1,
	2,
	0,
	185,
	46,
	42,
	3,
	37,
	47,
	21,
	0,
	60,
	42,
	14,
	0,
	72,
	26,
	38,
	6,
	186,
	43,
	117,
	63,
	32,
	7,
	3,
	0,
	3,
	7,
	2,
	1,
	2,
	23,
	16,
	0,
	2,
	0,
	95,
	7,
	3,
	38,
	17,
	0,
	2,
	0,
	29,
	0,
	11,
	39,
	8,
	0,
	22,
	0,
	12,
	45,
	20,
	0,
	19,
	72,
	200,
	32,
	32,
	8,
	2,
	36,
	18,
	0,
	50,
	29,
	113,
	6,
	2,
	1,
	2,
	37,
	22,
	0,
	26,
	5,
	2,
	1,
	2,
	31,
	15,
	0,
	328,
	18,
	16,
	0,
	2,
	12,
	2,
	33,
	125,
	0,
	80,
	921,
	103,
	110,
	18,
	195,
	2637,
	96,
	16,
	1071,
	18,
	5,
	26,
	3994,
	6,
	582,
	6842,
	29,
	1763,
	568,
	8,
	30,
	18,
	78,
	18,
	29,
	19,
	47,
	17,
	3,
	32,
	20,
	6,
	18,
	433,
	44,
	212,
	63,
	129,
	74,
	6,
	0,
	67,
	12,
	65,
	1,
	2,
	0,
	29,
	6135,
	9,
	1237,
	42,
	9,
	8936,
	3,
	2,
	6,
	2,
	1,
	2,
	290,
	16,
	0,
	30,
	2,
	3,
	0,
	15,
	3,
	9,
	395,
	2309,
	106,
	6,
	12,
	4,
	8,
	8,
	9,
	5991,
	84,
	2,
	70,
	2,
	1,
	3,
	0,
	3,
	1,
	3,
	3,
	2,
	11,
	2,
	0,
	2,
	6,
	2,
	64,
	2,
	3,
	3,
	7,
	2,
	6,
	2,
	27,
	2,
	3,
	2,
	4,
	2,
	0,
	4,
	6,
	2,
	339,
	3,
	24,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	7,
	1845,
	30,
	7,
	5,
	262,
	61,
	147,
	44,
	11,
	6,
	17,
	0,
	322,
	29,
	19,
	43,
	485,
	27,
	229,
	29,
	3,
	0,
	496,
	6,
	2,
	3,
	2,
	1,
	2,
	14,
	2,
	196,
	60,
	67,
	8,
	0,
	1205,
	3,
	2,
	26,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	9,
	2,
	3,
	2,
	0,
	2,
	0,
	7,
	0,
	5,
	0,
	2,
	0,
	2,
	0,
	2,
	2,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	1,
	2,
	0,
	3,
	3,
	2,
	6,
	2,
	3,
	2,
	3,
	2,
	0,
	2,
	9,
	2,
	16,
	6,
	2,
	2,
	4,
	2,
	16,
	4421,
	42719,
	33,
	4153,
	7,
	221,
	3,
	5761,
	15,
	7472,
	16,
	621,
	2467,
	541,
	1507,
	4938,
	6,
	4191
];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
	3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	5: "class enum extends super const export import",
	6: "enum",
	strict: "implements interface let package private protected public static yield",
	strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
	5: ecma5AndLessKeywords,
	"5module": ecma5AndLessKeywords + " export import",
	6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
	var pos = 65536;
	for (var i$1 = 0; i$1 < set.length; i$1 += 2) {
		pos += set[i$1];
		if (pos > code) return false;
		pos += set[i$1 + 1];
		if (pos >= code) return true;
	}
	return false;
}
function isIdentifierStart(code, astral) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType$1(label, conf) {
	if (conf === void 0) conf = {};
	this.label = label;
	this.keyword = conf.keyword;
	this.beforeExpr = !!conf.beforeExpr;
	this.startsExpr = !!conf.startsExpr;
	this.isLoop = !!conf.isLoop;
	this.isAssign = !!conf.isAssign;
	this.prefix = !!conf.prefix;
	this.postfix = !!conf.postfix;
	this.binop = conf.binop || null;
	this.updateContext = null;
};
function binop(name, prec) {
	return new TokenType(name, {
		beforeExpr: true,
		binop: prec
	});
}
var beforeExpr = { beforeExpr: true }, startsExpr$1 = { startsExpr: true };
var keywords = {};
function kw(name, options) {
	if (options === void 0) options = {};
	options.keyword = name;
	return keywords[name] = new TokenType(name, options);
}
var types$1 = {
	num: new TokenType("num", startsExpr$1),
	regexp: new TokenType("regexp", startsExpr$1),
	string: new TokenType("string", startsExpr$1),
	name: new TokenType("name", startsExpr$1),
	privateId: new TokenType("privateId", startsExpr$1),
	eof: new TokenType("eof"),
	bracketL: new TokenType("[", {
		beforeExpr: true,
		startsExpr: true
	}),
	bracketR: new TokenType("]"),
	braceL: new TokenType("{", {
		beforeExpr: true,
		startsExpr: true
	}),
	braceR: new TokenType("}"),
	parenL: new TokenType("(", {
		beforeExpr: true,
		startsExpr: true
	}),
	parenR: new TokenType(")"),
	comma: new TokenType(",", beforeExpr),
	semi: new TokenType(";", beforeExpr),
	colon: new TokenType(":", beforeExpr),
	dot: new TokenType("."),
	question: new TokenType("?", beforeExpr),
	questionDot: new TokenType("?."),
	arrow: new TokenType("=>", beforeExpr),
	template: new TokenType("template"),
	invalidTemplate: new TokenType("invalidTemplate"),
	ellipsis: new TokenType("...", beforeExpr),
	backQuote: new TokenType("`", startsExpr$1),
	dollarBraceL: new TokenType("\${", {
		beforeExpr: true,
		startsExpr: true
	}),
	eq: new TokenType("=", {
		beforeExpr: true,
		isAssign: true
	}),
	assign: new TokenType("_=", {
		beforeExpr: true,
		isAssign: true
	}),
	incDec: new TokenType("++/--", {
		prefix: true,
		postfix: true,
		startsExpr: true
	}),
	prefix: new TokenType("!/~", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	logicalOR: binop("||", 1),
	logicalAND: binop("&&", 2),
	bitwiseOR: binop("|", 3),
	bitwiseXOR: binop("^", 4),
	bitwiseAND: binop("&", 5),
	equality: binop("==/!=/===/!==", 6),
	relational: binop("</>/<=/>=", 7),
	bitShift: binop("<</>>/>>>", 8),
	plusMin: new TokenType("+/-", {
		beforeExpr: true,
		binop: 9,
		prefix: true,
		startsExpr: true
	}),
	modulo: binop("%", 10),
	star: binop("*", 10),
	slash: binop("/", 10),
	starstar: new TokenType("**", { beforeExpr: true }),
	coalesce: binop("??", 1),
	_break: kw("break"),
	_case: kw("case", beforeExpr),
	_catch: kw("catch"),
	_continue: kw("continue"),
	_debugger: kw("debugger"),
	_default: kw("default", beforeExpr),
	_do: kw("do", {
		isLoop: true,
		beforeExpr: true
	}),
	_else: kw("else", beforeExpr),
	_finally: kw("finally"),
	_for: kw("for", { isLoop: true }),
	_function: kw("function", startsExpr$1),
	_if: kw("if"),
	_return: kw("return", beforeExpr),
	_switch: kw("switch"),
	_throw: kw("throw", beforeExpr),
	_try: kw("try"),
	_var: kw("var"),
	_const: kw("const"),
	_while: kw("while", { isLoop: true }),
	_with: kw("with"),
	_new: kw("new", {
		beforeExpr: true,
		startsExpr: true
	}),
	_this: kw("this", startsExpr$1),
	_super: kw("super", startsExpr$1),
	_class: kw("class", startsExpr$1),
	_extends: kw("extends", beforeExpr),
	_export: kw("export"),
	_import: kw("import", startsExpr$1),
	_null: kw("null", startsExpr$1),
	_true: kw("true", startsExpr$1),
	_false: kw("false", startsExpr$1),
	_in: kw("in", {
		beforeExpr: true,
		binop: 7
	}),
	_instanceof: kw("instanceof", {
		beforeExpr: true,
		binop: 7
	}),
	_typeof: kw("typeof", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_void: kw("void", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_delete: kw("delete", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	})
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
	return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from$1, end) {
	if (end === void 0) end = code.length;
	for (var i$1 = from$1; i$1 < end; i$1++) {
		var next = code.charCodeAt(i$1);
		if (isNewLine(next)) return i$1 < end - 1 && next === 13 && code.charCodeAt(i$1 + 1) === 10 ? i$1 + 2 : i$1 + 1;
	}
	return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace$1 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
	return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
	return toString$1.call(obj) === "[object Array]";
};
var regexpCache = Object.create(null);
function wordsRegexp(words) {
	return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
	if (code <= 65535) return String.fromCharCode(code);
	code -= 65536;
	return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position$1(line, col) {
	this.line = line;
	this.column = col;
};
Position.prototype.offset = function offset(n$1) {
	return new Position(this.line, this.column + n$1);
};
var SourceLocation = function SourceLocation$1(p$1, start, end) {
	this.start = start;
	this.end = end;
	if (p$1.sourceFile !== null) this.source = p$1.sourceFile;
};
function getLineInfo(input, offset) {
	for (var line = 1, cur = 0;;) {
		var nextBreak = nextLineBreak(input, cur, offset);
		if (nextBreak < 0) return new Position(line, offset - cur);
		++line;
		cur = nextBreak;
	}
}
var defaultOptions = {
	ecmaVersion: null,
	sourceType: "script",
	onInsertedSemicolon: null,
	onTrailingComma: null,
	allowReserved: null,
	allowReturnOutsideFunction: false,
	allowImportExportEverywhere: false,
	allowAwaitOutsideFunction: null,
	allowSuperOutsideMethod: null,
	allowHashBang: false,
	checkPrivateFields: true,
	locations: false,
	onToken: null,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null,
	preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
	var options = {};
	for (var opt in defaultOptions) options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
	if (options.ecmaVersion === "latest") options.ecmaVersion = 1e8;
else if (options.ecmaVersion == null) {
		if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
			warnedAboutEcmaVersion = true;
			console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		}
		options.ecmaVersion = 11;
	} else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
	if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
	if (!opts || opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;
	if (isArray(options.onToken)) {
		var tokens = options.onToken;
		options.onToken = function(token) {
			return tokens.push(token);
		};
	}
	if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
	return options;
}
function pushComment(options, array) {
	return function(block$1, text$1, start, end, startLoc, endLoc) {
		var comment$1 = {
			type: block$1 ? "Block" : "Line",
			value: text$1,
			start,
			end
		};
		if (options.locations) comment$1.loc = new SourceLocation(this, startLoc, endLoc);
		if (options.ranges) comment$1.range = [start, end];
		array.push(comment$1);
	};
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags$1(async, generator) {
	return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE$1 = 0, BIND_VAR$1 = 1, BIND_LEXICAL$1 = 2, BIND_FUNCTION$1 = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE$1 = 5;
var Parser = function Parser$4(options, input, startPos) {
	this.options = options = getOptions(options);
	this.sourceFile = options.sourceFile;
	this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
	var reserved = "";
	if (options.allowReserved !== true) {
		reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		if (options.sourceType === "module") reserved += " await";
	}
	this.reservedWords = wordsRegexp(reserved);
	var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
	this.reservedWordsStrict = wordsRegexp(reservedStrict);
	this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
	this.input = String(input);
	this.containsEsc = false;
	if (startPos) {
		this.pos = startPos;
		this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	} else {
		this.pos = this.lineStart = 0;
		this.curLine = 1;
	}
	this.type = types$1.eof;
	this.value = null;
	this.start = this.end = this.pos;
	this.startLoc = this.endLoc = this.curPosition();
	this.lastTokEndLoc = this.lastTokStartLoc = null;
	this.lastTokStart = this.lastTokEnd = this.pos;
	this.context = this.initialContext();
	this.exprAllowed = true;
	this.inModule = options.sourceType === "module";
	this.strict = this.inModule || this.strictDirective(this.pos);
	this.potentialArrowAt = -1;
	this.potentialArrowInForAwait = false;
	this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
	this.labels = [];
	this.undefinedExports = Object.create(null);
	if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
	this.scopeStack = [];
	this.enterScope(SCOPE_TOP);
	this.regexpState = null;
	this.privateNameStack = [];
};
var prototypeAccessors = {
	inFunction: { configurable: true },
	inGenerator: { configurable: true },
	inAsync: { configurable: true },
	canAwait: { configurable: true },
	allowSuper: { configurable: true },
	allowDirectSuper: { configurable: true },
	treatFunctionsAsVar: { configurable: true },
	allowNewDotTarget: { configurable: true },
	inClassStaticBlock: { configurable: true }
};
Parser.prototype.parse = function parse$7() {
	var node = this.options.program || this.startNode();
	this.nextToken();
	return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
	return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
	return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
	return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
	for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
		var ref$1 = this.scopeStack[i$1];
		var flags = ref$1.flags;
		if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) return false;
		if (flags & SCOPE_FUNCTION) return (flags & SCOPE_ASYNC) > 0;
	}
	return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
	var ref$1 = this.currentThisScope();
	var flags = ref$1.flags;
	return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
	return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
	return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
	for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
		var ref$1 = this.scopeStack[i$1];
		var flags = ref$1.flags;
		if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) return true;
	}
	return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
	return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
	var plugins = [], len = arguments.length;
	while (len--) plugins[len] = arguments[len];
	var cls = this;
	for (var i$1 = 0; i$1 < plugins.length; i$1++) cls = plugins[i$1](cls);
	return cls;
};
Parser.parse = function parse$7(input, options) {
	return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt$1(input, pos, options) {
	var parser = new this(options, input, pos);
	parser.nextToken();
	return parser.parseExpression();
};
Parser.tokenizer = function tokenizer$3(input, options) {
	return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
	if (this.options.ecmaVersion < 5) return false;
	for (;;) {
		skipWhiteSpace$1.lastIndex = start;
		start += skipWhiteSpace$1.exec(this.input)[0].length;
		var match = literal.exec(this.input.slice(start));
		if (!match) return false;
		if ((match[1] || match[2]) === "use strict") {
			skipWhiteSpace$1.lastIndex = start + match[0].length;
			var spaceAfter = skipWhiteSpace$1.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
			var next = this.input.charAt(end);
			return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
		}
		start += match[0].length;
		skipWhiteSpace$1.lastIndex = start;
		start += skipWhiteSpace$1.exec(this.input)[0].length;
		if (this.input[start] === ";") start++;
	}
};
pp$9.eat = function(type) {
	if (this.type === type) {
		this.next();
		return true;
	} else return false;
};
pp$9.isContextual = function(name) {
	return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
	if (!this.isContextual(name)) return false;
	this.next();
	return true;
};
pp$9.expectContextual = function(name) {
	if (!this.eatContextual(name)) this.unexpected();
};
pp$9.canInsertSemicolon = function() {
	return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
	if (this.canInsertSemicolon()) {
		if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
		return true;
	}
};
pp$9.semicolon = function() {
	if (!this.eat(types$1.semi) && !this.insertSemicolon()) this.unexpected();
};
pp$9.afterTrailingComma = function(tokType, notNext) {
	if (this.type === tokType) {
		if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
		if (!notNext) this.next();
		return true;
	}
};
pp$9.expect = function(type) {
	this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
	this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors$1 = function DestructuringErrors$2() {
	this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
	if (!refDestructuringErrors) return;
	if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
	var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
	if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	if (!refDestructuringErrors) return false;
	var shorthandAssign = refDestructuringErrors.shorthandAssign;
	var doubleProto = refDestructuringErrors.doubleProto;
	if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
	if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
	if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
};
pp$9.checkYieldAwaitInDefaultParams = function() {
	if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
	if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp$9.isSimpleAssignTarget = function(expr) {
	if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
	return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
	var exports$1 = Object.create(null);
	if (!node.body) node.body = [];
	while (this.type !== types$1.eof) {
		var stmt = this.parseStatement(null, true, exports$1);
		node.body.push(stmt);
	}
	if (this.inModule) for (var i$1 = 0, list$5 = Object.keys(this.undefinedExports); i$1 < list$5.length; i$1 += 1) {
		var name = list$5[i$1];
		this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
	}
	this.adaptDirectivePrologue(node.body);
	this.next();
	node.sourceType = this.options.sourceType;
	return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
	if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
	skipWhiteSpace$1.lastIndex = this.pos;
	var skip = skipWhiteSpace$1.exec(this.input);
	var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	if (nextCh === 91 || nextCh === 92) return true;
	if (context) return false;
	if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) return true;
	if (isIdentifierStart(nextCh, true)) {
		var pos = next + 1;
		while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) ++pos;
		if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) return true;
		var ident = this.input.slice(next, pos);
		if (!keywordRelationalOperator.test(ident)) return true;
	}
	return false;
};
pp$8.isAsyncFunction = function() {
	if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
	skipWhiteSpace$1.lastIndex = this.pos;
	var skip = skipWhiteSpace$1.exec(this.input);
	var next = this.pos + skip[0].length, after;
	return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports$1) {
	var starttype = this.type, node = this.startNode(), kind;
	if (this.isLet(context)) {
		starttype = types$1._var;
		kind = "let";
	}
	switch (starttype) {
		case types$1._break:
		case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword);
		case types$1._debugger: return this.parseDebuggerStatement(node);
		case types$1._do: return this.parseDoStatement(node);
		case types$1._for: return this.parseForStatement(node);
		case types$1._function:
			if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
			return this.parseFunctionStatement(node, false, !context);
		case types$1._class:
			if (context) this.unexpected();
			return this.parseClass(node, true);
		case types$1._if: return this.parseIfStatement(node);
		case types$1._return: return this.parseReturnStatement(node);
		case types$1._switch: return this.parseSwitchStatement(node);
		case types$1._throw: return this.parseThrowStatement(node);
		case types$1._try: return this.parseTryStatement(node);
		case types$1._const:
		case types$1._var:
			kind = kind || this.value;
			if (context && kind !== "var") this.unexpected();
			return this.parseVarStatement(node, kind);
		case types$1._while: return this.parseWhileStatement(node);
		case types$1._with: return this.parseWithStatement(node);
		case types$1.braceL: return this.parseBlock(true, node);
		case types$1.semi: return this.parseEmptyStatement(node);
		case types$1._export:
		case types$1._import:
			if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
				skipWhiteSpace$1.lastIndex = this.pos;
				var skip = skipWhiteSpace$1.exec(this.input);
				var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
				if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
			}
			if (!this.options.allowImportExportEverywhere) {
				if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
				if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
			}
			return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports$1);
		default:
			if (this.isAsyncFunction()) {
				if (context) this.unexpected();
				this.next();
				return this.parseFunctionStatement(node, true, !context);
			}
			var maybeName = this.value, expr = this.parseExpression();
			if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
else return this.parseExpressionStatement(node, expr);
	}
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
	var isBreak = keyword === "break";
	this.next();
	if (this.eat(types$1.semi) || this.insertSemicolon()) node.label = null;
else if (this.type !== types$1.name) this.unexpected();
else {
		node.label = this.parseIdent();
		this.semicolon();
	}
	var i$1 = 0;
	for (; i$1 < this.labels.length; ++i$1) {
		var lab = this.labels[i$1];
		if (node.label == null || lab.name === node.label.name) {
			if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
			if (node.label && isBreak) break;
		}
	}
	if (i$1 === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
	this.next();
	this.semicolon();
	return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
	this.next();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("do");
	this.labels.pop();
	this.expect(types$1._while);
	node.test = this.parseParenExpression();
	if (this.options.ecmaVersion >= 6) this.eat(types$1.semi);
else this.semicolon();
	return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
	this.next();
	var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
	this.labels.push(loopLabel);
	this.enterScope(0);
	this.expect(types$1.parenL);
	if (this.type === types$1.semi) {
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, null);
	}
	var isLet = this.isLet();
	if (this.type === types$1._var || this.type === types$1._const || isLet) {
		var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		this.next();
		this.parseVar(init$1, true, kind);
		this.finishNode(init$1, "VariableDeclaration");
		if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
			if (this.options.ecmaVersion >= 9) if (this.type === types$1._in) {
				if (awaitAt > -1) this.unexpected(awaitAt);
			} else node.await = awaitAt > -1;
			return this.parseForIn(node, init$1);
		}
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, init$1);
	}
	var startsWithLet = this.isContextual("let"), isForOf = false;
	var containsEsc = this.containsEsc;
	var refDestructuringErrors = new DestructuringErrors$1();
	var initPos = this.start;
	var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
	if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		if (awaitAt > -1) {
			if (this.type === types$1._in) this.unexpected(awaitAt);
			node.await = true;
		} else if (isForOf && this.options.ecmaVersion >= 8) {
			if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") this.unexpected();
else if (this.options.ecmaVersion >= 9) node.await = false;
		}
		if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
		this.toAssignable(init, false, refDestructuringErrors);
		this.checkLValPattern(init);
		return this.parseForIn(node, init);
	} else this.checkExpressionErrors(refDestructuringErrors, true);
	if (awaitAt > -1) this.unexpected(awaitAt);
	return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
	this.next();
	return this.parseFunction(node, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT$1), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	node.consequent = this.parseStatement("if");
	node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
	return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
	if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	this.next();
	if (this.eat(types$1.semi) || this.insertSemicolon()) node.argument = null;
else {
		node.argument = this.parseExpression();
		this.semicolon();
	}
	return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
	this.next();
	node.discriminant = this.parseParenExpression();
	node.cases = [];
	this.expect(types$1.braceL);
	this.labels.push(switchLabel);
	this.enterScope(0);
	var cur;
	for (var sawDefault = false; this.type !== types$1.braceR;) if (this.type === types$1._case || this.type === types$1._default) {
		var isCase = this.type === types$1._case;
		if (cur) this.finishNode(cur, "SwitchCase");
		node.cases.push(cur = this.startNode());
		cur.consequent = [];
		this.next();
		if (isCase) cur.test = this.parseExpression();
else {
			if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
			sawDefault = true;
			cur.test = null;
		}
		this.expect(types$1.colon);
	} else {
		if (!cur) this.unexpected();
		cur.consequent.push(this.parseStatement(null));
	}
	this.exitScope();
	if (cur) this.finishNode(cur, "SwitchCase");
	this.next();
	this.labels.pop();
	return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
	this.next();
	if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	node.argument = this.parseExpression();
	this.semicolon();
	return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
	var param = this.parseBindingAtom();
	var simple = param.type === "Identifier";
	this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
	this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL$1);
	this.expect(types$1.parenR);
	return param;
};
pp$8.parseTryStatement = function(node) {
	this.next();
	node.block = this.parseBlock();
	node.handler = null;
	if (this.type === types$1._catch) {
		var clause = this.startNode();
		this.next();
		if (this.eat(types$1.parenL)) clause.param = this.parseCatchClauseParam();
else {
			if (this.options.ecmaVersion < 10) this.unexpected();
			clause.param = null;
			this.enterScope(0);
		}
		clause.body = this.parseBlock(false);
		this.exitScope();
		node.handler = this.finishNode(clause, "CatchClause");
	}
	node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
	if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
	this.next();
	this.parseVar(node, false, kind, allowMissingInitializer);
	this.semicolon();
	return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("while");
	this.labels.pop();
	return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
	if (this.strict) this.raise(this.start, "'with' in strict mode");
	this.next();
	node.object = this.parseParenExpression();
	node.body = this.parseStatement("with");
	return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
	this.next();
	return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
	for (var i$1 = 0, list$5 = this.labels; i$1 < list$5.length; i$1 += 1) {
		var label = list$5[i$1];
		if (label.name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	}
	var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
	for (var i$2 = this.labels.length - 1; i$2 >= 0; i$2--) {
		var label$1 = this.labels[i$2];
		if (label$1.statementStart === node.start) {
			label$1.statementStart = this.start;
			label$1.kind = kind;
		} else break;
	}
	this.labels.push({
		name: maybeName,
		kind,
		statementStart: this.start
	});
	node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
	this.labels.pop();
	node.label = expr;
	return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
	node.expression = expr;
	this.semicolon();
	return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
	if (createNewLexicalScope === void 0) createNewLexicalScope = true;
	if (node === void 0) node = this.startNode();
	node.body = [];
	this.expect(types$1.braceL);
	if (createNewLexicalScope) this.enterScope(0);
	while (this.type !== types$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	if (exitStrict) this.strict = false;
	this.next();
	if (createNewLexicalScope) this.exitScope();
	return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
	node.init = init;
	this.expect(types$1.semi);
	node.test = this.type === types$1.semi ? null : this.parseExpression();
	this.expect(types$1.semi);
	node.update = this.type === types$1.parenR ? null : this.parseExpression();
	this.expect(types$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
	var isForIn = this.type === types$1._in;
	this.next();
	if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
	node.left = init;
	node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
	this.expect(types$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
	node.declarations = [];
	node.kind = kind;
	for (;;) {
		var decl$1 = this.startNode();
		this.parseVarId(decl$1, kind);
		if (this.eat(types$1.eq)) decl$1.init = this.parseMaybeAssign(isFor);
else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
else if (!allowMissingInitializer && decl$1.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
else decl$1.init = null;
		node.declarations.push(this.finishNode(decl$1, "VariableDeclarator"));
		if (!this.eat(types$1.comma)) break;
	}
	return node;
};
pp$8.parseVarId = function(decl$1, kind) {
	decl$1.id = this.parseBindingAtom();
	this.checkLValPattern(decl$1.id, kind === "var" ? BIND_VAR$1 : BIND_LEXICAL$1, false);
};
var FUNC_STATEMENT$1 = 1, FUNC_HANGING_STATEMENT$1 = 2, FUNC_NULLABLE_ID$1 = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
	this.initFunction(node);
	if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
		if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT$1) this.unexpected();
		node.generator = this.eat(types$1.star);
	}
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	if (statement & FUNC_STATEMENT$1) {
		node.id = statement & FUNC_NULLABLE_ID$1 && this.type !== types$1.name ? null : this.parseIdent();
		if (node.id && !(statement & FUNC_HANGING_STATEMENT$1)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR$1 : BIND_LEXICAL$1 : BIND_FUNCTION$1);
	}
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags$1(node.async, node.generator));
	if (!(statement & FUNC_STATEMENT$1)) node.id = this.type === types$1.name ? this.parseIdent() : null;
	this.parseFunctionParams(node);
	this.parseFunctionBody(node, allowExpressionBody, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, statement & FUNC_STATEMENT$1 ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
	this.expect(types$1.parenL);
	node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
	this.next();
	var oldStrict = this.strict;
	this.strict = true;
	this.parseClassId(node, isStatement);
	this.parseClassSuper(node);
	var privateNameMap = this.enterClassBody();
	var classBody = this.startNode();
	var hadConstructor = false;
	classBody.body = [];
	this.expect(types$1.braceL);
	while (this.type !== types$1.braceR) {
		var element = this.parseClassElement(node.superClass !== null);
		if (element) {
			classBody.body.push(element);
			if (element.type === "MethodDefinition" && element.kind === "constructor") {
				if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
				hadConstructor = true;
			} else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted$1(privateNameMap, element)) this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
		}
	}
	this.strict = oldStrict;
	this.next();
	node.body = this.finishNode(classBody, "ClassBody");
	this.exitClassBody();
	return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
	if (this.eat(types$1.semi)) return null;
	var ecmaVersion$1 = this.options.ecmaVersion;
	var node = this.startNode();
	var keyName = "";
	var isGenerator = false;
	var isAsync = false;
	var kind = "method";
	var isStatic = false;
	if (this.eatContextual("static")) {
		if (ecmaVersion$1 >= 13 && this.eat(types$1.braceL)) {
			this.parseClassStaticBlock(node);
			return node;
		}
		if (this.isClassElementNameStart() || this.type === types$1.star) isStatic = true;
else keyName = "static";
	}
	node.static = isStatic;
	if (!keyName && ecmaVersion$1 >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) isAsync = true;
else keyName = "async";
	if (!keyName && (ecmaVersion$1 >= 9 || !isAsync) && this.eat(types$1.star)) isGenerator = true;
	if (!keyName && !isAsync && !isGenerator) {
		var lastValue = this.value;
		if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
else keyName = lastValue;
	}
	if (keyName) {
		node.computed = false;
		node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		node.key.name = keyName;
		this.finishNode(node.key, "Identifier");
	} else this.parseClassElementName(node);
	if (ecmaVersion$1 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
		var isConstructor = !node.static && checkKeyName$1(node, "constructor");
		var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
		node.kind = isConstructor ? "constructor" : kind;
		this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
	} else this.parseClassField(node);
	return node;
};
pp$8.isClassElementNameStart = function() {
	return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
	if (this.type === types$1.privateId) {
		if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
		element.computed = false;
		element.key = this.parsePrivateIdent();
	} else this.parsePropertyName(element);
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
	var key = method.key;
	if (method.kind === "constructor") {
		if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
		if (isAsync) this.raise(key.start, "Constructor can't be an async method");
	} else if (method.static && checkKeyName$1(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
	var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
	if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
	if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
	if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
	return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
	if (checkKeyName$1(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
else if (field.static && checkKeyName$1(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
	if (this.eat(types$1.eq)) {
		this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
		field.value = this.parseMaybeAssign();
		this.exitScope();
	} else field.value = null;
	this.semicolon();
	return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
	node.body = [];
	var oldLabels = this.labels;
	this.labels = [];
	this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
	while (this.type !== types$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	this.next();
	this.exitScope();
	this.labels = oldLabels;
	return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
	if (this.type === types$1.name) {
		node.id = this.parseIdent();
		if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL$1, false);
	} else {
		if (isStatement === true) this.unexpected();
		node.id = null;
	}
};
pp$8.parseClassSuper = function(node) {
	node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
	var element = {
		declared: Object.create(null),
		used: []
	};
	this.privateNameStack.push(element);
	return element.declared;
};
pp$8.exitClassBody = function() {
	var ref$1 = this.privateNameStack.pop();
	var declared = ref$1.declared;
	var used = ref$1.used;
	if (!this.options.checkPrivateFields) return;
	var len = this.privateNameStack.length;
	var parent = len === 0 ? null : this.privateNameStack[len - 1];
	for (var i$1 = 0; i$1 < used.length; ++i$1) {
		var id = used[i$1];
		if (!hasOwn(declared, id.name)) if (parent) parent.used.push(id);
else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
	}
};
function isPrivateNameConflicted$1(privateNameMap, element) {
	var name = element.key.name;
	var curr = privateNameMap[name];
	var next = "true";
	if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
	if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
		privateNameMap[name] = "true";
		return false;
	} else if (!curr) {
		privateNameMap[name] = next;
		return false;
	} else return true;
}
function checkKeyName$1(node, name) {
	var computed = node.computed;
	var key = node.key;
	return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports$1) {
	if (this.options.ecmaVersion >= 11) if (this.eatContextual("as")) {
		node.exported = this.parseModuleExportName();
		this.checkExport(exports$1, node.exported, this.lastTokStart);
	} else node.exported = null;
	this.expectContextual("from");
	if (this.type !== types$1.string) this.unexpected();
	node.source = this.parseExprAtom();
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports$1) {
	this.next();
	if (this.eat(types$1.star)) return this.parseExportAllDeclaration(node, exports$1);
	if (this.eat(types$1._default)) {
		this.checkExport(exports$1, "default", this.lastTokStart);
		node.declaration = this.parseExportDefaultDeclaration();
		return this.finishNode(node, "ExportDefaultDeclaration");
	}
	if (this.shouldParseExportStatement()) {
		node.declaration = this.parseExportDeclaration(node);
		if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports$1, node.declaration.declarations);
else this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
		node.specifiers = [];
		node.source = null;
		if (this.options.ecmaVersion >= 16) node.attributes = [];
	} else {
		node.declaration = null;
		node.specifiers = this.parseExportSpecifiers(exports$1);
		if (this.eatContextual("from")) {
			if (this.type !== types$1.string) this.unexpected();
			node.source = this.parseExprAtom();
			if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
		} else {
			for (var i$1 = 0, list$5 = node.specifiers; i$1 < list$5.length; i$1 += 1) {
				var spec = list$5[i$1];
				this.checkUnreserved(spec.local);
				this.checkLocalExport(spec.local);
				if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
			}
			node.source = null;
			if (this.options.ecmaVersion >= 16) node.attributes = [];
		}
		this.semicolon();
	}
	return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
	return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
	var isAsync;
	if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
		var fNode = this.startNode();
		this.next();
		if (isAsync) this.next();
		return this.parseFunction(fNode, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, false, isAsync);
	} else if (this.type === types$1._class) {
		var cNode = this.startNode();
		return this.parseClass(cNode, "nullableID");
	} else {
		var declaration = this.parseMaybeAssign();
		this.semicolon();
		return declaration;
	}
};
pp$8.checkExport = function(exports$1, name, pos) {
	if (!exports$1) return;
	if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
	if (hasOwn(exports$1, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
	exports$1[name] = true;
};
pp$8.checkPatternExport = function(exports$1, pat) {
	var type = pat.type;
	if (type === "Identifier") this.checkExport(exports$1, pat, pat.start);
else if (type === "ObjectPattern") for (var i$1 = 0, list$5 = pat.properties; i$1 < list$5.length; i$1 += 1) {
		var prop = list$5[i$1];
		this.checkPatternExport(exports$1, prop);
	}
else if (type === "ArrayPattern") for (var i$1$1 = 0, list$1$1 = pat.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
		var elt = list$1$1[i$1$1];
		if (elt) this.checkPatternExport(exports$1, elt);
	}
else if (type === "Property") this.checkPatternExport(exports$1, pat.value);
else if (type === "AssignmentPattern") this.checkPatternExport(exports$1, pat.left);
else if (type === "RestElement") this.checkPatternExport(exports$1, pat.argument);
};
pp$8.checkVariableExport = function(exports$1, decls) {
	if (!exports$1) return;
	for (var i$1 = 0, list$5 = decls; i$1 < list$5.length; i$1 += 1) {
		var decl$1 = list$5[i$1];
		this.checkPatternExport(exports$1, decl$1.id);
	}
};
pp$8.shouldParseExportStatement = function() {
	return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports$1) {
	var node = this.startNode();
	node.local = this.parseModuleExportName();
	node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
	this.checkExport(exports$1, node.exported, node.exported.start);
	return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports$1) {
	var nodes = [], first = true;
	this.expect(types$1.braceL);
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseExportSpecifier(exports$1));
	}
	return nodes;
};
pp$8.parseImport = function(node) {
	this.next();
	if (this.type === types$1.string) {
		node.specifiers = empty$1;
		node.source = this.parseExprAtom();
	} else {
		node.specifiers = this.parseImportSpecifiers();
		this.expectContextual("from");
		node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
	}
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
	var node = this.startNode();
	node.imported = this.parseModuleExportName();
	if (this.eatContextual("as")) node.local = this.parseIdent();
else {
		this.checkUnreserved(node.imported);
		node.local = node.imported;
	}
	this.checkLValSimple(node.local, BIND_LEXICAL$1);
	return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
	var node = this.startNode();
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL$1);
	return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
	var node = this.startNode();
	this.next();
	this.expectContextual("as");
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL$1);
	return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
	var nodes = [], first = true;
	if (this.type === types$1.name) {
		nodes.push(this.parseImportDefaultSpecifier());
		if (!this.eat(types$1.comma)) return nodes;
	}
	if (this.type === types$1.star) {
		nodes.push(this.parseImportNamespaceSpecifier());
		return nodes;
	}
	this.expect(types$1.braceL);
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseImportSpecifier());
	}
	return nodes;
};
pp$8.parseWithClause = function() {
	var nodes = [];
	if (!this.eat(types$1._with)) return nodes;
	this.expect(types$1.braceL);
	var attributeKeys = {};
	var first = true;
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		var attr = this.parseImportAttribute();
		var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
		if (hasOwn(attributeKeys, keyName)) this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
		attributeKeys[keyName] = true;
		nodes.push(attr);
	}
	return nodes;
};
pp$8.parseImportAttribute = function() {
	var node = this.startNode();
	node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
	this.expect(types$1.colon);
	if (this.type !== types$1.string) this.unexpected();
	node.value = this.parseExprAtom();
	return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
	if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
		var stringLiteral = this.parseLiteral(this.value);
		if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		return stringLiteral;
	}
	return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
	for (var i$1 = 0; i$1 < statements.length && this.isDirectiveCandidate(statements[i$1]); ++i$1) statements[i$1].directive = statements[i$1].expression.raw.slice(1, -1);
};
pp$8.isDirectiveCandidate = function(statement) {
	return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
		case "Identifier":
			if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
			break;
		case "ObjectPattern":
		case "ArrayPattern":
		case "AssignmentPattern":
		case "RestElement": break;
		case "ObjectExpression":
			node.type = "ObjectPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			for (var i$1 = 0, list$5 = node.properties; i$1 < list$5.length; i$1 += 1) {
				var prop = list$5[i$1];
				this.toAssignable(prop, isBinding);
				if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
			}
			break;
		case "Property":
			if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
			this.toAssignable(node.value, isBinding);
			break;
		case "ArrayExpression":
			node.type = "ArrayPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			this.toAssignableList(node.elements, isBinding);
			break;
		case "SpreadElement":
			node.type = "RestElement";
			this.toAssignable(node.argument, isBinding);
			if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
			break;
		case "AssignmentExpression":
			if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
			node.type = "AssignmentPattern";
			delete node.operator;
			this.toAssignable(node.left, isBinding);
			break;
		case "ParenthesizedExpression":
			this.toAssignable(node.expression, isBinding, refDestructuringErrors);
			break;
		case "ChainExpression":
			this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression": if (!isBinding) break;
		default: this.raise(node.start, "Assigning to rvalue");
	}
else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
	return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
	var end = exprList.length;
	for (var i$1 = 0; i$1 < end; i$1++) {
		var elt = exprList[i$1];
		if (elt) this.toAssignable(elt, isBinding);
	}
	if (end) {
		var last = exprList[end - 1];
		if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	}
	return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion === 6 && this.type !== types$1.name) this.unexpected();
	node.argument = this.parseBindingAtom();
	return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
	if (this.options.ecmaVersion >= 6) switch (this.type) {
		case types$1.bracketL:
			var node = this.startNode();
			this.next();
			node.elements = this.parseBindingList(types$1.bracketR, true, true);
			return this.finishNode(node, "ArrayPattern");
		case types$1.braceL: return this.parseObj(true);
	}
	return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (first) first = false;
else this.expect(types$1.comma);
		if (allowEmpty && this.type === types$1.comma) elts.push(null);
else if (allowTrailingComma && this.afterTrailingComma(close)) break;
else if (this.type === types$1.ellipsis) {
			var rest = this.parseRestBinding();
			this.parseBindingListItem(rest);
			elts.push(rest);
			if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			this.expect(close);
			break;
		} else elts.push(this.parseAssignableListItem(allowModifiers));
	}
	return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
	var elem = this.parseMaybeDefault(this.start, this.startLoc);
	this.parseBindingListItem(elem);
	return elem;
};
pp$7.parseBindingListItem = function(param) {
	return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
	left = left || this.parseBindingAtom();
	if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) return left;
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.right = this.parseMaybeAssign();
	return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE$1;
	var isBind = bindingType !== BIND_NONE$1;
	switch (expr.type) {
		case "Identifier":
			if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
			if (isBind) {
				if (bindingType === BIND_LEXICAL$1 && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
				if (checkClashes) {
					if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
					checkClashes[expr.name] = true;
				}
				if (bindingType !== BIND_OUTSIDE$1) this.declareName(expr.name, bindingType, expr.start);
			}
			break;
		case "ChainExpression":
			this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
			break;
		case "ParenthesizedExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
			return this.checkLValSimple(expr.expression, bindingType, checkClashes);
		default: this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
	}
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE$1;
	switch (expr.type) {
		case "ObjectPattern":
			for (var i$1 = 0, list$5 = expr.properties; i$1 < list$5.length; i$1 += 1) {
				var prop = list$5[i$1];
				this.checkLValInnerPattern(prop, bindingType, checkClashes);
			}
			break;
		case "ArrayPattern":
			for (var i$1$1 = 0, list$1$1 = expr.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
				var elem = list$1$1[i$1$1];
				if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
			}
			break;
		default: this.checkLValSimple(expr, bindingType, checkClashes);
	}
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE$1;
	switch (expr.type) {
		case "Property":
			this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
			break;
		case "AssignmentPattern":
			this.checkLValPattern(expr.left, bindingType, checkClashes);
			break;
		case "RestElement":
			this.checkLValPattern(expr.argument, bindingType, checkClashes);
			break;
		default: this.checkLValPattern(expr, bindingType, checkClashes);
	}
};
var TokContext = function TokContext$1(token, isExpr, preserveSpace, override, generator) {
	this.token = token;
	this.isExpr = !!isExpr;
	this.preserveSpace = !!preserveSpace;
	this.override = override;
	this.generator = !!generator;
};
var types = {
	b_stat: new TokContext("{", false),
	b_expr: new TokContext("{", true),
	b_tmpl: new TokContext("\${", false),
	p_stat: new TokContext("(", false),
	p_expr: new TokContext("(", true),
	q_tmpl: new TokContext("`", true, true, function(p$1) {
		return p$1.tryReadTemplateToken();
	}),
	f_stat: new TokContext("function", false),
	f_expr: new TokContext("function", true),
	f_expr_gen: new TokContext("function", true, false, null, true),
	f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
	return [types.b_stat];
};
pp$6.curContext = function() {
	return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
	var parent = this.curContext();
	if (parent === types.f_expr || parent === types.f_stat) return true;
	if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) return !parent.isExpr;
	if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) return true;
	if (prevType === types$1.braceL) return parent === types.b_stat;
	if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) return false;
	return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
	for (var i$1 = this.context.length - 1; i$1 >= 1; i$1--) {
		var context = this.context[i$1];
		if (context.token === "function") return context.generator;
	}
	return false;
};
pp$6.updateContext = function(prevType) {
	var update, type = this.type;
	if (type.keyword && prevType === types$1.dot) this.exprAllowed = false;
else if (update = type.updateContext) update.call(this, prevType);
else this.exprAllowed = type.beforeExpr;
};
pp$6.overrideContext = function(tokenCtx) {
	if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
	if (this.context.length === 1) {
		this.exprAllowed = true;
		return;
	}
	var out = this.context.pop();
	if (out === types.b_stat && this.curContext().token === "function") out = this.context.pop();
	this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
	this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
	this.context.push(types.b_tmpl);
	this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
	var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
	this.context.push(statementParens ? types.p_stat : types.p_expr);
	this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
	if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);
else this.context.push(types.f_stat);
	this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
	if (this.curContext().token === "function") this.context.pop();
	this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
	if (this.curContext() === types.q_tmpl) this.context.pop();
else this.context.push(types.q_tmpl);
	this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
	if (prevType === types$1._function) {
		var index = this.context.length - 1;
		if (this.context[index] === types.f_expr) this.context[index] = types.f_expr_gen;
else this.context[index] = types.f_gen;
	}
	this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
	var allowed = false;
	if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
		if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
	}
	this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
	if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	var key = prop.key;
	var name;
	switch (key.type) {
		case "Identifier":
			name = key.name;
			break;
		case "Literal":
			name = String(key.value);
			break;
		default: return;
	}
	var kind = prop.kind;
	if (this.options.ecmaVersion >= 6) {
		if (name === "__proto__" && kind === "init") {
			if (propHash.proto) if (refDestructuringErrors) {
				if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
			} else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
			propHash.proto = true;
		}
		return;
	}
	name = "$" + name;
	var other = propHash[name];
	if (other) {
		var redefinition;
		if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
else redefinition = other.init || other[kind];
		if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
	} else other = propHash[name] = {
		init: false,
		get: false,
		set: false
	};
	other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
	if (this.type === types$1.comma) {
		var node = this.startNodeAt(startPos, startLoc);
		node.expressions = [expr];
		while (this.eat(types$1.comma)) node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
		return this.finishNode(node, "SequenceExpression");
	}
	return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
	if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
else this.exprAllowed = false;
	var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
	if (refDestructuringErrors) {
		oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		oldTrailingComma = refDestructuringErrors.trailingComma;
		oldDoubleProto = refDestructuringErrors.doubleProto;
		refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
	} else {
		refDestructuringErrors = new DestructuringErrors$1();
		ownDestructuringErrors = true;
	}
	var startPos = this.start, startLoc = this.startLoc;
	if (this.type === types$1.parenL || this.type === types$1.name) {
		this.potentialArrowAt = this.start;
		this.potentialArrowInForAwait = forInit === "await";
	}
	var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
	if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	if (this.type.isAssign) {
		var node = this.startNodeAt(startPos, startLoc);
		node.operator = this.value;
		if (this.type === types$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
		if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
		if (this.type === types$1.eq) this.checkLValPattern(left);
else this.checkLValSimple(left);
		node.left = left;
		this.next();
		node.right = this.parseMaybeAssign(forInit);
		if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
		return this.finishNode(node, "AssignmentExpression");
	} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
	if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
	if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
	return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprOps(forInit, refDestructuringErrors);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	if (this.eat(types$1.question)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.test = expr;
		node.consequent = this.parseMaybeAssign();
		this.expect(types$1.colon);
		node.alternate = this.parseMaybeAssign(forInit);
		return this.finishNode(node, "ConditionalExpression");
	}
	return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
	var prec = this.type.binop;
	if (prec != null && (!forInit || this.type !== types$1._in)) {
		if (prec > minPrec) {
			var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
			var coalesce = this.type === types$1.coalesce;
			if (coalesce) prec = types$1.logicalAND.binop;
			var op = this.value;
			this.next();
			var startPos = this.start, startLoc = this.startLoc;
			var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
			var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
			if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
			return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
		}
	}
	return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.operator = op;
	node.right = right;
	return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
	var startPos = this.start, startLoc = this.startLoc, expr;
	if (this.isContextual("await") && this.canAwait) {
		expr = this.parseAwait(forInit);
		sawUnary = true;
	} else if (this.type.prefix) {
		var node = this.startNode(), update = this.type === types$1.incDec;
		node.operator = this.value;
		node.prefix = true;
		this.next();
		node.argument = this.parseMaybeUnary(null, true, update, forInit);
		this.checkExpressionErrors(refDestructuringErrors, true);
		if (update) this.checkLValSimple(node.argument);
else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
else sawUnary = true;
		expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	} else if (!sawUnary && this.type === types$1.privateId) {
		if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();
		expr = this.parsePrivateIdent();
		if (this.type !== types$1._in) this.unexpected();
	} else {
		expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
		while (this.type.postfix && !this.canInsertSemicolon()) {
			var node$1 = this.startNodeAt(startPos, startLoc);
			node$1.operator = this.value;
			node$1.prefix = false;
			node$1.argument = expr;
			this.checkLValSimple(expr);
			this.next();
			expr = this.finishNode(node$1, "UpdateExpression");
		}
	}
	if (!incDec && this.eat(types$1.starstar)) if (sawUnary) this.unexpected(this.lastTokStart);
else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
else return expr;
};
function isLocalVariableAccess(node) {
	return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
	return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprAtom(refDestructuringErrors, forInit);
	if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
	var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
	if (refDestructuringErrors && result.type === "MemberExpression") {
		if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
		if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
		if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
	}
	return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
	var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
	var optionalChained = false;
	while (true) {
		var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
		if (element.optional) optionalChained = true;
		if (element === base || element.type === "ArrowFunctionExpression") {
			if (optionalChained) {
				var chainNode = this.startNodeAt(startPos, startLoc);
				chainNode.expression = element;
				element = this.finishNode(chainNode, "ChainExpression");
			}
			return element;
		}
		base = element;
	}
};
pp$5.shouldParseAsyncArrow = function() {
	return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
	var optionalSupported = this.options.ecmaVersion >= 11;
	var optional = optionalSupported && this.eat(types$1.questionDot);
	if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
	var computed = this.eat(types$1.bracketL);
	if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.object = base;
		if (computed) {
			node.property = this.parseExpression();
			this.expect(types$1.bracketR);
		} else if (this.type === types$1.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
else node.property = this.parseIdent(this.options.allowReserved !== "never");
		node.computed = !!computed;
		if (optionalSupported) node.optional = optional;
		base = this.finishNode(node, "MemberExpression");
	} else if (!noCalls && this.eat(types$1.parenL)) {
		var refDestructuringErrors = new DestructuringErrors$1(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			this.awaitIdentPos = oldAwaitIdentPos;
			return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
		}
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		var node$1 = this.startNodeAt(startPos, startLoc);
		node$1.callee = base;
		node$1.arguments = exprList;
		if (optionalSupported) node$1.optional = optional;
		base = this.finishNode(node$1, "CallExpression");
	} else if (this.type === types$1.backQuote) {
		if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		var node$2 = this.startNodeAt(startPos, startLoc);
		node$2.tag = base;
		node$2.quasi = this.parseTemplate({ isTagged: true });
		base = this.finishNode(node$2, "TaggedTemplateExpression");
	}
	return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
	if (this.type === types$1.slash) this.readRegexp();
	var node, canBeArrow = this.potentialArrowAt === this.start;
	switch (this.type) {
		case types$1._super:
			if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
			node = this.startNode();
			this.next();
			if (this.type === types$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
			if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) this.unexpected();
			return this.finishNode(node, "Super");
		case types$1._this:
			node = this.startNode();
			this.next();
			return this.finishNode(node, "ThisExpression");
		case types$1.name:
			var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
			var id = this.parseIdent(false);
			if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
				this.overrideContext(types.f_expr);
				return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
			}
			if (canBeArrow && !this.canInsertSemicolon()) {
				if (this.eat(types$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
				if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
					id = this.parseIdent(false);
					if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) this.unexpected();
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
				}
			}
			return id;
		case types$1.regexp:
			var value = this.value;
			node = this.parseLiteral(value.value);
			node.regex = {
				pattern: value.pattern,
				flags: value.flags
			};
			return node;
		case types$1.num:
		case types$1.string: return this.parseLiteral(this.value);
		case types$1._null:
		case types$1._true:
		case types$1._false:
			node = this.startNode();
			node.value = this.type === types$1._null ? null : this.type === types$1._true;
			node.raw = this.type.keyword;
			this.next();
			return this.finishNode(node, "Literal");
		case types$1.parenL:
			var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
			if (refDestructuringErrors) {
				if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
				if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
			}
			return expr;
		case types$1.bracketL:
			node = this.startNode();
			this.next();
			node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
			return this.finishNode(node, "ArrayExpression");
		case types$1.braceL:
			this.overrideContext(types.b_expr);
			return this.parseObj(false, refDestructuringErrors);
		case types$1._function:
			node = this.startNode();
			this.next();
			return this.parseFunction(node, 0);
		case types$1._class: return this.parseClass(this.startNode(), false);
		case types$1._new: return this.parseNew();
		case types$1.backQuote: return this.parseTemplate();
		case types$1._import: if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);
else return this.unexpected();
		default: return this.parseExprAtomDefault();
	}
};
pp$5.parseExprAtomDefault = function() {
	this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
	var node = this.startNode();
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
	this.next();
	if (this.type === types$1.parenL && !forNew) return this.parseDynamicImport(node);
else if (this.type === types$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "import";
		node.meta = this.finishNode(meta, "Identifier");
		return this.parseImportMeta(node);
	} else this.unexpected();
};
pp$5.parseDynamicImport = function(node) {
	this.next();
	node.source = this.parseMaybeAssign();
	if (this.options.ecmaVersion >= 16) if (!this.eat(types$1.parenR)) {
		this.expect(types$1.comma);
		if (!this.afterTrailingComma(types$1.parenR)) {
			node.options = this.parseMaybeAssign();
			if (!this.eat(types$1.parenR)) {
				this.expect(types$1.comma);
				if (!this.afterTrailingComma(types$1.parenR)) this.unexpected();
			}
		} else node.options = null;
	} else node.options = null;
else if (!this.eat(types$1.parenR)) {
		var errorPos = this.start;
		if (this.eat(types$1.comma) && this.eat(types$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
else this.unexpected(errorPos);
	}
	return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
	this.next();
	var containsEsc = this.containsEsc;
	node.property = this.parseIdent(true);
	if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
	if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
	if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
	return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
	var node = this.startNode();
	node.value = value;
	node.raw = this.input.slice(this.start, this.end);
	if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
	this.next();
	return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
	this.expect(types$1.parenL);
	var val = this.parseExpression();
	this.expect(types$1.parenR);
	return val;
};
pp$5.shouldParseArrow = function(exprList) {
	return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
	var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
	if (this.options.ecmaVersion >= 6) {
		this.next();
		var innerStartPos = this.start, innerStartLoc = this.startLoc;
		var exprList = [], first = true, lastIsComma = false;
		var refDestructuringErrors = new DestructuringErrors$1(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		this.yieldPos = 0;
		this.awaitPos = 0;
		while (this.type !== types$1.parenR) {
			first ? first = false : this.expect(types$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
				lastIsComma = true;
				break;
			} else if (this.type === types$1.ellipsis) {
				spreadStart = this.start;
				exprList.push(this.parseParenItem(this.parseRestBinding()));
				if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
				break;
			} else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		}
		var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		this.expect(types$1.parenR);
		if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
		}
		if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
		if (spreadStart) this.unexpected(spreadStart);
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		if (exprList.length > 1) {
			val = this.startNodeAt(innerStartPos, innerStartLoc);
			val.expressions = exprList;
			this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		} else val = exprList[0];
	} else val = this.parseParenExpression();
	if (this.options.preserveParens) {
		var par = this.startNodeAt(startPos, startLoc);
		par.expression = val;
		return this.finishNode(par, "ParenthesizedExpression");
	} else return val;
};
pp$5.parseParenItem = function(item) {
	return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "new";
		node.meta = this.finishNode(meta, "Identifier");
		this.next();
		var containsEsc = this.containsEsc;
		node.property = this.parseIdent(true);
		if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
		if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
		if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
		return this.finishNode(node, "MetaProperty");
	}
	var startPos = this.start, startLoc = this.startLoc;
	node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
	if (this.eat(types$1.parenL)) node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
else node.arguments = empty;
	return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref$1) {
	var isTagged = ref$1.isTagged;
	var elem = this.startNode();
	if (this.type === types$1.invalidTemplate) {
		if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		elem.value = {
			raw: this.value.replace(/\r\n?/g, "\n"),
			cooked: null
		};
	} else elem.value = {
		raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		cooked: this.value
	};
	this.next();
	elem.tail = this.type === types$1.backQuote;
	return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref$1) {
	if (ref$1 === void 0) ref$1 = {};
	var isTagged = ref$1.isTagged;
	if (isTagged === void 0) isTagged = false;
	var node = this.startNode();
	this.next();
	node.expressions = [];
	var curElt = this.parseTemplateElement({ isTagged });
	node.quasis = [curElt];
	while (!curElt.tail) {
		if (this.type === types$1.eof) this.raise(this.pos, "Unterminated template literal");
		this.expect(types$1.dollarBraceL);
		node.expressions.push(this.parseExpression());
		this.expect(types$1.braceR);
		node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
	}
	this.next();
	return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
	return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
	var node = this.startNode(), first = true, propHash = {};
	node.properties = [];
	this.next();
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		var prop = this.parseProperty(isPattern, refDestructuringErrors);
		if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
		node.properties.push(prop);
	}
	return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
	var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
	if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
		if (isPattern) {
			prop.argument = this.parseIdent(false);
			if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			return this.finishNode(prop, "RestElement");
		}
		prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		return this.finishNode(prop, "SpreadElement");
	}
	if (this.options.ecmaVersion >= 6) {
		prop.method = false;
		prop.shorthand = false;
		if (isPattern || refDestructuringErrors) {
			startPos = this.start;
			startLoc = this.startLoc;
		}
		if (!isPattern) isGenerator = this.eat(types$1.star);
	}
	var containsEsc = this.containsEsc;
	this.parsePropertyName(prop);
	if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		isAsync = true;
		isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
		this.parsePropertyName(prop);
	} else isAsync = false;
	this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
	return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
	var kind = prop.key.name;
	this.parsePropertyName(prop);
	prop.value = this.parseMethod(false);
	prop.kind = kind;
	var paramCount = prop.kind === "get" ? 0 : 1;
	if (prop.value.params.length !== paramCount) {
		var start = prop.value.start;
		if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
else this.raiseRecoverable(start, "setter should have exactly one param");
	} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
	if ((isGenerator || isAsync) && this.type === types$1.colon) this.unexpected();
	if (this.eat(types$1.colon)) {
		prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		prop.kind = "init";
	} else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
		if (isPattern) this.unexpected();
		prop.method = true;
		prop.value = this.parseMethod(isGenerator, isAsync);
		prop.kind = "init";
	} else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
		if (isGenerator || isAsync) this.unexpected();
		this.parseGetterSetter(prop);
	} else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		if (isGenerator || isAsync) this.unexpected();
		this.checkUnreserved(prop.key);
		if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
		if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
else if (this.type === types$1.eq && refDestructuringErrors) {
			if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
			prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		} else prop.value = this.copyNode(prop.key);
		prop.kind = "init";
		prop.shorthand = true;
	} else this.unexpected();
};
pp$5.parsePropertyName = function(prop) {
	if (this.options.ecmaVersion >= 6) if (this.eat(types$1.bracketL)) {
		prop.computed = true;
		prop.key = this.parseMaybeAssign();
		this.expect(types$1.bracketR);
		return prop.key;
	} else prop.computed = false;
	return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
	node.id = null;
	if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
	if (this.options.ecmaVersion >= 8) node.async = false;
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
	var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.initFunction(node);
	if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags$1(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
	this.expect(types$1.parenL);
	node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
	this.parseFunctionBody(node, false, true, false);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.enterScope(functionFlags$1(isAsync, false) | SCOPE_ARROW);
	this.initFunction(node);
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	node.params = this.toAssignableList(params, true);
	this.parseFunctionBody(node, true, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
	var isExpression = isArrowFunction && this.type !== types$1.braceL;
	var oldStrict = this.strict, useStrict = false;
	if (isExpression) {
		node.body = this.parseMaybeAssign(forInit);
		node.expression = true;
		this.checkParams(node, false);
	} else {
		var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		if (!oldStrict || nonSimple) {
			useStrict = this.strictDirective(this.end);
			if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
		}
		var oldLabels = this.labels;
		this.labels = [];
		if (useStrict) this.strict = true;
		this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE$1);
		node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
		node.expression = false;
		this.adaptDirectivePrologue(node.body.body);
		this.labels = oldLabels;
	}
	this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
	for (var i$1 = 0, list$5 = params; i$1 < list$5.length; i$1 += 1) {
		var param = list$5[i$1];
		if (param.type !== "Identifier") return false;
	}
	return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
	var nameHash = Object.create(null);
	for (var i$1 = 0, list$5 = node.params; i$1 < list$5.length; i$1 += 1) {
		var param = list$5[i$1];
		this.checkLValInnerPattern(param, BIND_VAR$1, allowDuplicates ? null : nameHash);
	}
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (!first) {
			this.expect(types$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(close)) break;
		} else first = false;
		var elt = void 0;
		if (allowEmpty && this.type === types$1.comma) elt = null;
else if (this.type === types$1.ellipsis) {
			elt = this.parseSpread(refDestructuringErrors);
			if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		} else elt = this.parseMaybeAssign(false, refDestructuringErrors);
		elts.push(elt);
	}
	return elts;
};
pp$5.checkUnreserved = function(ref$1) {
	var start = ref$1.start;
	var end = ref$1.end;
	var name = ref$1.name;
	if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
	if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
	if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
	if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
	if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
	if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
	var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
	if (re.test(name)) {
		if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
		this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
	}
};
pp$5.parseIdent = function(liberal) {
	var node = this.parseIdentNode();
	this.next(!!liberal);
	this.finishNode(node, "Identifier");
	if (!liberal) {
		this.checkUnreserved(node);
		if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
	}
	return node;
};
pp$5.parseIdentNode = function() {
	var node = this.startNode();
	if (this.type === types$1.name) node.name = this.value;
else if (this.type.keyword) {
		node.name = this.type.keyword;
		if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
		this.type = types$1.name;
	} else this.unexpected();
	return node;
};
pp$5.parsePrivateIdent = function() {
	var node = this.startNode();
	if (this.type === types$1.privateId) node.name = this.value;
else this.unexpected();
	this.next();
	this.finishNode(node, "PrivateIdentifier");
	if (this.options.checkPrivateFields) if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
	return node;
};
pp$5.parseYield = function(forInit) {
	if (!this.yieldPos) this.yieldPos = this.start;
	var node = this.startNode();
	this.next();
	if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
		node.delegate = false;
		node.argument = null;
	} else {
		node.delegate = this.eat(types$1.star);
		node.argument = this.parseMaybeAssign(forInit);
	}
	return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
	if (!this.awaitPos) this.awaitPos = this.start;
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeUnary(null, true, false, forInit);
	return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
	var loc = getLineInfo(this.input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	if (this.sourceFile) message += " in " + this.sourceFile;
	var err = new SyntaxError(message);
	err.pos = pos;
	err.loc = loc;
	err.raisedAt = this.pos;
	throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
	if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$3 = Parser.prototype;
var Scope = function Scope$1(flags) {
	this.flags = flags;
	this.var = [];
	this.lexical = [];
	this.functions = [];
};
pp$3.enterScope = function(flags) {
	this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
	this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
	return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
	var redeclared = false;
	if (bindingType === BIND_LEXICAL$1) {
		var scope = this.currentScope();
		redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		scope.lexical.push(name);
		if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
	} else if (bindingType === BIND_SIMPLE_CATCH) {
		var scope$1 = this.currentScope();
		scope$1.lexical.push(name);
	} else if (bindingType === BIND_FUNCTION$1) {
		var scope$2 = this.currentScope();
		if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
		scope$2.functions.push(name);
	} else for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; --i$1) {
		var scope$3 = this.scopeStack[i$1];
		if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
			redeclared = true;
			break;
		}
		scope$3.var.push(name);
		if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
		if (scope$3.flags & SCOPE_VAR) break;
	}
	if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
};
pp$3.checkLocalExport = function(id) {
	if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
};
pp$3.currentScope = function() {
	return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) return scope;
	}
};
pp$3.currentThisScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) return scope;
	}
};
var Node = function Node$8(parser, pos, loc) {
	this.type = "";
	this.start = pos;
	this.end = 0;
	if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
	if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
	if (parser.options.ranges) this.range = [pos, 0];
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
	return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
	return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
	node.type = type;
	node.end = pos;
	if (this.options.locations) node.loc.end = loc;
	if (this.options.ranges) node.range[1] = pos;
	return node;
}
pp$2.finishNode = function(node, type) {
	return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
	return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
	var newNode = new Node(this, node.start, this.startLoc);
	for (var prop in node) newNode[prop] = node[prop];
	return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
	9: ecma9BinaryProperties,
	10: ecma10BinaryProperties,
	11: ecma11BinaryProperties,
	12: ecma12BinaryProperties,
	13: ecma13BinaryProperties,
	14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
	9: "",
	10: "",
	11: "",
	12: "",
	13: "",
	14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
	9: ecma9ScriptValues,
	10: ecma10ScriptValues,
	11: ecma11ScriptValues,
	12: ecma12ScriptValues,
	13: ecma13ScriptValues,
	14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion$1) {
	var d = data[ecmaVersion$1] = {
		binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion$1] + " " + unicodeGeneralCategoryValues),
		binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion$1]),
		nonBinary: {
			General_Category: wordsRegexp(unicodeGeneralCategoryValues),
			Script: wordsRegexp(unicodeScriptValues[ecmaVersion$1])
		}
	};
	d.nonBinary.Script_Extensions = d.nonBinary.Script;
	d.nonBinary.gc = d.nonBinary.General_Category;
	d.nonBinary.sc = d.nonBinary.Script;
	d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (var i = 0, list = [
	9,
	10,
	11,
	12,
	13,
	14
]; i < list.length; i += 1) {
	var ecmaVersion = list[i];
	buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser.prototype;
var BranchID = function BranchID$1(parent, base) {
	this.parent = parent;
	this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
	for (var self$1 = this; self$1; self$1 = self$1.parent) for (var other = alt; other; other = other.parent) if (self$1.base === other.base && self$1 !== other) return true;
	return false;
};
BranchID.prototype.sibling = function sibling() {
	return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState$1(parser) {
	this.parser = parser;
	this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
	this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
	this.source = "";
	this.flags = "";
	this.start = 0;
	this.switchU = false;
	this.switchV = false;
	this.switchN = false;
	this.pos = 0;
	this.lastIntValue = 0;
	this.lastStringValue = "";
	this.lastAssertionIsQuantifiable = false;
	this.numCapturingParens = 0;
	this.maxBackReference = 0;
	this.groupNames = Object.create(null);
	this.backReferenceNames = [];
	this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
	var unicodeSets = flags.indexOf("v") !== -1;
	var unicode$1 = flags.indexOf("u") !== -1;
	this.start = start | 0;
	this.source = pattern + "";
	this.flags = flags;
	if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		this.switchU = true;
		this.switchV = true;
		this.switchN = true;
	} else {
		this.switchU = unicode$1 && this.parser.options.ecmaVersion >= 6;
		this.switchV = false;
		this.switchN = unicode$1 && this.parser.options.ecmaVersion >= 9;
	}
};
RegExpValidationState.prototype.raise = function raise(message) {
	this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s$1 = this.source;
	var l$1$1 = s$1.length;
	if (i$1 >= l$1$1) return -1;
	var c$1 = s$1.charCodeAt(i$1);
	if (!(forceU || this.switchU) || c$1 <= 55295 || c$1 >= 57344 || i$1 + 1 >= l$1$1) return c$1;
	var next = s$1.charCodeAt(i$1 + 1);
	return next >= 56320 && next <= 57343 ? (c$1 << 10) + next - 56613888 : c$1;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s$1 = this.source;
	var l$1$1 = s$1.length;
	if (i$1 >= l$1$1) return l$1$1;
	var c$1 = s$1.charCodeAt(i$1), next;
	if (!(forceU || this.switchU) || c$1 <= 55295 || c$1 >= 57344 || i$1 + 1 >= l$1$1 || (next = s$1.charCodeAt(i$1 + 1)) < 56320 || next > 57343) return i$1 + 1;
	return i$1 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
	if (forceU === void 0) forceU = false;
	this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
	if (forceU === void 0) forceU = false;
	if (this.current(forceU) === ch) {
		this.advance(forceU);
		return true;
	}
	return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
	if (forceU === void 0) forceU = false;
	var pos = this.pos;
	for (var i$1 = 0, list$5 = chs; i$1 < list$5.length; i$1 += 1) {
		var ch = list$5[i$1];
		var current = this.at(pos, forceU);
		if (current === -1 || current !== ch) return false;
		pos = this.nextIndex(pos, forceU);
	}
	this.pos = pos;
	return true;
};
/**
* Validate the flags part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpFlags = function(state) {
	var validFlags = state.validFlags;
	var flags = state.flags;
	var u = false;
	var v = false;
	for (var i$1 = 0; i$1 < flags.length; i$1++) {
		var flag = flags.charAt(i$1);
		if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
		if (flags.indexOf(flag, i$1 + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
		if (flag === "u") u = true;
		if (flag === "v") v = true;
	}
	if (this.options.ecmaVersion >= 15 && u && v) this.raise(state.start, "Invalid regular expression flag");
};
function hasProp(obj) {
	for (var _ in obj) return true;
	return false;
}
/**
* Validate the pattern part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpPattern = function(state) {
	this.regexp_pattern(state);
	if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
		state.switchN = true;
		this.regexp_pattern(state);
	}
};
pp$1.regexp_pattern = function(state) {
	state.pos = 0;
	state.lastIntValue = 0;
	state.lastStringValue = "";
	state.lastAssertionIsQuantifiable = false;
	state.numCapturingParens = 0;
	state.maxBackReference = 0;
	state.groupNames = Object.create(null);
	state.backReferenceNames.length = 0;
	state.branchID = null;
	this.regexp_disjunction(state);
	if (state.pos !== state.source.length) {
		if (state.eat(
			41
			/* ) */
)) state.raise("Unmatched ')'");
		if (state.eat(
			93
			/* ] */
) || state.eat(
			125
			/* } */
)) state.raise("Lone quantifier brackets");
	}
	if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
	for (var i$1 = 0, list$5 = state.backReferenceNames; i$1 < list$5.length; i$1 += 1) {
		var name = list$5[i$1];
		if (!state.groupNames[name]) state.raise("Invalid named capture referenced");
	}
};
pp$1.regexp_disjunction = function(state) {
	var trackDisjunction = this.options.ecmaVersion >= 16;
	if (trackDisjunction) state.branchID = new BranchID(state.branchID, null);
	this.regexp_alternative(state);
	while (state.eat(
		124
		/* | */
)) {
		if (trackDisjunction) state.branchID = state.branchID.sibling();
		this.regexp_alternative(state);
	}
	if (trackDisjunction) state.branchID = state.branchID.parent;
	if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
	if (state.eat(
		123
		/* { */
)) state.raise("Lone quantifier brackets");
};
pp$1.regexp_alternative = function(state) {
	while (state.pos < state.source.length && this.regexp_eatTerm(state));
};
pp$1.regexp_eatTerm = function(state) {
	if (this.regexp_eatAssertion(state)) {
		if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
			if (state.switchU) state.raise("Invalid quantifier");
		}
		return true;
	}
	if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		this.regexp_eatQuantifier(state);
		return true;
	}
	return false;
};
pp$1.regexp_eatAssertion = function(state) {
	var start = state.pos;
	state.lastAssertionIsQuantifiable = false;
	if (state.eat(
		94
		/* ^ */
) || state.eat(
		36
		/* $ */
)) return true;
	if (state.eat(
		92
		/* \ */
)) {
		if (state.eat(
			66
			/* B */
) || state.eat(
			98
			/* b */
)) return true;
		state.pos = start;
	}
	if (state.eat(
		40
		/* ( */
) && state.eat(
		63
		/* ? */
)) {
		var lookbehind = false;
		if (this.options.ecmaVersion >= 9) lookbehind = state.eat(
			60
			/* < */
);
		if (state.eat(
			61
			/* = */
) || state.eat(
			33
			/* ! */
)) {
			this.regexp_disjunction(state);
			if (!state.eat(
				41
				/* ) */
)) state.raise("Unterminated group");
			state.lastAssertionIsQuantifiable = !lookbehind;
			return true;
		}
	}
	state.pos = start;
	return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
	if (noError === void 0) noError = false;
	if (this.regexp_eatQuantifierPrefix(state, noError)) {
		state.eat(
			63
			/* ? */
);
		return true;
	}
	return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
	return state.eat(
		42
		/* * */
) || state.eat(
		43
		/* + */
) || state.eat(
		63
		/* ? */
) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
	var start = state.pos;
	if (state.eat(
		123
		/* { */
)) {
		var min = 0, max = -1;
		if (this.regexp_eatDecimalDigits(state)) {
			min = state.lastIntValue;
			if (state.eat(
				44
				/* , */
) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
			if (state.eat(
				125
				/* } */
)) {
				if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
				return true;
			}
		}
		if (state.switchU && !noError) state.raise("Incomplete quantifier");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatAtom = function(state) {
	return this.regexp_eatPatternCharacters(state) || state.eat(
		46
		/* . */
) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
	var start = state.pos;
	if (state.eat(
		92
		/* \ */
)) {
		if (this.regexp_eatAtomEscape(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
	var start = state.pos;
	if (state.eat(
		40
		/* ( */
)) {
		if (state.eat(
			63
			/* ? */
)) {
			if (this.options.ecmaVersion >= 16) {
				var addModifiers = this.regexp_eatModifiers(state);
				var hasHyphen = state.eat(
					45
					/* - */
);
				if (addModifiers || hasHyphen) {
					for (var i$1 = 0; i$1 < addModifiers.length; i$1++) {
						var modifier = addModifiers.charAt(i$1);
						if (addModifiers.indexOf(modifier, i$1 + 1) > -1) state.raise("Duplicate regular expression modifiers");
					}
					if (hasHyphen) {
						var removeModifiers = this.regexp_eatModifiers(state);
						if (!addModifiers && !removeModifiers && state.current() === 58) state.raise("Invalid regular expression modifiers");
						for (var i$1$1 = 0; i$1$1 < removeModifiers.length; i$1$1++) {
							var modifier$1 = removeModifiers.charAt(i$1$1);
							if (removeModifiers.indexOf(modifier$1, i$1$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) state.raise("Duplicate regular expression modifiers");
						}
					}
				}
			}
			if (state.eat(
				58
				/* : */
)) {
				this.regexp_disjunction(state);
				if (state.eat(
					41
					/* ) */
)) return true;
				state.raise("Unterminated group");
			}
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
	if (state.eat(
		40
		/* ( */
)) {
		if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
else if (state.current() === 63) state.raise("Invalid group");
		this.regexp_disjunction(state);
		if (state.eat(
			41
			/* ) */
)) {
			state.numCapturingParens += 1;
			return true;
		}
		state.raise("Unterminated group");
	}
	return false;
};
pp$1.regexp_eatModifiers = function(state) {
	var modifiers = "";
	var ch = 0;
	while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
		modifiers += codePointToString(ch);
		state.advance();
	}
	return modifiers;
};
function isRegularExpressionModifier(ch) {
	return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
	return state.eat(
		46
		/* . */
) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
	if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
	return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
	var ch = state.current();
	if (isSyntaxCharacter(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isSyntaxCharacter(ch) {
	return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
	var start = state.pos;
	var ch = 0;
	while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) state.advance();
	return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
	var ch = state.current();
	if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_groupSpecifier = function(state) {
	if (state.eat(
		63
		/* ? */
)) {
		if (!this.regexp_eatGroupName(state)) state.raise("Invalid group");
		var trackDisjunction = this.options.ecmaVersion >= 16;
		var known = state.groupNames[state.lastStringValue];
		if (known) if (trackDisjunction) for (var i$1 = 0, list$5 = known; i$1 < list$5.length; i$1 += 1) {
			var altID = list$5[i$1];
			if (!altID.separatedFrom(state.branchID)) state.raise("Duplicate capture group name");
		}
else state.raise("Duplicate capture group name");
		if (trackDisjunction) (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
else state.groupNames[state.lastStringValue] = true;
	}
};
pp$1.regexp_eatGroupName = function(state) {
	state.lastStringValue = "";
	if (state.eat(
		60
		/* < */
)) {
		if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
			62
			/* > */
)) return true;
		state.raise("Invalid capture group name");
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
	state.lastStringValue = "";
	if (this.regexp_eatRegExpIdentifierStart(state)) {
		state.lastStringValue += codePointToString(state.lastIntValue);
		while (this.regexp_eatRegExpIdentifierPart(state)) state.lastStringValue += codePointToString(state.lastIntValue);
		return true;
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierStart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierStart(ch) {
	return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierPart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierPart(ch) {
	return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
	if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
	if (state.switchU) {
		if (state.current() === 99) state.raise("Invalid unicode escape");
		state.raise("Invalid escape");
	}
	return false;
};
pp$1.regexp_eatBackReference = function(state) {
	var start = state.pos;
	if (this.regexp_eatDecimalEscape(state)) {
		var n$1 = state.lastIntValue;
		if (state.switchU) {
			if (n$1 > state.maxBackReference) state.maxBackReference = n$1;
			return true;
		}
		if (n$1 <= state.numCapturingParens) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatKGroupName = function(state) {
	if (state.eat(
		107
		/* k */
)) {
		if (this.regexp_eatGroupName(state)) {
			state.backReferenceNames.push(state.lastStringValue);
			return true;
		}
		state.raise("Invalid named reference");
	}
	return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
	return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
	var start = state.pos;
	if (state.eat(
		99
		/* c */
)) {
		if (this.regexp_eatControlLetter(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatZero = function(state) {
	if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
		state.lastIntValue = 0;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlEscape = function(state) {
	var ch = state.current();
	if (ch === 116) {
		state.lastIntValue = 9;
		state.advance();
		return true;
	}
	if (ch === 110) {
		state.lastIntValue = 10;
		state.advance();
		return true;
	}
	if (ch === 118) {
		state.lastIntValue = 11;
		state.advance();
		return true;
	}
	if (ch === 102) {
		state.lastIntValue = 12;
		state.advance();
		return true;
	}
	if (ch === 114) {
		state.lastIntValue = 13;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlLetter = function(state) {
	var ch = state.current();
	if (isControlLetter(ch)) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
function isControlLetter(ch) {
	return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
	if (forceU === void 0) forceU = false;
	var start = state.pos;
	var switchU = forceU || state.switchU;
	if (state.eat(
		117
		/* u */
)) {
		if (this.regexp_eatFixedHexDigits(state, 4)) {
			var lead = state.lastIntValue;
			if (switchU && lead >= 55296 && lead <= 56319) {
				var leadSurrogateEnd = state.pos;
				if (state.eat(
					92
					/* \ */
) && state.eat(
					117
					/* u */
) && this.regexp_eatFixedHexDigits(state, 4)) {
					var trail = state.lastIntValue;
					if (trail >= 56320 && trail <= 57343) {
						state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
						return true;
					}
				}
				state.pos = leadSurrogateEnd;
				state.lastIntValue = lead;
			}
			return true;
		}
		if (switchU && state.eat(
			123
			/* { */
) && this.regexp_eatHexDigits(state) && state.eat(
			125
			/* } */
) && isValidUnicode(state.lastIntValue)) return true;
		if (switchU) state.raise("Invalid unicode escape");
		state.pos = start;
	}
	return false;
};
function isValidUnicode(ch) {
	return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
	if (state.switchU) {
		if (this.regexp_eatSyntaxCharacter(state)) return true;
		if (state.eat(
			47
			/* / */
)) {
			state.lastIntValue = 47;
			return true;
		}
		return false;
	}
	var ch = state.current();
	if (ch !== 99 && (!state.switchN || ch !== 107)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
	state.lastIntValue = 0;
	var ch = state.current();
	if (ch >= 49 && ch <= 57) {
		do {
			state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
			state.advance();
		} while ((ch = state.current()) >= 48 && ch <= 57);
		return true;
	}
	return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
	var ch = state.current();
	if (isCharacterClassEscape(ch)) {
		state.lastIntValue = -1;
		state.advance();
		return CharSetOk;
	}
	var negate = false;
	if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
		state.lastIntValue = -1;
		state.advance();
		var result;
		if (state.eat(
			123
			/* { */
) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
			125
			/* } */
)) {
			if (negate && result === CharSetString) state.raise("Invalid property name");
			return result;
		}
		state.raise("Invalid property name");
	}
	return CharSetNone;
};
function isCharacterClassEscape(ch) {
	return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
	var start = state.pos;
	if (this.regexp_eatUnicodePropertyName(state) && state.eat(
		61
		/* = */
)) {
		var name = state.lastStringValue;
		if (this.regexp_eatUnicodePropertyValue(state)) {
			var value = state.lastStringValue;
			this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
			return CharSetOk;
		}
	}
	state.pos = start;
	if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		var nameOrValue = state.lastStringValue;
		return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
	}
	return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
	if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
	if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
	if (state.unicodeProperties.binary.test(nameOrValue)) return CharSetOk;
	if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return CharSetString;
	state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyNameCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
	return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyValueCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
	return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
	return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
	if (state.eat(
		91
		/* [ */
)) {
		var negate = state.eat(
			94
			/* ^ */
);
		var result = this.regexp_classContents(state);
		if (!state.eat(
			93
			/* ] */
)) state.raise("Unterminated character class");
		if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
		return true;
	}
	return false;
};
pp$1.regexp_classContents = function(state) {
	if (state.current() === 93) return CharSetOk;
	if (state.switchV) return this.regexp_classSetExpression(state);
	this.regexp_nonEmptyClassRanges(state);
	return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
	while (this.regexp_eatClassAtom(state)) {
		var left = state.lastIntValue;
		if (state.eat(
			45
			/* - */
) && this.regexp_eatClassAtom(state)) {
			var right = state.lastIntValue;
			if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
		}
	}
};
pp$1.regexp_eatClassAtom = function(state) {
	var start = state.pos;
	if (state.eat(
		92
		/* \ */
)) {
		if (this.regexp_eatClassEscape(state)) return true;
		if (state.switchU) {
			var ch$1 = state.current();
			if (ch$1 === 99 || isOctalDigit(ch$1)) state.raise("Invalid class escape");
			state.raise("Invalid escape");
		}
		state.pos = start;
	}
	var ch = state.current();
	if (ch !== 93) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatClassEscape = function(state) {
	var start = state.pos;
	if (state.eat(
		98
		/* b */
)) {
		state.lastIntValue = 8;
		return true;
	}
	if (state.switchU && state.eat(
		45
		/* - */
)) {
		state.lastIntValue = 45;
		return true;
	}
	if (!state.switchU && state.eat(
		99
		/* c */
)) {
		if (this.regexp_eatClassControlLetter(state)) return true;
		state.pos = start;
	}
	return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
	var result = CharSetOk, subResult;
	if (this.regexp_eatClassSetRange(state));
else if (subResult = this.regexp_eatClassSetOperand(state)) {
		if (subResult === CharSetString) result = CharSetString;
		var start = state.pos;
		while (state.eatChars(
			[38, 38]
			/* && */
)) {
			if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
				if (subResult !== CharSetString) result = CharSetOk;
				continue;
			}
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
		while (state.eatChars(
			[45, 45]
			/* -- */
)) {
			if (this.regexp_eatClassSetOperand(state)) continue;
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
	} else state.raise("Invalid character in character class");
	for (;;) {
		if (this.regexp_eatClassSetRange(state)) continue;
		subResult = this.regexp_eatClassSetOperand(state);
		if (!subResult) return result;
		if (subResult === CharSetString) result = CharSetString;
	}
};
pp$1.regexp_eatClassSetRange = function(state) {
	var start = state.pos;
	if (this.regexp_eatClassSetCharacter(state)) {
		var left = state.lastIntValue;
		if (state.eat(
			45
			/* - */
) && this.regexp_eatClassSetCharacter(state)) {
			var right = state.lastIntValue;
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
			return true;
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
	if (this.regexp_eatClassSetCharacter(state)) return CharSetOk;
	return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
	var start = state.pos;
	if (state.eat(
		91
		/* [ */
)) {
		var negate = state.eat(
			94
			/* ^ */
);
		var result = this.regexp_classContents(state);
		if (state.eat(
			93
			/* ] */
)) {
			if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
			return result;
		}
		state.pos = start;
	}
	if (state.eat(
		92
		/* \ */
)) {
		var result$1 = this.regexp_eatCharacterClassEscape(state);
		if (result$1) return result$1;
		state.pos = start;
	}
	return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
	var start = state.pos;
	if (state.eatChars(
		[92, 113]
		/* \q */
)) {
		if (state.eat(
			123
			/* { */
)) {
			var result = this.regexp_classStringDisjunctionContents(state);
			if (state.eat(
				125
				/* } */
)) return result;
		} else state.raise("Invalid escape");
		state.pos = start;
	}
	return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
	var result = this.regexp_classString(state);
	while (state.eat(
		124
		/* | */
)) if (this.regexp_classString(state) === CharSetString) result = CharSetString;
	return result;
};
pp$1.regexp_classString = function(state) {
	var count = 0;
	while (this.regexp_eatClassSetCharacter(state)) count++;
	return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
	var start = state.pos;
	if (state.eat(
		92
		/* \ */
)) {
		if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;
		if (state.eat(
			98
			/* b */
)) {
			state.lastIntValue = 8;
			return true;
		}
		state.pos = start;
		return false;
	}
	var ch = state.current();
	if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) return false;
	if (isClassSetSyntaxCharacter(ch)) return false;
	state.advance();
	state.lastIntValue = ch;
	return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
	return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
	return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
	var ch = state.current();
	if (isClassSetReservedPunctuator(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isClassSetReservedPunctuator(ch) {
	return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
	var ch = state.current();
	if (isDecimalDigit(ch) || ch === 95) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
	var start = state.pos;
	if (state.eat(
		120
		/* x */
)) {
		if (this.regexp_eatFixedHexDigits(state, 2)) return true;
		if (state.switchU) state.raise("Invalid escape");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isDecimalDigit(ch = state.current())) {
		state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
		state.advance();
	}
	return state.pos !== start;
};
function isDecimalDigit(ch) {
	return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isHexDigit(ch = state.current())) {
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return state.pos !== start;
};
function isHexDigit(ch) {
	return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
	if (ch >= 65 && ch <= 70) return 10 + (ch - 65);
	if (ch >= 97 && ch <= 102) return 10 + (ch - 97);
	return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
	if (this.regexp_eatOctalDigit(state)) {
		var n1 = state.lastIntValue;
		if (this.regexp_eatOctalDigit(state)) {
			var n2 = state.lastIntValue;
			if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
else state.lastIntValue = n1 * 8 + n2;
		} else state.lastIntValue = n1;
		return true;
	}
	return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
	var ch = state.current();
	if (isOctalDigit(ch)) {
		state.lastIntValue = ch - 48;
		state.advance();
		return true;
	}
	state.lastIntValue = 0;
	return false;
};
function isOctalDigit(ch) {
	return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
	var start = state.pos;
	state.lastIntValue = 0;
	for (var i$1 = 0; i$1 < length; ++i$1) {
		var ch = state.current();
		if (!isHexDigit(ch)) {
			state.pos = start;
			return false;
		}
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return true;
};
var Token = function Token$1(p$1) {
	this.type = p$1.type;
	this.value = p$1.value;
	this.start = p$1.start;
	this.end = p$1.end;
	if (p$1.options.locations) this.loc = new SourceLocation(p$1, p$1.startLoc, p$1.endLoc);
	if (p$1.options.ranges) this.range = [p$1.start, p$1.end];
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
	if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
	if (this.options.onToken) this.options.onToken(new Token(this));
	this.lastTokEnd = this.end;
	this.lastTokStart = this.start;
	this.lastTokEndLoc = this.endLoc;
	this.lastTokStartLoc = this.startLoc;
	this.nextToken();
};
pp.getToken = function() {
	this.next();
	return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
	var this$1$1 = this;
	return { next: function() {
		var token = this$1$1.getToken();
		return {
			done: token.type === types$1.eof,
			value: token
		};
	} };
};
pp.nextToken = function() {
	var curContext = this.curContext();
	if (!curContext || !curContext.preserveSpace) this.skipSpace();
	this.start = this.pos;
	if (this.options.locations) this.startLoc = this.curPosition();
	if (this.pos >= this.input.length) return this.finishToken(types$1.eof);
	if (curContext.override) return curContext.override(this);
else this.readToken(this.fullCharCodeAtPos());
};
pp.readToken = function(code) {
	if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) return this.readWord();
	return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
	var code = this.input.charCodeAt(this.pos);
	if (code <= 55295 || code >= 56320) return code;
	var next = this.input.charCodeAt(this.pos + 1);
	return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
	var startLoc = this.options.onComment && this.curPosition();
	var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
	if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	this.pos = end + 2;
	if (this.options.locations) for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		++this.curLine;
		pos = this.lineStart = nextBreak;
	}
	if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};
pp.skipLineComment = function(startSkip) {
	var start = this.pos;
	var startLoc = this.options.onComment && this.curPosition();
	var ch = this.input.charCodeAt(this.pos += startSkip);
	while (this.pos < this.input.length && !isNewLine(ch)) ch = this.input.charCodeAt(++this.pos);
	if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function() {
	loop: while (this.pos < this.input.length) {
		var ch = this.input.charCodeAt(this.pos);
		switch (ch) {
			case 32:
			case 160:
				++this.pos;
				break;
			case 13: if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
			case 10:
			case 8232:
			case 8233:
				++this.pos;
				if (this.options.locations) {
					++this.curLine;
					this.lineStart = this.pos;
				}
				break;
			case 47:
				switch (this.input.charCodeAt(this.pos + 1)) {
					case 42:
						this.skipBlockComment();
						break;
					case 47:
						this.skipLineComment(2);
						break;
					default: break loop;
				}
				break;
			default: if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
else break loop;
		}
	}
};
pp.finishToken = function(type, val) {
	this.end = this.pos;
	if (this.options.locations) this.endLoc = this.curPosition();
	var prevType = this.type;
	this.type = type;
	this.value = val;
	this.updateContext(prevType);
};
pp.readToken_dot = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next >= 48 && next <= 57) return this.readNumber(true);
	var next2 = this.input.charCodeAt(this.pos + 2);
	if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
		this.pos += 3;
		return this.finishToken(types$1.ellipsis);
	} else {
		++this.pos;
		return this.finishToken(types$1.dot);
	}
};
pp.readToken_slash = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (this.exprAllowed) {
		++this.pos;
		return this.readRegexp();
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	var tokentype = code === 42 ? types$1.star : types$1.modulo;
	if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		++size;
		tokentype = types$1.starstar;
		next = this.input.charCodeAt(this.pos + 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, size + 1);
	return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (this.options.ecmaVersion >= 12) {
			var next2 = this.input.charCodeAt(this.pos + 2);
			if (next2 === 61) return this.finishOp(types$1.assign, 3);
		}
		return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
			this.skipLineComment(3);
			this.skipSpace();
			return this.nextToken();
		}
		return this.finishOp(types$1.incDec, 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	if (next === code) {
		size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1.assign, size + 1);
		return this.finishOp(types$1.bitShift, size);
	}
	if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
		this.skipLineComment(4);
		this.skipSpace();
		return this.nextToken();
	}
	if (next === 61) size = 2;
	return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === 61) return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
		this.pos += 2;
		return this.finishToken(types$1.arrow);
	}
	return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	if (ecmaVersion$1 >= 11) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === 46) {
			var next2 = this.input.charCodeAt(this.pos + 2);
			if (next2 < 48 || next2 > 57) return this.finishOp(types$1.questionDot, 2);
		}
		if (next === 63) {
			if (ecmaVersion$1 >= 12) {
				var next2$1 = this.input.charCodeAt(this.pos + 2);
				if (next2$1 === 61) return this.finishOp(types$1.assign, 3);
			}
			return this.finishOp(types$1.coalesce, 2);
		}
	}
	return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	var code = 35;
	if (ecmaVersion$1 >= 13) {
		++this.pos;
		code = this.fullCharCodeAtPos();
		if (isIdentifierStart(code, true) || code === 92) return this.finishToken(types$1.privateId, this.readWord1());
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
	switch (code) {
		case 46: return this.readToken_dot();
		case 40:
			++this.pos;
			return this.finishToken(types$1.parenL);
		case 41:
			++this.pos;
			return this.finishToken(types$1.parenR);
		case 59:
			++this.pos;
			return this.finishToken(types$1.semi);
		case 44:
			++this.pos;
			return this.finishToken(types$1.comma);
		case 91:
			++this.pos;
			return this.finishToken(types$1.bracketL);
		case 93:
			++this.pos;
			return this.finishToken(types$1.bracketR);
		case 123:
			++this.pos;
			return this.finishToken(types$1.braceL);
		case 125:
			++this.pos;
			return this.finishToken(types$1.braceR);
		case 58:
			++this.pos;
			return this.finishToken(types$1.colon);
		case 96:
			if (this.options.ecmaVersion < 6) break;
			++this.pos;
			return this.finishToken(types$1.backQuote);
		case 48:
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 120 || next === 88) return this.readRadixNumber(16);
			if (this.options.ecmaVersion >= 6) {
				if (next === 111 || next === 79) return this.readRadixNumber(8);
				if (next === 98 || next === 66) return this.readRadixNumber(2);
			}
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57: return this.readNumber(false);
		case 34:
		case 39: return this.readString(code);
		case 47: return this.readToken_slash();
		case 37:
		case 42: return this.readToken_mult_modulo_exp(code);
		case 124:
		case 38: return this.readToken_pipe_amp(code);
		case 94: return this.readToken_caret();
		case 43:
		case 45: return this.readToken_plus_min(code);
		case 60:
		case 62: return this.readToken_lt_gt(code);
		case 61:
		case 33: return this.readToken_eq_excl(code);
		case 63: return this.readToken_question();
		case 126: return this.finishOp(types$1.prefix, 1);
		case 35: return this.readToken_numberSign();
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
	var str = this.input.slice(this.pos, this.pos + size);
	this.pos += size;
	return this.finishToken(type, str);
};
pp.readRegexp = function() {
	var escaped, inClass, start = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
		var ch = this.input.charAt(this.pos);
		if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
		if (!escaped) {
			if (ch === "[") inClass = true;
else if (ch === "]" && inClass) inClass = false;
else if (ch === "/" && !inClass) break;
			escaped = ch === "\\";
		} else escaped = false;
		++this.pos;
	}
	var pattern = this.input.slice(start, this.pos);
	++this.pos;
	var flagsStart = this.pos;
	var flags = this.readWord1();
	if (this.containsEsc) this.unexpected(flagsStart);
	var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
	state.reset(start, pattern, flags);
	this.validateRegExpFlags(state);
	this.validateRegExpPattern(state);
	var value = null;
	try {
		value = new RegExp(pattern, flags);
	} catch (e) {}
	return this.finishToken(types$1.regexp, {
		pattern,
		flags,
		value
	});
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
	var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
	var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
	var start = this.pos, total = 0, lastCode = 0;
	for (var i$1 = 0, e = len == null ? Infinity : len; i$1 < e; ++i$1, ++this.pos) {
		var code = this.input.charCodeAt(this.pos), val = void 0;
		if (allowSeparators && code === 95) {
			if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
			if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
			if (i$1 === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
			lastCode = code;
			continue;
		}
		if (code >= 97) val = code - 97 + 10;
else if (code >= 65) val = code - 65 + 10;
else if (code >= 48 && code <= 57) val = code - 48;
else val = Infinity;
		if (val >= radix) break;
		lastCode = code;
		total = total * radix + val;
	}
	if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
	if (this.pos === start || len != null && this.pos - start !== len) return null;
	return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
	if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
	return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
	if (typeof BigInt !== "function") return null;
	return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
	var start = this.pos;
	this.pos += 2;
	var val = this.readInt(radix);
	if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		val = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
	} else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
	var start = this.pos;
	if (!startsWithDot && this.readInt(10, undefined, true) === null) this.raise(start, "Invalid number");
	var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	if (octal && this.strict) this.raise(start, "Invalid number");
	var next = this.input.charCodeAt(this.pos);
	if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
		if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
		return this.finishToken(types$1.num, val$1);
	}
	if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
	if (next === 46 && !octal) {
		++this.pos;
		this.readInt(10);
		next = this.input.charCodeAt(this.pos);
	}
	if ((next === 69 || next === 101) && !octal) {
		next = this.input.charCodeAt(++this.pos);
		if (next === 43 || next === 45) ++this.pos;
		if (this.readInt(10) === null) this.raise(start, "Invalid number");
	}
	if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	var val = stringToNumber(this.input.slice(start, this.pos), octal);
	return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
	var ch = this.input.charCodeAt(this.pos), code;
	if (ch === 123) {
		if (this.options.ecmaVersion < 6) this.unexpected();
		var codePos = ++this.pos;
		code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		++this.pos;
		if (code > 1114111) this.invalidStringToken(codePos, "Code point out of bounds");
	} else code = this.readHexChar(4);
	return code;
};
pp.readString = function(quote$1) {
	var out = "", chunkStart = ++this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === quote$1) break;
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(false);
			chunkStart = this.pos;
		} else if (ch === 8232 || ch === 8233) {
			if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
			++this.pos;
			if (this.options.locations) {
				this.curLine++;
				this.lineStart = this.pos;
			}
		} else {
			if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
			++this.pos;
		}
	}
	out += this.input.slice(chunkStart, this.pos++);
	return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
	this.inTemplateElement = true;
	try {
		this.readTmplToken();
	} catch (err) {
		if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
else throw err;
	}
	this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
	if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
else this.raise(position, message);
};
pp.readTmplToken = function() {
	var out = "", chunkStart = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
			if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) if (ch === 36) {
				this.pos += 2;
				return this.finishToken(types$1.dollarBraceL);
			} else {
				++this.pos;
				return this.finishToken(types$1.backQuote);
			}
			out += this.input.slice(chunkStart, this.pos);
			return this.finishToken(types$1.template, out);
		}
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(true);
			chunkStart = this.pos;
		} else if (isNewLine(ch)) {
			out += this.input.slice(chunkStart, this.pos);
			++this.pos;
			switch (ch) {
				case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
				case 10:
					out += "\n";
					break;
				default:
					out += String.fromCharCode(ch);
					break;
			}
			if (this.options.locations) {
				++this.curLine;
				this.lineStart = this.pos;
			}
			chunkStart = this.pos;
		} else ++this.pos;
	}
};
pp.readInvalidTemplateToken = function() {
	for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
		case "\\":
			++this.pos;
			break;
		case "$": if (this.input[this.pos + 1] !== "{") break;
		case "`": return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
		case "\r": if (this.input[this.pos + 1] === "\n") ++this.pos;
		case "\n":
		case "\u2028":
		case "\u2029":
			++this.curLine;
			this.lineStart = this.pos + 1;
			break;
	}
	this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
	var ch = this.input.charCodeAt(++this.pos);
	++this.pos;
	switch (ch) {
		case 110: return "\n";
		case 114: return "\r";
		case 120: return String.fromCharCode(this.readHexChar(2));
		case 117: return codePointToString(this.readCodePoint());
		case 116: return "	";
		case 98: return "\b";
		case 118: return "\v";
		case 102: return "\f";
		case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
		case 10:
			if (this.options.locations) {
				this.lineStart = this.pos;
				++this.curLine;
			}
			return "";
		case 56:
		case 57:
			if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
			if (inTemplate) {
				var codePos = this.pos - 1;
				this.invalidStringToken(codePos, "Invalid escape sequence in template string");
			}
		default:
			if (ch >= 48 && ch <= 55) {
				var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
				var octal = parseInt(octalStr, 8);
				if (octal > 255) {
					octalStr = octalStr.slice(0, -1);
					octal = parseInt(octalStr, 8);
				}
				this.pos += octalStr.length - 1;
				ch = this.input.charCodeAt(this.pos);
				if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
				return String.fromCharCode(octal);
			}
			if (isNewLine(ch)) {
				if (this.options.locations) {
					this.lineStart = this.pos;
					++this.curLine;
				}
				return "";
			}
			return String.fromCharCode(ch);
	}
};
pp.readHexChar = function(len) {
	var codePos = this.pos;
	var n$1 = this.readInt(16, len);
	if (n$1 === null) this.invalidStringToken(codePos, "Bad character escape sequence");
	return n$1;
};
pp.readWord1 = function() {
	this.containsEsc = false;
	var word = "", first = true, chunkStart = this.pos;
	var astral = this.options.ecmaVersion >= 6;
	while (this.pos < this.input.length) {
		var ch = this.fullCharCodeAtPos();
		if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2;
else if (ch === 92) {
			this.containsEsc = true;
			word += this.input.slice(chunkStart, this.pos);
			var escStart = this.pos;
			if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
			++this.pos;
			var esc = this.readCodePoint();
			if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
			word += codePointToString(esc);
			chunkStart = this.pos;
		} else break;
		first = false;
	}
	return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
	var word = this.readWord1();
	var type = types$1.name;
	if (this.keywords.test(word)) type = keywords[word];
	return this.finishToken(type, word);
};
var version = "8.14.1";
Parser.acorn = {
	Parser,
	version,
	defaultOptions,
	Position,
	SourceLocation,
	getLineInfo,
	Node,
	TokenType,
	tokTypes: types$1,
	keywordTypes: keywords,
	TokContext,
	tokContexts: types,
	isIdentifierChar,
	isIdentifierStart,
	Token,
	isNewLine,
	lineBreak,
	lineBreakG,
	nonASCIIwhitespace
};
function parse(input, options) {
	return Parser.parse(input, options);
}
function parseExpressionAt(input, pos, options) {
	return Parser.parseExpressionAt(input, pos, options);
}
function tokenizer(input, options) {
	return Parser.tokenizer(input, options);
}
var startsExpr = true;
function kwLike(_name, options = {}) {
	return new TokenType("name", options);
}
var acornTypeScriptMap = /* @__PURE__ */ new WeakMap();
function generateAcornTypeScript(_acorn) {
	const acorn = _acorn.Parser.acorn || _acorn;
	let acornTypeScript = acornTypeScriptMap.get(acorn);
	if (!acornTypeScript) {
		let tokenIsLiteralPropertyName = function(token) {
			return [
				...[
					types$1.name,
					types$1.string,
					types$1.num
				],
				...Object.values(keywords),
				...Object.values(tsKwTokenType)
			].includes(token);
		}, tokenIsKeywordOrIdentifier = function(token) {
			return [
				...[types$1.name],
				...Object.values(keywords),
				...Object.values(tsKwTokenType)
			].includes(token);
		}, tokenIsIdentifier = function(token) {
			return [...Object.values(tsKwTokenType), types$1.name].includes(token);
		}, tokenIsTSDeclarationStart = function(token) {
			return [
				tsKwTokenType.abstract,
				tsKwTokenType.declare,
				tsKwTokenType.enum,
				tsKwTokenType.module,
				tsKwTokenType.namespace,
				tsKwTokenType.interface,
				tsKwTokenType.type
			].includes(token);
		}, tokenIsTSTypeOperator = function(token) {
			return [
				tsKwTokenType.keyof,
				tsKwTokenType.readonly,
				tsKwTokenType.unique
			].includes(token);
		}, tokenIsTemplate = function(token) {
			return token === types$1.invalidTemplate;
		};
		const tsKwTokenType = generateTsKwTokenType();
		const tsTokenType = generateTsTokenType();
		const tsTokenContext = generateTsTokenContext();
		const tsKeywordsRegExp = new RegExp(`^(?:${Object.keys(tsKwTokenType).join("|")})$`);
		tsTokenType.jsxTagStart.updateContext = function() {
			this.context.push(tsTokenContext.tc_expr);
			this.context.push(tsTokenContext.tc_oTag);
			this.exprAllowed = false;
		};
		tsTokenType.jsxTagEnd.updateContext = function(prevType) {
			let out = this.context.pop();
			if (out === tsTokenContext.tc_oTag && prevType === types$1.slash || out === tsTokenContext.tc_cTag) {
				this.context.pop();
				this.exprAllowed = this.curContext() === tsTokenContext.tc_expr;
			} else this.exprAllowed = true;
		};
		acornTypeScript = {
			tokTypes: {
				...tsKwTokenType,
				...tsTokenType
			},
			tokContexts: { ...tsTokenContext },
			keywordsRegExp: tsKeywordsRegExp,
			tokenIsLiteralPropertyName,
			tokenIsKeywordOrIdentifier,
			tokenIsIdentifier,
			tokenIsTSDeclarationStart,
			tokenIsTSTypeOperator,
			tokenIsTemplate
		};
	}
	return acornTypeScript;
}
function generateTsTokenContext() {
	return {
		tc_oTag: new TokContext("<tag", false, false),
		tc_cTag: new TokContext("</tag", false, false),
		tc_expr: new TokContext("<tag>...</tag>", true, true)
	};
}
function generateTsTokenType() {
	return {
		at: new TokenType("@"),
		jsxName: new TokenType("jsxName"),
		jsxText: new TokenType("jsxText", { beforeExpr: true }),
		jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
		jsxTagEnd: new TokenType("jsxTagEnd")
	};
}
function generateTsKwTokenType() {
	return {
		assert: kwLike("assert", { startsExpr }),
		asserts: kwLike("asserts", { startsExpr }),
		global: kwLike("global", { startsExpr }),
		keyof: kwLike("keyof", { startsExpr }),
		readonly: kwLike("readonly", { startsExpr }),
		unique: kwLike("unique", { startsExpr }),
		abstract: kwLike("abstract", { startsExpr }),
		declare: kwLike("declare", { startsExpr }),
		enum: kwLike("enum", { startsExpr }),
		module: kwLike("module", { startsExpr }),
		namespace: kwLike("namespace", { startsExpr }),
		interface: kwLike("interface", { startsExpr }),
		type: kwLike("type", { startsExpr })
	};
}
var TS_SCOPE_OTHER = 512;
var TS_SCOPE_TS_MODULE = 1024;
var BIND_KIND_VALUE = 1;
var BIND_KIND_TYPE = 2;
var BIND_SCOPE_VAR = 4;
var BIND_SCOPE_LEXICAL = 8;
var BIND_SCOPE_FUNCTION = 16;
var BIND_FLAGS_NONE = 64;
var BIND_FLAGS_CLASS = 128;
var BIND_FLAGS_TS_ENUM = 256;
var BIND_FLAGS_TS_CONST_ENUM = 512;
var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
var BIND_TS_INTERFACE = BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
var BIND_TS_TYPE = BIND_KIND_TYPE | 0;
var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
var BIND_TS_AMBIENT = 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var BIND_NONE = 0 | BIND_FLAGS_NONE;
var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | BIND_FLAGS_NONE;
var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
var BIND_TS_NAMESPACE = 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var CLASS_ELEMENT_FLAG_STATIC = 4;
var CLASS_ELEMENT_KIND_GETTER = 2;
var CLASS_ELEMENT_KIND_SETTER = 1;
var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
var skipWhiteSpaceToLineBreak = new RegExp(
	// Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or
	// possessive quantifiers, so we use a trick to prevent backtracking
	// when the look-ahead for line terminator fails.
	"(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
	"y"
	// sticky
);
var DestructuringErrors = class {
	constructor() {
		this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
	}
};
function isPrivateNameConflicted(privateNameMap, element) {
	const name = element.key.name;
	const curr = privateNameMap[name];
	let next = "true";
	if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
	if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
		privateNameMap[name] = "true";
		return false;
	} else if (!curr) {
		privateNameMap[name] = next;
		return false;
	} else return true;
}
function checkKeyName(node, name) {
	const { computed, key } = node;
	return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
var TypeScriptError = {
	AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
	AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
	AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
	AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
	CannotFindName: ({ name }) => `Cannot find name '${name}'.`,
	ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
	ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
	ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
	ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
	DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,
	DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
	DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
	DuplicateAccessibilityModifier: () => `Accessibility modifier already seen.`,
	DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,
	EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,
	EmptyTypeArguments: "Type argument list cannot be empty.",
	EmptyTypeParameters: "Type parameter list cannot be empty.",
	ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
	ImportAliasHasImportType: "An import alias can not use 'import type'.",
	IncompatibleModifiers: ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
	IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
	IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
	IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
	IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
	IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
	InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
	InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,
	InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,
	InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
	InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
	InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
	InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
	MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
	MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
	NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
	NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
	OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
	OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
	PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
	PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
	PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
	PrivateMethodsHasAccessibility: ({ modifier }) => `Private methods cannot have an accessibility modifier ('${modifier}').`,
	ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
	ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
	ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
	SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
	SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
	SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
	SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
	StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
	TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
	TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
	TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
	UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
	UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
	GenericsEndWithComma: `Trailing comma is not allowed at the end of generics.`,
	UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
	UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
	UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
	UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
	UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
	LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
};
var DecoratorsError = {
	UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
	DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
	TrailingDecorator: "Decorators must be attached to a class element.",
	SpreadElementDecorator: `Decorators can't be used with SpreadElement`
};
function generateParseDecorators(Parse, acornTypeScript, acorn) {
	const { tokTypes: tt } = acorn;
	const { tokTypes: tokTypes2 } = acornTypeScript;
	return class ParseDecorators extends Parse {
		takeDecorators(node) {
			const decorators = this.decoratorStack[this.decoratorStack.length - 1];
			if (decorators.length) {
				node.decorators = decorators;
				this.resetStartLocationFromNode(node, decorators[0]);
				this.decoratorStack[this.decoratorStack.length - 1] = [];
			}
		}
		parseDecorators(allowExport) {
			const currentContextDecorators = this.decoratorStack[this.decoratorStack.length - 1];
			while (this.match(tokTypes2.at)) {
				const decorator = this.parseDecorator();
				currentContextDecorators.push(decorator);
			}
			if (this.match(tt._export)) {
				if (!allowExport) this.unexpected();
			} else if (!this.canHaveLeadingDecorator()) this.raise(this.start, DecoratorsError.UnexpectedLeadingDecorator);
		}
		parseDecorator() {
			const node = this.startNode();
			this.next();
			this.decoratorStack.push([]);
			const startPos = this.start;
			const startLoc = this.startLoc;
			let expr;
			if (this.match(tt.parenL)) {
				const startPos2 = this.start;
				const startLoc2 = this.startLoc;
				this.next();
				expr = this.parseExpression();
				this.expect(tt.parenR);
				if (this.options.preserveParens) {
					let par = this.startNodeAt(startPos2, startLoc2);
					par.expression = expr;
					expr = this.finishNode(par, "ParenthesizedExpression");
				}
			} else {
				expr = this.parseIdent(false);
				while (this.eat(tt.dot)) {
					const node2 = this.startNodeAt(startPos, startLoc);
					node2.object = expr;
					node2.property = this.parseIdent(true);
					node2.computed = false;
					expr = this.finishNode(node2, "MemberExpression");
				}
			}
			node.expression = this.parseMaybeDecoratorArguments(expr);
			this.decoratorStack.pop();
			return this.finishNode(node, "Decorator");
		}
		parseMaybeDecoratorArguments(expr) {
			if (this.eat(tt.parenL)) {
				const node = this.startNodeAtNode(expr);
				node.callee = expr;
				node.arguments = this.parseExprList(tt.parenR, false);
				return this.finishNode(node, "CallExpression");
			}
			return expr;
		}
	};
}
var xhtml_default = {
	quot: "\"",
	amp: "&",
	apos: "'",
	lt: "<",
	gt: ">",
	nbsp: "\xA0",
	iexcl: "¡",
	cent: "¢",
	pound: "£",
	curren: "¤",
	yen: "¥",
	brvbar: "¦",
	sect: "§",
	uml: "¨",
	copy: "©",
	ordf: "ª",
	laquo: "«",
	not: "¬",
	shy: "­",
	reg: "®",
	macr: "¯",
	deg: "°",
	plusmn: "±",
	sup2: "²",
	sup3: "³",
	acute: "´",
	micro: "µ",
	para: "¶",
	middot: "·",
	cedil: "¸",
	sup1: "¹",
	ordm: "º",
	raquo: "»",
	frac14: "¼",
	frac12: "½",
	frac34: "¾",
	iquest: "¿",
	Agrave: "À",
	Aacute: "Á",
	Acirc: "Â",
	Atilde: "Ã",
	Auml: "Ä",
	Aring: "Å",
	AElig: "Æ",
	Ccedil: "Ç",
	Egrave: "È",
	Eacute: "É",
	Ecirc: "Ê",
	Euml: "Ë",
	Igrave: "Ì",
	Iacute: "Í",
	Icirc: "Î",
	Iuml: "Ï",
	ETH: "Ð",
	Ntilde: "Ñ",
	Ograve: "Ò",
	Oacute: "Ó",
	Ocirc: "Ô",
	Otilde: "Õ",
	Ouml: "Ö",
	times: "×",
	Oslash: "Ø",
	Ugrave: "Ù",
	Uacute: "Ú",
	Ucirc: "Û",
	Uuml: "Ü",
	Yacute: "Ý",
	THORN: "Þ",
	szlig: "ß",
	agrave: "à",
	aacute: "á",
	acirc: "â",
	atilde: "ã",
	auml: "ä",
	aring: "å",
	aelig: "æ",
	ccedil: "ç",
	egrave: "è",
	eacute: "é",
	ecirc: "ê",
	euml: "ë",
	igrave: "ì",
	iacute: "í",
	icirc: "î",
	iuml: "ï",
	eth: "ð",
	ntilde: "ñ",
	ograve: "ò",
	oacute: "ó",
	ocirc: "ô",
	otilde: "õ",
	ouml: "ö",
	divide: "÷",
	oslash: "ø",
	ugrave: "ù",
	uacute: "ú",
	ucirc: "û",
	uuml: "ü",
	yacute: "ý",
	thorn: "þ",
	yuml: "ÿ",
	OElig: "Œ",
	oelig: "œ",
	Scaron: "Š",
	scaron: "š",
	Yuml: "Ÿ",
	fnof: "ƒ",
	circ: "ˆ",
	tilde: "˜",
	Alpha: "Α",
	Beta: "Β",
	Gamma: "Γ",
	Delta: "Δ",
	Epsilon: "Ε",
	Zeta: "Ζ",
	Eta: "Η",
	Theta: "Θ",
	Iota: "Ι",
	Kappa: "Κ",
	Lambda: "Λ",
	Mu: "Μ",
	Nu: "Ν",
	Xi: "Ξ",
	Omicron: "Ο",
	Pi: "Π",
	Rho: "Ρ",
	Sigma: "Σ",
	Tau: "Τ",
	Upsilon: "Υ",
	Phi: "Φ",
	Chi: "Χ",
	Psi: "Ψ",
	Omega: "Ω",
	alpha: "α",
	beta: "β",
	gamma: "γ",
	delta: "δ",
	epsilon: "ε",
	zeta: "ζ",
	eta: "η",
	theta: "θ",
	iota: "ι",
	kappa: "κ",
	lambda: "λ",
	mu: "μ",
	nu: "ν",
	xi: "ξ",
	omicron: "ο",
	pi: "π",
	rho: "ρ",
	sigmaf: "ς",
	sigma: "σ",
	tau: "τ",
	upsilon: "υ",
	phi: "φ",
	chi: "χ",
	psi: "ψ",
	omega: "ω",
	thetasym: "ϑ",
	upsih: "ϒ",
	piv: "ϖ",
	ensp: " ",
	emsp: " ",
	thinsp: " ",
	zwnj: "‌",
	zwj: "‍",
	lrm: "‎",
	rlm: "‏",
	ndash: "–",
	mdash: "—",
	lsquo: "‘",
	rsquo: "’",
	sbquo: "‚",
	ldquo: "“",
	rdquo: "”",
	bdquo: "„",
	dagger: "†",
	Dagger: "‡",
	bull: "•",
	hellip: "…",
	permil: "‰",
	prime: "′",
	Prime: "″",
	lsaquo: "‹",
	rsaquo: "›",
	oline: "‾",
	frasl: "⁄",
	euro: "€",
	image: "ℑ",
	weierp: "℘",
	real: "ℜ",
	trade: "™",
	alefsym: "ℵ",
	larr: "←",
	uarr: "↑",
	rarr: "→",
	darr: "↓",
	harr: "↔",
	crarr: "↵",
	lArr: "⇐",
	uArr: "⇑",
	rArr: "⇒",
	dArr: "⇓",
	hArr: "⇔",
	forall: "∀",
	part: "∂",
	exist: "∃",
	empty: "∅",
	nabla: "∇",
	isin: "∈",
	notin: "∉",
	ni: "∋",
	prod: "∏",
	sum: "∑",
	minus: "−",
	lowast: "∗",
	radic: "√",
	prop: "∝",
	infin: "∞",
	ang: "∠",
	and: "∧",
	or: "∨",
	cap: "∩",
	cup: "∪",
	int: "∫",
	there4: "∴",
	sim: "∼",
	cong: "≅",
	asymp: "≈",
	ne: "≠",
	equiv: "≡",
	le: "≤",
	ge: "≥",
	sub: "⊂",
	sup: "⊃",
	nsub: "⊄",
	sube: "⊆",
	supe: "⊇",
	oplus: "⊕",
	otimes: "⊗",
	perp: "⊥",
	sdot: "⋅",
	lceil: "⌈",
	rceil: "⌉",
	lfloor: "⌊",
	rfloor: "⌋",
	lang: "〈",
	rang: "〉",
	loz: "◊",
	spades: "♠",
	clubs: "♣",
	hearts: "♥",
	diams: "♦"
};
var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;
function getQualifiedJSXName(object) {
	if (!object) return object;
	if (object.type === "JSXIdentifier") return object.name;
	if (object.type === "JSXNamespacedName") return object.namespace.name + ":" + object.name.name;
	if (object.type === "JSXMemberExpression") return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
}
function generateJsxParser(acorn, acornTypeScript, Parser$4, jsxOptions) {
	const tt = acorn.tokTypes;
	const tok = acornTypeScript.tokTypes;
	const isNewLine$1 = acorn.isNewLine;
	const isIdentifierChar$1 = acorn.isIdentifierChar;
	const options = Object.assign({
		allowNamespaces: true,
		allowNamespacedObjects: true
	}, jsxOptions || {});
	return class JsxParser extends Parser$4 {
		jsx_readToken() {
			let out = "", chunkStart = this.pos;
			for (;;) {
				if (this.pos >= this.input.length) this.raise(this.start, "Unterminated JSX contents");
				let ch = this.input.charCodeAt(this.pos);
				switch (ch) {
					case 60:
					case 123:
						if (this.pos === this.start) {
							if (ch === 60 && this.exprAllowed) {
								++this.pos;
								return this.finishToken(tok.jsxTagStart);
							}
							return this.getTokenFromCode(ch);
						}
						out += this.input.slice(chunkStart, this.pos);
						return this.finishToken(tok.jsxText, out);
					case 38:
						out += this.input.slice(chunkStart, this.pos);
						out += this.jsx_readEntity();
						chunkStart = this.pos;
						break;
					case 62:
					case 125: this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + "` or `{\"" + this.input[this.pos] + "\"}`?");
					default: if (isNewLine$1(ch)) {
						out += this.input.slice(chunkStart, this.pos);
						out += this.jsx_readNewLine(true);
						chunkStart = this.pos;
					} else ++this.pos;
				}
			}
		}
		jsx_readNewLine(normalizeCRLF) {
			let ch = this.input.charCodeAt(this.pos);
			let out;
			++this.pos;
			if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
				++this.pos;
				out = normalizeCRLF ? "\n" : "\r\n";
			} else out = String.fromCharCode(ch);
			if (this.options.locations) {
				++this.curLine;
				this.lineStart = this.pos;
			}
			return out;
		}
		jsx_readString(quote$1) {
			let out = "", chunkStart = ++this.pos;
			for (;;) {
				if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
				let ch = this.input.charCodeAt(this.pos);
				if (ch === quote$1) break;
				if (ch === 38) {
					out += this.input.slice(chunkStart, this.pos);
					out += this.jsx_readEntity();
					chunkStart = this.pos;
				} else if (isNewLine$1(ch)) {
					out += this.input.slice(chunkStart, this.pos);
					out += this.jsx_readNewLine(false);
					chunkStart = this.pos;
				} else ++this.pos;
			}
			out += this.input.slice(chunkStart, this.pos++);
			return this.finishToken(tt.string, out);
		}
		jsx_readEntity() {
			let str = "", count = 0, entity;
			let ch = this.input[this.pos];
			if (ch !== "&") this.raise(this.pos, "Entity must start with an ampersand");
			let startPos = ++this.pos;
			while (this.pos < this.input.length && count++ < 10) {
				ch = this.input[this.pos++];
				if (ch === ";") {
					if (str[0] === "#") if (str[1] === "x") {
						str = str.substr(2);
						if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
					} else {
						str = str.substr(1);
						if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
					}
else entity = xhtml_default[str];
					break;
				}
				str += ch;
			}
			if (!entity) {
				this.pos = startPos;
				return "&";
			}
			return entity;
		}
		jsx_readWord() {
			let ch, start = this.pos;
			do 
				ch = this.input.charCodeAt(++this.pos);
			while (isIdentifierChar$1(ch) || ch === 45);
			return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
		}
		jsx_parseIdentifier() {
			let node = this.startNode();
			if (this.type === tok.jsxName) node.name = this.value;
else if (this.type.keyword) node.name = this.type.keyword;
else this.unexpected();
			this.next();
			return this.finishNode(node, "JSXIdentifier");
		}
		jsx_parseNamespacedName() {
			let startPos = this.start, startLoc = this.startLoc;
			let name = this.jsx_parseIdentifier();
			if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
			var node = this.startNodeAt(startPos, startLoc);
			node.namespace = name;
			node.name = this.jsx_parseIdentifier();
			return this.finishNode(node, "JSXNamespacedName");
		}
		jsx_parseElementName() {
			if (this.type === tok.jsxTagEnd) return "";
			let startPos = this.start, startLoc = this.startLoc;
			let node = this.jsx_parseNamespacedName();
			if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) this.unexpected();
			while (this.eat(tt.dot)) {
				let newNode = this.startNodeAt(startPos, startLoc);
				newNode.object = node;
				newNode.property = this.jsx_parseIdentifier();
				node = this.finishNode(newNode, "JSXMemberExpression");
			}
			return node;
		}
		jsx_parseAttributeValue() {
			switch (this.type) {
				case tt.braceL:
					let node = this.jsx_parseExpressionContainer();
					if (node.expression.type === "JSXEmptyExpression") this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
					return node;
				case tok.jsxTagStart:
				case tt.string: return this.parseExprAtom();
				default: this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
			}
		}
		jsx_parseEmptyExpression() {
			let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
			return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
		}
		jsx_parseExpressionContainer() {
			let node = this.startNode();
			this.next();
			node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
			this.expect(tt.braceR);
			return this.finishNode(node, "JSXExpressionContainer");
		}
		jsx_parseAttribute() {
			let node = this.startNode();
			if (this.eat(tt.braceL)) {
				this.expect(tt.ellipsis);
				node.argument = this.parseMaybeAssign();
				this.expect(tt.braceR);
				return this.finishNode(node, "JSXSpreadAttribute");
			}
			node.name = this.jsx_parseNamespacedName();
			node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
			return this.finishNode(node, "JSXAttribute");
		}
		jsx_parseOpeningElementAt(startPos, startLoc) {
			let node = this.startNodeAt(startPos, startLoc);
			node.attributes = [];
			let nodeName = this.jsx_parseElementName();
			if (nodeName) node.name = nodeName;
			while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());
			node.selfClosing = this.eat(tt.slash);
			this.expect(tok.jsxTagEnd);
			return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
		}
		jsx_parseClosingElementAt(startPos, startLoc) {
			let node = this.startNodeAt(startPos, startLoc);
			let nodeName = this.jsx_parseElementName();
			if (nodeName) node.name = nodeName;
			this.expect(tok.jsxTagEnd);
			return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
		}
		jsx_parseElementAt(startPos, startLoc) {
			let node = this.startNodeAt(startPos, startLoc);
			let children = [];
			let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
			let closingElement = null;
			if (!openingElement.selfClosing) {
				contents: for (;;) switch (this.type) {
					case tok.jsxTagStart:
						startPos = this.start;
						startLoc = this.startLoc;
						this.next();
						if (this.eat(tt.slash)) {
							closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
							break contents;
						}
						children.push(this.jsx_parseElementAt(startPos, startLoc));
						break;
					case tok.jsxText:
						children.push(this.parseExprAtom());
						break;
					case tt.braceL:
						children.push(this.jsx_parseExpressionContainer());
						break;
					default: this.unexpected();
				}
				if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
			}
			let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
			node["opening" + fragmentOrElement] = openingElement;
			node["closing" + fragmentOrElement] = closingElement;
			node.children = children;
			if (this.type === tt.relational && this.value === "<") this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
			return this.finishNode(node, "JSX" + fragmentOrElement);
		}
		jsx_parseText() {
			let node = this.parseLiteral(this.value);
			node.type = "JSXText";
			return node;
		}
		jsx_parseElement() {
			let startPos = this.start, startLoc = this.startLoc;
			this.next();
			return this.jsx_parseElementAt(startPos, startLoc);
		}
	};
}
function generateParseImportAssertions(Parse, acornTypeScript, acorn) {
	const { tokTypes: tokTypes2 } = acornTypeScript;
	const { tokTypes: tt } = acorn;
	return class ImportAttributes extends Parse {
		parseMaybeImportAttributes(node) {
			if (this.type === tt._with || this.type === tokTypes2.assert) {
				this.next();
				const attributes = this.parseImportAttributes();
				if (attributes) node.attributes = attributes;
			}
		}
		parseImportAttributes() {
			this.expect(tt.braceL);
			const attrs = this.parseWithEntries();
			this.expect(tt.braceR);
			return attrs;
		}
		parseWithEntries() {
			const attrs = [];
			const attrNames = /* @__PURE__ */ new Set();
			do {
				if (this.type === tt.braceR) break;
				const node = this.startNode();
				let withionKeyNode;
				if (this.type === tt.string) withionKeyNode = this.parseLiteral(this.value);
else withionKeyNode = this.parseIdent(true);
				this.next();
				node.key = withionKeyNode;
				if (attrNames.has(node.key.name)) this.raise(this.pos, "Duplicated key in attributes");
				attrNames.add(node.key.name);
				if (this.type !== tt.string) this.raise(this.pos, "Only string is supported as an attribute value");
				node.value = this.parseLiteral(this.value);
				attrs.push(this.finishNode(node, "ImportAttribute"));
			} while (this.eat(tt.comma));
			return attrs;
		}
	};
}
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function assert(x$1) {
	if (!x$1) throw new Error("Assert fail");
}
function tsIsClassAccessor(modifier) {
	return modifier === "accessor";
}
function tsIsVarianceAnnotations(modifier) {
	return modifier === "in" || modifier === "out";
}
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
var acornScope = {
	SCOPE_TOP: 1,
	SCOPE_FUNCTION: 2,
	SCOPE_ASYNC: 4,
	SCOPE_GENERATOR: 8,
	SCOPE_ARROW: 16,
	SCOPE_SIMPLE_CATCH: 32,
	SCOPE_SUPER: 64,
	SCOPE_DIRECT_SUPER: 128,
	SCOPE_CLASS_STATIC_BLOCK: 256,
	SCOPE_VAR: 256,
	BIND_NONE: 0,
	BIND_VAR: 1,
	BIND_LEXICAL: 2,
	BIND_FUNCTION: 3,
	BIND_SIMPLE_CATCH: 4,
	BIND_OUTSIDE: 5,
	BIND_TS_TYPE: 6,
	BIND_TS_INTERFACE: 7,
	BIND_TS_NAMESPACE: 8,
	BIND_FLAGS_TS_EXPORT_ONLY: 1024,
	BIND_FLAGS_TS_IMPORT: 4096,
	BIND_FLAGS_TS_ENUM: 256,
	BIND_FLAGS_TS_CONST_ENUM: 512,
	BIND_FLAGS_CLASS: 128
};
function functionFlags(async, generator) {
	return acornScope.SCOPE_FUNCTION | (async ? acornScope.SCOPE_ASYNC : 0) | (generator ? acornScope.SCOPE_GENERATOR : 0);
}
function isPossiblyLiteralEnum(expression) {
	if (expression.type !== "MemberExpression") return false;
	const { computed, property } = expression;
	if (computed && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) return false;
	return isUncomputedMemberExpressionChain(expression.object);
}
function isUncomputedMemberExpressionChain(expression) {
	if (expression.type === "Identifier") return true;
	if (expression.type !== "MemberExpression") return false;
	if (expression.computed) return false;
	return isUncomputedMemberExpressionChain(expression.object);
}
function tsIsAccessModifier(modifier) {
	return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tokenCanStartExpression(token) {
	return Boolean(token.startsExpr);
}
function nonNull(x$1) {
	if (x$1 == null) throw new Error(`Unexpected ${x$1} value.`);
	return x$1;
}
function keywordTypeFromName(value) {
	switch (value) {
		case "any": return "TSAnyKeyword";
		case "boolean": return "TSBooleanKeyword";
		case "bigint": return "TSBigIntKeyword";
		case "never": return "TSNeverKeyword";
		case "number": return "TSNumberKeyword";
		case "object": return "TSObjectKeyword";
		case "string": return "TSStringKeyword";
		case "symbol": return "TSSymbolKeyword";
		case "undefined": return "TSUndefinedKeyword";
		case "unknown": return "TSUnknownKeyword";
		default: return void 0;
	}
}
function tsPlugin(options) {
	const { dts = false } = options || {};
	const disallowAmbiguousJSXLike = !!options?.jsx;
	return function(Parser$4) {
		const _acorn = Parser$4.acorn || acorn_exports;
		const acornTypeScript = generateAcornTypeScript(_acorn);
		const tt = _acorn.tokTypes;
		const keywordTypes2 = _acorn.keywordTypes;
		const isIdentifierStart$1 = _acorn.isIdentifierStart;
		const lineBreak$1 = _acorn.lineBreak;
		const isNewLine$1 = _acorn.isNewLine;
		const tokContexts = _acorn.tokContexts;
		const isIdentifierChar$1 = _acorn.isIdentifierChar;
		const { tokTypes: tokTypes2, tokContexts: tsTokContexts, keywordsRegExp, tokenIsLiteralPropertyName, tokenIsTemplate, tokenIsTSDeclarationStart, tokenIsIdentifier, tokenIsKeywordOrIdentifier, tokenIsTSTypeOperator } = acornTypeScript;
		function nextLineBreak$1(code, from$1, end = code.length) {
			for (let i$1 = from$1; i$1 < end; i$1++) {
				let next = code.charCodeAt(i$1);
				if (isNewLine$1(next)) return i$1 < end - 1 && next === 13 && code.charCodeAt(i$1 + 1) === 10 ? i$1 + 2 : i$1 + 1;
			}
			return -1;
		}
		Parser$4 = generateParseDecorators(Parser$4, acornTypeScript, _acorn);
		if (options?.jsx) Parser$4 = generateJsxParser(_acorn, acornTypeScript, Parser$4, typeof options.jsx === "boolean" ? {} : options.jsx);
		Parser$4 = generateParseImportAssertions(Parser$4, acornTypeScript, _acorn);
		class TypeScriptParser extends Parser$4 {
			constructor(options2, input, startPos) {
				super(options2, input, startPos);
				this.preValue = null;
				this.preToken = null;
				this.isLookahead = false;
				this.isAmbientContext = false;
				this.inAbstractClass = false;
				this.inType = false;
				this.inDisallowConditionalTypesContext = false;
				this.maybeInArrowParameters = false;
				this.shouldParseArrowReturnType = void 0;
				this.shouldParseAsyncArrowReturnType = void 0;
				this.decoratorStack = [[]];
				this.importsStack = [[]];
				/**
				* we will only parse one import node or export node at same time.
				* default kind is undefined
				* */
				this.importOrExportOuterKind = void 0;
				this.tsParseConstModifier = (node) => {
					this.tsParseModifiers({
						modified: node,
						allowedModifiers: ["const"],
						disallowedModifiers: ["in", "out"],
						errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
					});
				};
				this.ecmaVersion = this.options.ecmaVersion;
			}
			static get acornTypeScript() {
				return acornTypeScript;
			}
			get acornTypeScript() {
				return acornTypeScript;
			}
			getTokenFromCodeInType(code) {
				if (code === 62) return this.finishOp(tt.relational, 1);
				if (code === 60) return this.finishOp(tt.relational, 1);
				return super.getTokenFromCode(code);
			}
			readToken(code) {
				if (!this.inType) {
					let context = this.curContext();
					if (context === tsTokContexts.tc_expr) return this.jsx_readToken();
					if (context === tsTokContexts.tc_oTag || context === tsTokContexts.tc_cTag) {
						if (isIdentifierStart$1(code)) return this.jsx_readWord();
						if (code == 62) {
							++this.pos;
							return this.finishToken(tokTypes2.jsxTagEnd);
						}
						if ((code === 34 || code === 39) && context == tsTokContexts.tc_oTag) return this.jsx_readString(code);
					}
					if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
						++this.pos;
						if (options?.jsx) return this.finishToken(tokTypes2.jsxTagStart);
else return this.finishToken(tt.relational, "<");
					}
				}
				return super.readToken(code);
			}
			getTokenFromCode(code) {
				if (this.inType) return this.getTokenFromCodeInType(code);
				if (code === 64) {
					++this.pos;
					return this.finishToken(tokTypes2.at);
				}
				return super.getTokenFromCode(code);
			}
			isAbstractClass() {
				return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._class;
			}
			finishNode(node, type) {
				if (node.type !== "" && node.end !== 0) return node;
				return super.finishNode(node, type);
			}
			tryParse(fn, oldState = this.cloneCurLookaheadState()) {
				const abortSignal = { node: null };
				try {
					const node = fn((node2 = null) => {
						abortSignal.node = node2;
						throw abortSignal;
					});
					return {
						node,
						error: null,
						thrown: false,
						aborted: false,
						failState: null
					};
				} catch (error) {
					const failState = this.getCurLookaheadState();
					this.setLookaheadState(oldState);
					if (error instanceof SyntaxError) return {
						node: null,
						error,
						thrown: true,
						aborted: false,
						failState
					};
					if (error === abortSignal) return {
						node: abortSignal.node,
						error: null,
						thrown: false,
						aborted: true,
						failState
					};
					throw error;
				}
			}
			setOptionalParametersError(refExpressionErrors, resultError) {
				refExpressionErrors.optionalParametersLoc = resultError?.loc ?? this.startLoc;
			}
			reScan_lt_gt() {
				if (this.type === tt.relational) {
					this.pos -= 1;
					this.readToken_lt_gt(this.fullCharCodeAtPos());
				}
			}
			reScan_lt() {
				const { type } = this;
				if (type === tt.bitShift) {
					this.pos -= 2;
					this.finishOp(tt.relational, 1);
					return tt.relational;
				}
				return type;
			}
			resetEndLocation(node, endPos = this.lastTokEnd, endLoc = this.lastTokEndLoc) {
				node.end = endPos;
				node.loc.end = endLoc;
				if (this.options.ranges) node.range[1] = endPos;
			}
			startNodeAtNode(type) {
				return super.startNodeAt(type.start, type.loc.start);
			}
			nextTokenStart() {
				return this.nextTokenStartSince(this.pos);
			}
			tsHasSomeModifiers(member, modifiers) {
				return modifiers.some((modifier) => {
					if (tsIsAccessModifier(modifier)) return member.accessibility === modifier;
					return !!member[modifier];
				});
			}
			tsIsStartOfStaticBlocks() {
				return this.isContextual("static") && this.lookaheadCharCode() === 123;
			}
			tsCheckForInvalidTypeCasts(items) {
				items.forEach((node) => {
					if (node?.type === "TSTypeCastExpression") this.raise(node.typeAnnotation.start, TypeScriptError.UnexpectedTypeAnnotation);
				});
			}
			atPossibleAsyncArrow(base) {
				return base.type === "Identifier" && base.name === "async" && this.lastTokEndLoc.column === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.potentialArrowAt;
			}
			tsIsIdentifier() {
				return tokenIsIdentifier(this.type);
			}
			tsTryParseTypeOrTypePredicateAnnotation() {
				return this.match(tt.colon) ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon) : void 0;
			}
			tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit) {
				if (!this.tsMatchLeftRelational()) return void 0;
				const oldMaybeInArrowParameters = this.maybeInArrowParameters;
				this.maybeInArrowParameters = true;
				const res = this.tsTryParseAndCatch(() => {
					const node = this.startNodeAt(startPos, startLoc);
					node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
					super.parseFunctionParams(node);
					node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
					this.expect(tt.arrow);
					return node;
				});
				this.maybeInArrowParameters = oldMaybeInArrowParameters;
				if (!res) return void 0;
				return super.parseArrowExpression(
					res,
					/* params are already set */
					null,
					/* async */
					true,
					/* forInit */
					forInit
);
			}
			tsParseTypeArgumentsInExpression() {
				if (this.reScan_lt() !== tt.relational) return void 0;
				return this.tsParseTypeArguments();
			}
			tsInNoContext(cb) {
				const oldContext = this.context;
				this.context = [oldContext[0]];
				try {
					return cb();
				} finally {
					this.context = oldContext;
				}
			}
			tsTryParseTypeAnnotation() {
				return this.match(tt.colon) ? this.tsParseTypeAnnotation() : void 0;
			}
			isUnparsedContextual(nameStart, name) {
				const nameEnd = nameStart + name.length;
				if (this.input.slice(nameStart, nameEnd) === name) {
					const nextCh = this.input.charCodeAt(nameEnd);
					return !(isIdentifierChar$1(nextCh) || (nextCh & 64512) === 55296);
				}
				return false;
			}
			isAbstractConstructorSignature() {
				return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._new;
			}
			nextTokenStartSince(pos) {
				skipWhiteSpace.lastIndex = pos;
				return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
			}
			lookaheadCharCode() {
				return this.input.charCodeAt(this.nextTokenStart());
			}
			compareLookaheadState(state, state2) {
				for (const key of Object.keys(state)) if (state[key] !== state2[key]) return false;
				return true;
			}
			createLookaheadState() {
				this.value = null;
				this.context = [this.curContext()];
			}
			getCurLookaheadState() {
				return {
					endLoc: this.endLoc,
					lastTokEnd: this.lastTokEnd,
					lastTokStart: this.lastTokStart,
					lastTokStartLoc: this.lastTokStartLoc,
					pos: this.pos,
					value: this.value,
					type: this.type,
					start: this.start,
					end: this.end,
					context: this.context,
					startLoc: this.startLoc,
					lastTokEndLoc: this.lastTokEndLoc,
					curLine: this.curLine,
					lineStart: this.lineStart,
					curPosition: this.curPosition,
					containsEsc: this.containsEsc
				};
			}
			cloneCurLookaheadState() {
				return {
					pos: this.pos,
					value: this.value,
					type: this.type,
					start: this.start,
					end: this.end,
					context: this.context && this.context.slice(),
					startLoc: this.startLoc,
					lastTokEndLoc: this.lastTokEndLoc,
					endLoc: this.endLoc,
					lastTokEnd: this.lastTokEnd,
					lastTokStart: this.lastTokStart,
					lastTokStartLoc: this.lastTokStartLoc,
					curLine: this.curLine,
					lineStart: this.lineStart,
					curPosition: this.curPosition,
					containsEsc: this.containsEsc
				};
			}
			setLookaheadState(state) {
				this.pos = state.pos;
				this.value = state.value;
				this.endLoc = state.endLoc;
				this.lastTokEnd = state.lastTokEnd;
				this.lastTokStart = state.lastTokStart;
				this.lastTokStartLoc = state.lastTokStartLoc;
				this.type = state.type;
				this.start = state.start;
				this.end = state.end;
				this.context = state.context;
				this.startLoc = state.startLoc;
				this.lastTokEndLoc = state.lastTokEndLoc;
				this.curLine = state.curLine;
				this.lineStart = state.lineStart;
				this.curPosition = state.curPosition;
				this.containsEsc = state.containsEsc;
			}
			tsLookAhead(f) {
				const state = this.getCurLookaheadState();
				const res = f();
				this.setLookaheadState(state);
				return res;
			}
			lookahead(number) {
				const oldState = this.getCurLookaheadState();
				this.createLookaheadState();
				this.isLookahead = true;
				if (number !== void 0) for (let i$1 = 0; i$1 < number; i$1++) this.nextToken();
else this.nextToken();
				this.isLookahead = false;
				const curState = this.getCurLookaheadState();
				this.setLookaheadState(oldState);
				return curState;
			}
			readWord() {
				let word = this.readWord1();
				let type = tt.name;
				if (this.keywords.test(word)) type = keywordTypes2[word];
else if (new RegExp(keywordsRegExp).test(word)) type = tokTypes2[word];
				return this.finishToken(type, word);
			}
			skipBlockComment() {
				let startLoc;
				if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
				let start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
				if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
				this.pos = end + 2;
				if (this.options.locations) for (let nextBreak, pos = start; (nextBreak = nextLineBreak$1(this.input, pos, this.pos)) > -1;) {
					++this.curLine;
					pos = this.lineStart = nextBreak;
				}
				if (this.isLookahead) return;
				if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
			}
			skipLineComment(startSkip) {
				let start = this.pos;
				let startLoc;
				if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
				let ch = this.input.charCodeAt(this.pos += startSkip);
				while (this.pos < this.input.length && !isNewLine$1(ch)) ch = this.input.charCodeAt(++this.pos);
				if (this.isLookahead) return;
				if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
			}
			finishToken(type, val) {
				this.preValue = this.value;
				this.preToken = this.type;
				this.end = this.pos;
				if (this.options.locations) this.endLoc = this.curPosition();
				let prevType = this.type;
				this.type = type;
				this.value = val;
				if (!this.isLookahead) this.updateContext(prevType);
			}
			resetStartLocation(node, start, startLoc) {
				node.start = start;
				node.loc.start = startLoc;
				if (this.options.ranges) node.range[0] = start;
			}
			isLineTerminator() {
				return this.eat(tt.semi) || super.canInsertSemicolon();
			}
			hasFollowingLineBreak() {
				skipWhiteSpaceToLineBreak.lastIndex = this.end;
				return skipWhiteSpaceToLineBreak.test(this.input);
			}
			addExtra(node, key, value, enumerable = true) {
				if (!node) return;
				const extra = node.extra = node.extra || {};
				if (enumerable) extra[key] = value;
else Object.defineProperty(extra, key, {
					enumerable,
					value
				});
			}
			/**
			* Test if current token is a literal property name
			* https://tc39.es/ecma262/#prod-LiteralPropertyName
			* LiteralPropertyName:
			*   IdentifierName
			*   StringLiteral
			*   NumericLiteral
			*   BigIntLiteral
			*/
			isLiteralPropertyName() {
				return tokenIsLiteralPropertyName(this.type);
			}
			hasPrecedingLineBreak() {
				return lineBreak$1.test(this.input.slice(this.lastTokEnd, this.start));
			}
			createIdentifier(node, name) {
				node.name = name;
				return this.finishNode(node, "Identifier");
			}
			/**
			* Reset the start location of node to the start location of locationNode
			*/
			resetStartLocationFromNode(node, locationNode) {
				this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
			}
			isThisParam(param) {
				return param.type === "Identifier" && param.name === "this";
			}
			isLookaheadContextual(name) {
				const next = this.nextTokenStart();
				return this.isUnparsedContextual(next, name);
			}
			/**
			* ts type isContextual
			* @param {TokenType} type
			* @param {TokenType} token
			* @returns {boolean}
			* */
			ts_type_isContextual(type, token) {
				return type === token && !this.containsEsc;
			}
			/**
			* ts isContextual
			* @param {TokenType} token
			* @returns {boolean}
			* */
			ts_isContextual(token) {
				return this.type === token && !this.containsEsc;
			}
			ts_isContextualWithState(state, token) {
				return state.type === token && !state.containsEsc;
			}
			isContextualWithState(keyword, state) {
				return state.type === tt.name && state.value === keyword && !state.containsEsc;
			}
			tsIsStartOfMappedType() {
				this.next();
				if (this.eat(tt.plusMin)) return this.ts_isContextual(tokTypes2.readonly);
				if (this.ts_isContextual(tokTypes2.readonly)) this.next();
				if (!this.match(tt.bracketL)) return false;
				this.next();
				if (!this.tsIsIdentifier()) return false;
				this.next();
				return this.match(tt._in);
			}
			tsInDisallowConditionalTypesContext(cb) {
				const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
				this.inDisallowConditionalTypesContext = true;
				try {
					return cb();
				} finally {
					this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
				}
			}
			tsTryParseType() {
				return this.tsEatThenParseType(tt.colon);
			}
			/**
			* Whether current token matches given type
			*
			* @param {TokenType} type
			* @returns {boolean}
			* @memberof Tokenizer
			*/
			match(type) {
				return this.type === type;
			}
			matchJsx(type) {
				return this.type === acornTypeScript.tokTypes[type];
			}
			ts_eatWithState(type, nextCount, state) {
				const targetType = state.type;
				if (type === targetType) {
					for (let i$1 = 0; i$1 < nextCount; i$1++) this.next();
					return true;
				} else return false;
			}
			ts_eatContextualWithState(name, nextCount, state) {
				if (keywordsRegExp.test(name)) {
					if (this.ts_isContextualWithState(state, tokTypes2[name])) {
						for (let i$1 = 0; i$1 < nextCount; i$1++) this.next();
						return true;
					}
					return false;
				} else {
					if (!this.isContextualWithState(name, state)) return false;
					for (let i$1 = 0; i$1 < nextCount; i$1++) this.next();
					return true;
				}
			}
			canHaveLeadingDecorator() {
				return this.match(tt._class);
			}
			eatContextual(name) {
				if (keywordsRegExp.test(name)) {
					if (this.ts_isContextual(tokTypes2[name])) {
						this.next();
						return true;
					}
					return false;
				} else return super.eatContextual(name);
			}
			tsIsExternalModuleReference() {
				return this.isContextual("require") && this.lookaheadCharCode() === 40;
			}
			tsParseExternalModuleReference() {
				const node = this.startNode();
				this.expectContextual("require");
				this.expect(tt.parenL);
				if (!this.match(tt.string)) this.unexpected();
				node.expression = this.parseExprAtom();
				this.expect(tt.parenR);
				return this.finishNode(node, "TSExternalModuleReference");
			}
			tsParseEntityName(allowReservedWords = true) {
				let entity = this.parseIdent(allowReservedWords);
				while (this.eat(tt.dot)) {
					const node = this.startNodeAtNode(entity);
					node.left = entity;
					node.right = this.parseIdent(allowReservedWords);
					entity = this.finishNode(node, "TSQualifiedName");
				}
				return entity;
			}
			tsParseEnumMember() {
				const node = this.startNode();
				node.id = this.match(tt.string) ? this.parseLiteral(this.value) : this.parseIdent(
					/* liberal */
					true
);
				if (this.eat(tt.eq)) node.initializer = this.parseMaybeAssign();
				return this.finishNode(node, "TSEnumMember");
			}
			tsParseEnumDeclaration(node, properties = {}) {
				if (properties.const) node.const = true;
				if (properties.declare) node.declare = true;
				this.expectContextual("enum");
				node.id = this.parseIdent();
				this.checkLValSimple(node.id);
				this.expect(tt.braceL);
				node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
				this.expect(tt.braceR);
				return this.finishNode(node, "TSEnumDeclaration");
			}
			tsParseModuleBlock() {
				const node = this.startNode();
				this.enterScope(TS_SCOPE_OTHER);
				this.expect(tt.braceL);
				node.body = [];
				while (this.type !== tt.braceR) {
					let stmt = this.parseStatement(null, true);
					node.body.push(stmt);
				}
				this.next();
				super.exitScope();
				return this.finishNode(node, "TSModuleBlock");
			}
			tsParseAmbientExternalModuleDeclaration(node) {
				if (this.ts_isContextual(tokTypes2.global)) {
					node.global = true;
					node.id = this.parseIdent();
				} else if (this.match(tt.string)) node.id = this.parseLiteral(this.value);
else this.unexpected();
				if (this.match(tt.braceL)) {
					this.enterScope(TS_SCOPE_TS_MODULE);
					node.body = this.tsParseModuleBlock();
					super.exitScope();
				} else super.semicolon();
				return this.finishNode(node, "TSModuleDeclaration");
			}
			tsTryParseDeclare(nany) {
				if (this.isLineTerminator()) return;
				let starttype = this.type;
				let kind;
				if (this.isContextual("let")) {
					starttype = tt._var;
					kind = "let";
				}
				return this.tsInAmbientContext(() => {
					if (starttype === tt._function) {
						nany.declare = true;
						return this.parseFunctionStatement(
							nany,
							/* async */
							false,
							/* declarationPosition */
							true
);
					}
					if (starttype === tt._class) {
						nany.declare = true;
						return this.parseClass(nany, true);
					}
					if (starttype === tokTypes2.enum) return this.tsParseEnumDeclaration(nany, { declare: true });
					if (starttype === tokTypes2.global) return this.tsParseAmbientExternalModuleDeclaration(nany);
					if (starttype === tt._const || starttype === tt._var) {
						if (!this.match(tt._const) || !this.isLookaheadContextual("enum")) {
							nany.declare = true;
							return this.parseVarStatement(nany, kind || this.value, true);
						}
						this.expect(tt._const);
						return this.tsParseEnumDeclaration(nany, {
							const: true,
							declare: true
						});
					}
					if (starttype === tokTypes2.interface) {
						const result = this.tsParseInterfaceDeclaration(nany, { declare: true });
						if (result) return result;
					}
					if (tokenIsIdentifier(starttype)) return this.tsParseDeclaration(
						nany,
						this.value,
						/* next */
						true
);
				});
			}
			tsIsListTerminator(kind) {
				switch (kind) {
					case "EnumMembers":
					case "TypeMembers": return this.match(tt.braceR);
					case "HeritageClauseElement": return this.match(tt.braceL);
					case "TupleElementTypes": return this.match(tt.bracketR);
					case "TypeParametersOrArguments": return this.tsMatchRightRelational();
				}
			}
			/**
			* If !expectSuccess, returns undefined instead of failing to parse.
			* If expectSuccess, parseElement should always return a defined value.
			*/
			tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
				const result = [];
				let trailingCommaPos = -1;
				for (;;) {
					if (this.tsIsListTerminator(kind)) break;
					trailingCommaPos = -1;
					const element = parseElement();
					if (element == null) return void 0;
					result.push(element);
					if (this.eat(tt.comma)) {
						trailingCommaPos = this.lastTokStart;
						continue;
					}
					if (this.tsIsListTerminator(kind)) break;
					if (expectSuccess) this.expect(tt.comma);
					return void 0;
				}
				if (refTrailingCommaPos) refTrailingCommaPos.value = trailingCommaPos;
				return result;
			}
			tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
				return nonNull(this.tsParseDelimitedListWorker(
					kind,
					parseElement,
					/* expectSuccess */
					true,
					refTrailingCommaPos
));
			}
			tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
				if (!skipFirstToken) if (bracket) this.expect(tt.bracketL);
else this.expect(tt.relational);
				const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
				if (bracket) this.expect(tt.bracketR);
else this.expect(tt.relational);
				return result;
			}
			tsParseTypeParameterName() {
				const typeName = this.parseIdent();
				return typeName.name;
			}
			tsEatThenParseType(token) {
				return !this.match(token) ? void 0 : this.tsNextThenParseType();
			}
			tsExpectThenParseType(token) {
				return this.tsDoThenParseType(() => this.expect(token));
			}
			tsNextThenParseType() {
				return this.tsDoThenParseType(() => this.next());
			}
			tsDoThenParseType(cb) {
				return this.tsInType(() => {
					cb();
					return this.tsParseType();
				});
			}
			tsSkipParameterStart() {
				if (tokenIsIdentifier(this.type) || this.match(tt._this)) {
					this.next();
					return true;
				}
				if (this.match(tt.braceL)) try {
					this.parseObj(true);
					return true;
				} catch {
					return false;
				}
				if (this.match(tt.bracketL)) {
					this.next();
					try {
						this.parseBindingList(tt.bracketR, true, true);
						return true;
					} catch {
						return false;
					}
				}
				return false;
			}
			tsIsUnambiguouslyStartOfFunctionType() {
				this.next();
				if (this.match(tt.parenR) || this.match(tt.ellipsis)) return true;
				if (this.tsSkipParameterStart()) {
					if (this.match(tt.colon) || this.match(tt.comma) || this.match(tt.question) || this.match(tt.eq)) return true;
					if (this.match(tt.parenR)) {
						this.next();
						if (this.match(tt.arrow)) return true;
					}
				}
				return false;
			}
			tsIsStartOfFunctionType() {
				if (this.tsMatchLeftRelational()) return true;
				return this.match(tt.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
			}
			tsInAllowConditionalTypesContext(cb) {
				const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
				this.inDisallowConditionalTypesContext = false;
				try {
					return cb();
				} finally {
					this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
				}
			}
			tsParseBindingListForSignature() {
				return super.parseBindingList(tt.parenR, true, true).map((pattern) => {
					if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") this.raise(pattern.start, TypeScriptError.UnsupportedSignatureParameterKind(pattern.type));
					return pattern;
				});
			}
			tsParseTypePredicateAsserts() {
				if (this.type !== tokTypes2.asserts) return false;
				const containsEsc = this.containsEsc;
				this.next();
				if (!tokenIsIdentifier(this.type) && !this.match(tt._this)) return false;
				if (containsEsc) this.raise(this.lastTokStart, "Escape sequence in keyword asserts");
				return true;
			}
			tsParseThisTypeNode() {
				const node = this.startNode();
				this.next();
				return this.finishNode(node, "TSThisType");
			}
			tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
				this.tsInType(() => {
					if (eatColon) this.expect(tt.colon);
					t.typeAnnotation = this.tsParseType();
				});
				return this.finishNode(t, "TSTypeAnnotation");
			}
			tsParseThisTypePredicate(lhs) {
				this.next();
				const node = this.startNodeAtNode(lhs);
				node.parameterName = lhs;
				node.typeAnnotation = this.tsParseTypeAnnotation(
					/* eatColon */
					false
);
				node.asserts = false;
				return this.finishNode(node, "TSTypePredicate");
			}
			tsParseThisTypeOrThisTypePredicate() {
				const thisKeyword = this.tsParseThisTypeNode();
				if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.tsParseThisTypePredicate(thisKeyword);
else return thisKeyword;
			}
			tsParseTypePredicatePrefix() {
				const id = this.parseIdent();
				if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
					this.next();
					return id;
				}
			}
			tsParseTypeOrTypePredicateAnnotation(returnToken) {
				return this.tsInType(() => {
					const t = this.startNode();
					this.expect(returnToken);
					const node = this.startNode();
					const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
					if (asserts && this.match(tt._this)) {
						let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
						if (thisTypePredicate.type === "TSThisType") {
							node.parameterName = thisTypePredicate;
							node.asserts = true;
							node.typeAnnotation = null;
							thisTypePredicate = this.finishNode(node, "TSTypePredicate");
						} else {
							this.resetStartLocationFromNode(thisTypePredicate, node);
							thisTypePredicate.asserts = true;
						}
						t.typeAnnotation = thisTypePredicate;
						return this.finishNode(t, "TSTypeAnnotation");
					}
					const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
					if (!typePredicateVariable) {
						if (!asserts) return this.tsParseTypeAnnotation(
							/* eatColon */
							false,
							t
);
						node.parameterName = this.parseIdent();
						node.asserts = asserts;
						node.typeAnnotation = null;
						t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
						return this.finishNode(t, "TSTypeAnnotation");
					}
					const type = this.tsParseTypeAnnotation(
						/* eatColon */
						false
);
					node.parameterName = typePredicateVariable;
					node.typeAnnotation = type;
					node.asserts = asserts;
					t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
					return this.finishNode(t, "TSTypeAnnotation");
				});
			}
			tsFillSignature(returnToken, signature) {
				const returnTokenRequired = returnToken === tt.arrow;
				const paramsKey = "parameters";
				const returnTypeKey = "typeAnnotation";
				signature.typeParameters = this.tsTryParseTypeParameters();
				this.expect(tt.parenL);
				signature[paramsKey] = this.tsParseBindingListForSignature();
				if (returnTokenRequired) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
else if (this.match(returnToken)) signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
			}
			tsTryNextParseConstantContext() {
				if (this.lookahead().type !== tt._const) return null;
				this.next();
				const typeReference = this.tsParseTypeReference();
				if (typeReference.typeParameters || typeReference.typeArguments) this.raise(typeReference.typeName.start, TypeScriptError.CannotFindName({ name: "const" }));
				return typeReference;
			}
			tsParseFunctionOrConstructorType(type, abstract) {
				const node = this.startNode();
				if (type === "TSConstructorType") {
					node.abstract = !!abstract;
					if (abstract) this.next();
					this.next();
				}
				this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(tt.arrow, node));
				return this.finishNode(node, type);
			}
			tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
				const node = this.startNode();
				const hasLeadingOperator = this.eat(operator);
				const types$2 = [];
				do 
					types$2.push(parseConstituentType());
				while (this.eat(operator));
				if (types$2.length === 1 && !hasLeadingOperator) return types$2[0];
				node.types = types$2;
				return this.finishNode(node, kind);
			}
			tsCheckTypeAnnotationForReadOnly(node) {
				switch (node.typeAnnotation.type) {
					case "TSTupleType":
					case "TSArrayType": return;
					default: this.raise(node.start, TypeScriptError.UnexpectedReadonly);
				}
			}
			tsParseTypeOperator() {
				const node = this.startNode();
				const operator = this.value;
				this.next();
				node.operator = operator;
				node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
				if (operator === "readonly") this.tsCheckTypeAnnotationForReadOnly(node);
				return this.finishNode(node, "TSTypeOperator");
			}
			tsParseConstraintForInferType() {
				if (this.eat(tt._extends)) {
					const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
					if (this.inDisallowConditionalTypesContext || !this.match(tt.question)) return constraint;
				}
			}
			tsParseInferType() {
				const node = this.startNode();
				this.expectContextual("infer");
				const typeParameter = this.startNode();
				typeParameter.name = this.tsParseTypeParameterName();
				typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
				node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
				return this.finishNode(node, "TSInferType");
			}
			tsParseLiteralTypeNode() {
				const node = this.startNode();
				node.literal = (() => {
					switch (this.type) {
						case tt.num:
						case tt.string:
						case tt._true:
						case tt._false: return this.parseExprAtom();
						default: this.unexpected();
					}
				})();
				return this.finishNode(node, "TSLiteralType");
			}
			tsParseImportType() {
				const node = this.startNode();
				this.expect(tt._import);
				this.expect(tt.parenL);
				if (!this.match(tt.string)) this.raise(this.start, TypeScriptError.UnsupportedImportTypeArgument);
				node.argument = this.parseExprAtom();
				this.expect(tt.parenR);
				if (this.eat(tt.dot)) node.qualifier = this.tsParseEntityName();
				if (this.tsMatchLeftRelational()) node.typeArguments = this.tsParseTypeArguments();
				return this.finishNode(node, "TSImportType");
			}
			tsParseTypeQuery() {
				const node = this.startNode();
				this.expect(tt._typeof);
				if (this.match(tt._import)) node.exprName = this.tsParseImportType();
else node.exprName = this.tsParseEntityName();
				if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) node.typeArguments = this.tsParseTypeArguments();
				return this.finishNode(node, "TSTypeQuery");
			}
			tsParseMappedTypeParameter() {
				const node = this.startNode();
				node.name = this.tsParseTypeParameterName();
				node.constraint = this.tsExpectThenParseType(tt._in);
				return this.finishNode(node, "TSTypeParameter");
			}
			tsParseMappedType() {
				const node = this.startNode();
				this.expect(tt.braceL);
				if (this.match(tt.plusMin)) {
					node.readonly = this.value;
					this.next();
					this.expectContextual("readonly");
				} else if (this.eatContextual("readonly")) node.readonly = true;
				this.expect(tt.bracketL);
				node.typeParameter = this.tsParseMappedTypeParameter();
				node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
				this.expect(tt.bracketR);
				if (this.match(tt.plusMin)) {
					node.optional = this.value;
					this.next();
					this.expect(tt.question);
				} else if (this.eat(tt.question)) node.optional = true;
				node.typeAnnotation = this.tsTryParseType();
				this.semicolon();
				this.expect(tt.braceR);
				return this.finishNode(node, "TSMappedType");
			}
			tsParseTypeLiteral() {
				const node = this.startNode();
				node.members = this.tsParseObjectTypeMembers();
				return this.finishNode(node, "TSTypeLiteral");
			}
			tsParseTupleElementType() {
				const startLoc = this.startLoc;
				const startPos = this["start"];
				const rest = this.eat(tt.ellipsis);
				let type = this.tsParseType();
				const optional = this.eat(tt.question);
				const labeled = this.eat(tt.colon);
				if (labeled) {
					const labeledNode = this.startNodeAtNode(type);
					labeledNode.optional = optional;
					if (type.type === "TSTypeReference" && !type.typeArguments && type.typeName.type === "Identifier") labeledNode.label = type.typeName;
else {
						this.raise(type.start, TypeScriptError.InvalidTupleMemberLabel);
						labeledNode.label = type;
					}
					labeledNode.elementType = this.tsParseType();
					type = this.finishNode(labeledNode, "TSNamedTupleMember");
				} else if (optional) {
					const optionalTypeNode = this.startNodeAtNode(type);
					optionalTypeNode.typeAnnotation = type;
					type = this.finishNode(optionalTypeNode, "TSOptionalType");
				}
				if (rest) {
					const restNode = this.startNodeAt(startPos, startLoc);
					restNode.typeAnnotation = type;
					type = this.finishNode(restNode, "TSRestType");
				}
				return type;
			}
			tsParseTupleType() {
				const node = this.startNode();
				node.elementTypes = this.tsParseBracketedList(
					"TupleElementTypes",
					this.tsParseTupleElementType.bind(this),
					/* bracket */
					true,
					/* skipFirstToken */
					false
);
				let seenOptionalElement = false;
				let labeledElements = null;
				node.elementTypes.forEach((elementNode) => {
					const { type } = elementNode;
					if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) this.raise(elementNode.start, TypeScriptError.OptionalTypeBeforeRequired);
					seenOptionalElement ||= type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
					let checkType = type;
					if (type === "TSRestType") {
						elementNode = elementNode.typeAnnotation;
						checkType = elementNode.type;
					}
					const isLabeled = checkType === "TSNamedTupleMember";
					labeledElements ??= isLabeled;
					if (labeledElements !== isLabeled) this.raise(elementNode.start, TypeScriptError.MixedLabeledAndUnlabeledElements);
				});
				return this.finishNode(node, "TSTupleType");
			}
			tsParseTemplateLiteralType() {
				const node = this.startNode();
				node.literal = this.parseTemplate({ isTagged: false });
				return this.finishNode(node, "TSLiteralType");
			}
			tsParseTypeReference() {
				const node = this.startNode();
				node.typeName = this.tsParseEntityName();
				if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) node.typeArguments = this.tsParseTypeArguments();
				return this.finishNode(node, "TSTypeReference");
			}
			tsMatchLeftRelational() {
				return this.match(tt.relational) && this.value === "<";
			}
			tsMatchRightRelational() {
				return this.match(tt.relational) && this.value === ">";
			}
			tsParseParenthesizedType() {
				const node = this.startNode();
				this.expect(tt.parenL);
				node.typeAnnotation = this.tsParseType();
				this.expect(tt.parenR);
				return this.finishNode(node, "TSParenthesizedType");
			}
			tsParseNonArrayType() {
				switch (this.type) {
					case tt.string:
					case tt.num:
					case tt._true:
					case tt._false: return this.tsParseLiteralTypeNode();
					case tt.plusMin:
						if (this.value === "-") {
							const node = this.startNode();
							const nextToken = this.lookahead();
							if (nextToken.type !== tt.num) this.unexpected();
							node.literal = this.parseMaybeUnary();
							return this.finishNode(node, "TSLiteralType");
						}
						break;
					case tt._this: return this.tsParseThisTypeOrThisTypePredicate();
					case tt._typeof: return this.tsParseTypeQuery();
					case tt._import: return this.tsParseImportType();
					case tt.braceL: return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
					case tt.bracketL: return this.tsParseTupleType();
					case tt.parenL: return this.tsParseParenthesizedType();
					case tt.backQuote:
					case tt.dollarBraceL: return this.tsParseTemplateLiteralType();
					default: {
						const { type } = this;
						if (tokenIsIdentifier(type) || type === tt._void || type === tt._null) {
							const nodeType = type === tt._void ? "TSVoidKeyword" : type === tt._null ? "TSNullKeyword" : keywordTypeFromName(this.value);
							if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
								const node = this.startNode();
								this.next();
								return this.finishNode(node, nodeType);
							}
							return this.tsParseTypeReference();
						}
					}
				}
				this.unexpected();
			}
			tsParseArrayTypeOrHigher() {
				let type = this.tsParseNonArrayType();
				while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) if (this.match(tt.bracketR)) {
					const node = this.startNodeAtNode(type);
					node.elementType = type;
					this.expect(tt.bracketR);
					type = this.finishNode(node, "TSArrayType");
				} else {
					const node = this.startNodeAtNode(type);
					node.objectType = type;
					node.indexType = this.tsParseType();
					this.expect(tt.bracketR);
					type = this.finishNode(node, "TSIndexedAccessType");
				}
				return type;
			}
			tsParseTypeOperatorOrHigher() {
				const isTypeOperator = tokenIsTSTypeOperator(this.type) && !this.containsEsc;
				return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
			}
			tsParseIntersectionTypeOrHigher() {
				return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), tt.bitwiseAND);
			}
			tsParseUnionTypeOrHigher() {
				return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), tt.bitwiseOR);
			}
			tsParseNonConditionalType() {
				if (this.tsIsStartOfFunctionType()) return this.tsParseFunctionOrConstructorType("TSFunctionType");
				if (this.match(tt._new)) return this.tsParseFunctionOrConstructorType("TSConstructorType");
else if (this.isAbstractConstructorSignature()) return this.tsParseFunctionOrConstructorType(
					"TSConstructorType",
					/* abstract */
					true
);
				return this.tsParseUnionTypeOrHigher();
			}
			/** Be sure to be in a type context before calling this, using `tsInType`. */
			tsParseType() {
				assert(this.inType);
				const type = this.tsParseNonConditionalType();
				if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(tt._extends)) return type;
				const node = this.startNodeAtNode(type);
				node.checkType = type;
				node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
				this.expect(tt.question);
				node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
				this.expect(tt.colon);
				node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
				return this.finishNode(node, "TSConditionalType");
			}
			tsIsUnambiguouslyIndexSignature() {
				this.next();
				if (tokenIsIdentifier(this.type)) {
					this.next();
					return this.match(tt.colon);
				}
				return false;
			}
			/**
			* Runs `cb` in a type context.
			* This should be called one token *before* the first type token,
			* so that the call to `next()` is run in type context.
			*/
			tsInType(cb) {
				const oldInType = this.inType;
				this.inType = true;
				try {
					return cb();
				} finally {
					this.inType = oldInType;
				}
			}
			tsTryParseIndexSignature(node) {
				if (!(this.match(tt.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return void 0;
				this.expect(tt.bracketL);
				const id = this.parseIdent();
				id.typeAnnotation = this.tsParseTypeAnnotation();
				this.resetEndLocation(id);
				this.expect(tt.bracketR);
				node.parameters = [id];
				const type = this.tsTryParseTypeAnnotation();
				if (type) node.typeAnnotation = type;
				this.tsParseTypeMemberSemicolon();
				return this.finishNode(node, "TSIndexSignature");
			}
			tsParseNoneModifiers(node) {
				this.tsParseModifiers({
					modified: node,
					allowedModifiers: [],
					disallowedModifiers: ["in", "out"],
					errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
				});
			}
			tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
				const node = this.startNode();
				parseModifiers(node);
				node.name = this.tsParseTypeParameterName();
				node.constraint = this.tsEatThenParseType(tt._extends);
				node.default = this.tsEatThenParseType(tt.eq);
				return this.finishNode(node, "TSTypeParameter");
			}
			tsParseTypeParameters(parseModifiers) {
				const node = this.startNode();
				if (this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart")) this.next();
else this.unexpected();
				const refTrailingCommaPos = { value: -1 };
				node.params = this.tsParseBracketedList(
					"TypeParametersOrArguments",
					this.tsParseTypeParameter.bind(this, parseModifiers),
					/* bracket */
					false,
					/* skipFirstToken */
					true,
					refTrailingCommaPos
);
				if (node.params.length === 0) this.raise(this.start, TypeScriptError.EmptyTypeParameters);
				if (refTrailingCommaPos.value !== -1) this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
				return this.finishNode(node, "TSTypeParameterDeclaration");
			}
			tsTryParseTypeParameters(parseModifiers) {
				if (this.tsMatchLeftRelational()) return this.tsParseTypeParameters(parseModifiers);
			}
			tsTryParse(f) {
				const state = this.getCurLookaheadState();
				const result = f();
				if (result !== void 0 && result !== false) return result;
else {
					this.setLookaheadState(state);
					return void 0;
				}
			}
			tsTokenCanFollowModifier() {
				return (this.match(tt.bracketL) || this.match(tt.braceL) || this.match(tt.star) || this.match(tt.ellipsis) || this.match(tt.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
			}
			tsNextTokenCanFollowModifier() {
				this.next(true);
				return this.tsTokenCanFollowModifier();
			}
			/** Parses a modifier matching one the given modifier names. */
			tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
				const modifier = this.value;
				if (allowedModifiers.indexOf(modifier) !== -1 && !this.containsEsc) {
					if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) return void 0;
					if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return modifier;
				}
				return void 0;
			}
			tsParseModifiersByMap({ modified, map }) {
				for (const key of Object.keys(map)) modified[key] = map[key];
			}
			/** Parses a list of modifiers, in any order.
			*  If you need a specific order, you must call this function multiple times:
			*    this.tsParseModifiers({ modified: node, allowedModifiers: ['public'] });
			*    this.tsParseModifiers({ modified: node, allowedModifiers: ["abstract", "readonly"] });
			*/
			tsParseModifiers({ modified, allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock, errorTemplate = TypeScriptError.InvalidModifierOnTypeMember }) {
				const modifiedMap = {};
				const enforceOrder = (loc, modifier, before, after) => {
					if (modifier === before && modified[after]) this.raise(loc.column, TypeScriptError.InvalidModifiersOrder({ orderedModifiers: [before, after] }));
				};
				const incompatible = (loc, modifier, mod1, mod2) => {
					if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) this.raise(loc.column, TypeScriptError.IncompatibleModifiers({ modifiers: [mod1, mod2] }));
				};
				for (;;) {
					const startLoc = this.startLoc;
					const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers ?? []), stopOnStartOfClassStaticBlock);
					if (!modifier) break;
					if (tsIsAccessModifier(modifier)) if (modified.accessibility) this.raise(this.start, TypeScriptError.DuplicateAccessibilityModifier());
else {
						enforceOrder(startLoc, modifier, modifier, "override");
						enforceOrder(startLoc, modifier, modifier, "static");
						enforceOrder(startLoc, modifier, modifier, "readonly");
						enforceOrder(startLoc, modifier, modifier, "accessor");
						modifiedMap.accessibility = modifier;
						modified["accessibility"] = modifier;
					}
else if (tsIsVarianceAnnotations(modifier)) if (modified[modifier]) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
else {
						enforceOrder(startLoc, modifier, "in", "out");
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
else if (tsIsClassAccessor(modifier)) if (modified[modifier]) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
else {
						incompatible(startLoc, modifier, "accessor", "readonly");
						incompatible(startLoc, modifier, "accessor", "static");
						incompatible(startLoc, modifier, "accessor", "override");
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
else if (modifier === "const") if (modified[modifier]) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
else {
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
else if (Object.hasOwnProperty.call(modified, modifier)) this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
else {
						enforceOrder(startLoc, modifier, "static", "readonly");
						enforceOrder(startLoc, modifier, "static", "override");
						enforceOrder(startLoc, modifier, "override", "readonly");
						enforceOrder(startLoc, modifier, "abstract", "override");
						incompatible(startLoc, modifier, "declare", "override");
						incompatible(startLoc, modifier, "static", "abstract");
						modifiedMap[modifier] = modifier;
						modified[modifier] = true;
					}
					if (disallowedModifiers?.includes(modifier)) this.raise(this.start, errorTemplate);
				}
				return modifiedMap;
			}
			tsParseInOutModifiers(node) {
				this.tsParseModifiers({
					modified: node,
					allowedModifiers: ["in", "out"],
					disallowedModifiers: [
						"public",
						"private",
						"protected",
						"readonly",
						"declare",
						"abstract",
						"override"
					],
					errorTemplate: TypeScriptError.InvalidModifierOnTypeParameter
				});
			}
			parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit) {
				if (!options?.jsx && this.tsMatchLeftRelational()) return this.tsParseTypeAssertion();
else return super.parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit);
			}
			tsParseTypeAssertion() {
				if (disallowAmbiguousJSXLike) this.raise(this.start, TypeScriptError.ReservedTypeAssertion);
				const result = this.tryParse(() => {
					const node = this.startNode();
					const _const = this.tsTryNextParseConstantContext();
					node.typeAnnotation = _const || this.tsNextThenParseType();
					this.expect(tt.relational);
					node.expression = this.parseMaybeUnary();
					return this.finishNode(node, "TSTypeAssertion");
				});
				if (result.error) return this.tsParseTypeParameters(this.tsParseConstModifier);
else return result.node;
			}
			tsParseTypeArguments() {
				const node = this.startNode();
				node.params = this.tsInType(() => this.tsInNoContext(() => {
					this.expect(tt.relational);
					return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
				}));
				if (node.params.length === 0) this.raise(this.start, TypeScriptError.EmptyTypeArguments);
				this.exprAllowed = false;
				this.expect(tt.relational);
				return this.finishNode(node, "TSTypeParameterInstantiation");
			}
			tsParseHeritageClause(token) {
				const originalStart = this.start;
				const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
					const node = this.startNode();
					node.expression = this.tsParseEntityName();
					if (this.tsMatchLeftRelational()) node.typeParameters = this.tsParseTypeArguments();
					return this.finishNode(node, "TSExpressionWithTypeArguments");
				});
				if (!delimitedList.length) this.raise(originalStart, TypeScriptError.EmptyHeritageClauseType({ token }));
				return delimitedList;
			}
			tsParseTypeMemberSemicolon() {
				if (!this.eat(tt.comma) && !this.isLineTerminator()) this.expect(tt.semi);
			}
			tsTryParseAndCatch(f) {
				const result = this.tryParse((abort) => f() || abort());
				if (result.aborted || !result.node) return void 0;
				if (result.error) this.setLookaheadState(result.failState);
				return result.node;
			}
			tsParseSignatureMember(kind, node) {
				this.tsFillSignature(tt.colon, node);
				this.tsParseTypeMemberSemicolon();
				return this.finishNode(node, kind);
			}
			tsParsePropertyOrMethodSignature(node, readonly) {
				if (this.eat(tt.question)) node.optional = true;
				const nodeAny = node;
				if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
					if (readonly) this.raise(node.start, TypeScriptError.ReadonlyForMethodSignature);
					const method = nodeAny;
					if (method.kind && this.tsMatchLeftRelational()) this.raise(this.start, TypeScriptError.AccesorCannotHaveTypeParameters);
					this.tsFillSignature(tt.colon, method);
					this.tsParseTypeMemberSemicolon();
					const paramsKey = "parameters";
					const returnTypeKey = "typeAnnotation";
					if (method.kind === "get") {
						if (method[paramsKey].length > 0) {
							this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
							if (this.isThisParam(method[paramsKey][0])) this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
						}
					} else if (method.kind === "set") {
						if (method[paramsKey].length !== 1) this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
else {
							const firstParameter = method[paramsKey][0];
							if (this.isThisParam(firstParameter)) this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
							if (firstParameter.type === "Identifier" && firstParameter.optional) this.raise(this.start, TypeScriptError.SetAccesorCannotHaveOptionalParameter);
							if (firstParameter.type === "RestElement") this.raise(this.start, TypeScriptError.SetAccesorCannotHaveRestParameter);
						}
						if (method[returnTypeKey]) this.raise(method[returnTypeKey].start, TypeScriptError.SetAccesorCannotHaveReturnType);
					} else method.kind = "method";
					return this.finishNode(method, "TSMethodSignature");
				} else {
					const property = nodeAny;
					if (readonly) property.readonly = true;
					const type = this.tsTryParseTypeAnnotation();
					if (type) property.typeAnnotation = type;
					this.tsParseTypeMemberSemicolon();
					return this.finishNode(property, "TSPropertySignature");
				}
			}
			tsParseTypeMember() {
				const node = this.startNode();
				if (this.match(tt.parenL) || this.tsMatchLeftRelational()) return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
				if (this.match(tt._new)) {
					const id = this.startNode();
					this.next();
					if (this.match(tt.parenL) || this.tsMatchLeftRelational()) return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
else {
						node.key = this.createIdentifier(id, "new");
						return this.tsParsePropertyOrMethodSignature(node, false);
					}
				}
				this.tsParseModifiers({
					modified: node,
					allowedModifiers: ["readonly"],
					disallowedModifiers: [
						"declare",
						"abstract",
						"private",
						"protected",
						"public",
						"static",
						"override"
					]
				});
				const idx = this.tsTryParseIndexSignature(node);
				if (idx) return idx;
				this.parsePropertyName(node);
				if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
					node.kind = node.key.name;
					this.parsePropertyName(node);
				}
				return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
			}
			tsParseList(kind, parseElement) {
				const result = [];
				while (!this.tsIsListTerminator(kind)) result.push(parseElement());
				return result;
			}
			tsParseObjectTypeMembers() {
				this.expect(tt.braceL);
				const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
				this.expect(tt.braceR);
				return members;
			}
			tsParseInterfaceDeclaration(node, properties = {}) {
				if (this.hasFollowingLineBreak()) return null;
				this.expectContextual("interface");
				if (properties.declare) node.declare = true;
				if (tokenIsIdentifier(this.type)) {
					node.id = this.parseIdent();
					this.checkLValSimple(node.id, acornScope.BIND_TS_INTERFACE);
				} else {
					node.id = null;
					this.raise(this.start, TypeScriptError.MissingInterfaceName);
				}
				node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
				if (this.eat(tt._extends)) node.extends = this.tsParseHeritageClause("extends");
				const body = this.startNode();
				body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
				node.body = this.finishNode(body, "TSInterfaceBody");
				return this.finishNode(node, "TSInterfaceDeclaration");
			}
			tsParseAbstractDeclaration(node) {
				if (this.match(tt._class)) {
					node.abstract = true;
					return this.parseClass(node, true);
				} else if (this.ts_isContextual(tokTypes2.interface)) {
					if (!this.hasFollowingLineBreak()) {
						node.abstract = true;
						return this.tsParseInterfaceDeclaration(node);
					}
				} else this.unexpected(node.start);
			}
			tsIsDeclarationStart() {
				return tokenIsTSDeclarationStart(this.type);
			}
			tsParseExpressionStatement(node, expr) {
				switch (expr.name) {
					case "declare": {
						const declaration = this.tsTryParseDeclare(node);
						if (declaration) {
							declaration.declare = true;
							return declaration;
						}
						break;
					}
					case "global":
						if (this.match(tt.braceL)) {
							this.enterScope(TS_SCOPE_TS_MODULE);
							const mod = node;
							mod.global = true;
							mod.id = expr;
							mod.body = this.tsParseModuleBlock();
							super.exitScope();
							return this.finishNode(mod, "TSModuleDeclaration");
						}
						break;
					default: return this.tsParseDeclaration(
						node,
						expr.name,
						/* next */
						false
);
				}
			}
			tsParseModuleReference() {
				return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(
					/* allowReservedWords */
					false
);
			}
			tsIsExportDefaultSpecifier() {
				const { type } = this;
				const isAsync = this.isAsyncFunction();
				const isLet = this.isLet();
				if (tokenIsIdentifier(type)) {
					if (isAsync && !this.containsEsc || isLet) return false;
					if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
						const ahead = this.lookahead();
						if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) return false;
					}
				} else if (!this.match(tt._default)) return false;
				const next = this.nextTokenStart();
				const hasFrom = this.isUnparsedContextual(next, "from");
				if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) return true;
				if (this.match(tt._default) && hasFrom) {
					const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
					return nextAfterFrom === 34 || nextAfterFrom === 39;
				}
				return false;
			}
			tsInAmbientContext(cb) {
				const oldIsAmbientContext = this.isAmbientContext;
				this.isAmbientContext = true;
				try {
					return cb();
				} finally {
					this.isAmbientContext = oldIsAmbientContext;
				}
			}
			tsCheckLineTerminator(next) {
				if (next) {
					if (this.hasFollowingLineBreak()) return false;
					this.next();
					return true;
				}
				return !this.isLineTerminator();
			}
			tsParseModuleOrNamespaceDeclaration(node, nested = false) {
				node.id = this.parseIdent();
				if (!nested) this.checkLValSimple(node.id, acornScope.BIND_TS_NAMESPACE);
				if (this.eat(tt.dot)) {
					const inner = this.startNode();
					this.tsParseModuleOrNamespaceDeclaration(inner, true);
					node.body = inner;
				} else {
					this.enterScope(TS_SCOPE_TS_MODULE);
					node.body = this.tsParseModuleBlock();
					super.exitScope();
				}
				return this.finishNode(node, "TSModuleDeclaration");
			}
			checkLValSimple(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
				if (expr.type === "TSNonNullExpression" || expr.type === "TSAsExpression") expr = expr.expression;
				return super.checkLValSimple(expr, bindingType, checkClashes);
			}
			tsParseTypeAliasDeclaration(node) {
				node.id = this.parseIdent();
				this.checkLValSimple(node.id, acornScope.BIND_TS_TYPE);
				node.typeAnnotation = this.tsInType(() => {
					node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
					this.expect(tt.eq);
					if (this.ts_isContextual(tokTypes2.interface) && this.lookahead().type !== tt.dot) {
						const node2 = this.startNode();
						this.next();
						return this.finishNode(node2, "TSIntrinsicKeyword");
					}
					return this.tsParseType();
				});
				this.semicolon();
				return this.finishNode(node, "TSTypeAliasDeclaration");
			}
			tsParseDeclaration(node, value, next) {
				switch (value) {
					case "abstract":
						if (this.tsCheckLineTerminator(next) && (this.match(tt._class) || tokenIsIdentifier(this.type))) return this.tsParseAbstractDeclaration(node);
						break;
					case "module":
						if (this.tsCheckLineTerminator(next)) {
							if (this.match(tt.string)) return this.tsParseAmbientExternalModuleDeclaration(node);
else if (tokenIsIdentifier(this.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
						}
						break;
					case "namespace":
						if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
						break;
					case "type":
						if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) return this.tsParseTypeAliasDeclaration(node);
						break;
				}
			}
			tsTryParseExportDeclaration() {
				return this.tsParseDeclaration(
					this.startNode(),
					this.value,
					/* next */
					true
);
			}
			tsParseImportEqualsDeclaration(node, isExport) {
				node.isExport = isExport || false;
				node.id = this.parseIdent();
				this.checkLValSimple(node.id, acornScope.BIND_LEXICAL);
				super.expect(tt.eq);
				const moduleReference = this.tsParseModuleReference();
				if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") this.raise(moduleReference.start, TypeScriptError.ImportAliasHasImportType);
				node.moduleReference = moduleReference;
				super.semicolon();
				return this.finishNode(node, "TSImportEqualsDeclaration");
			}
			isExportDefaultSpecifier() {
				if (this.tsIsDeclarationStart()) return false;
				const { type } = this;
				if (tokenIsIdentifier(type)) {
					if (this.isContextual("async") || this.isContextual("let")) return false;
					if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
						const ahead = this.lookahead();
						if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) return false;
					}
				} else if (!this.match(tt._default)) return false;
				const next = this.nextTokenStart();
				const hasFrom = this.isUnparsedContextual(next, "from");
				if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) return true;
				if (this.match(tt._default) && hasFrom) {
					const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
					return nextAfterFrom === 34 || nextAfterFrom === 39;
				}
				return false;
			}
			parseTemplate({ isTagged = false } = {}) {
				let node = this.startNode();
				this.next();
				node.expressions = [];
				let curElt = this.parseTemplateElement({ isTagged });
				node.quasis = [curElt];
				while (!curElt.tail) {
					if (this.type === tt.eof) this.raise(this.pos, "Unterminated template literal");
					this.expect(tt.dollarBraceL);
					node.expressions.push(this.inType ? this.tsParseType() : this.parseExpression());
					this.expect(tt.braceR);
					node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
				}
				this.next();
				return this.finishNode(node, "TemplateLiteral");
			}
			parseFunction(node, statement, allowExpressionBody, isAsync, forInit) {
				this.initFunction(node);
				if (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !isAsync) {
					if (this.type === tt.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
					node.generator = this.eat(tt.star);
				}
				if (this.ecmaVersion >= 8) node.async = !!isAsync;
				if (statement & FUNC_STATEMENT) node.id = statement & FUNC_NULLABLE_ID && this.type !== tt.name ? null : this.parseIdent();
				let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
				const oldMaybeInArrowParameters = this.maybeInArrowParameters;
				this.maybeInArrowParameters = false;
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.enterScope(functionFlags(node.async, node.generator));
				if (!(statement & FUNC_STATEMENT)) node.id = this.type === tt.name ? this.parseIdent() : null;
				this.parseFunctionParams(node);
				const isDeclaration = statement & FUNC_STATEMENT;
				this.parseFunctionBody(node, allowExpressionBody, false, forInit, { isFunctionDeclaration: isDeclaration });
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				if (statement & FUNC_STATEMENT && node.id && !(statement & FUNC_HANGING_STATEMENT)) if (node.body) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? acornScope.BIND_VAR : acornScope.BIND_LEXICAL : acornScope.BIND_FUNCTION);
else this.checkLValSimple(node.id, acornScope.BIND_NONE);
				this.maybeInArrowParameters = oldMaybeInArrowParameters;
				return this.finishNode(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
			}
			parseFunctionBody(node, isArrowFunction = false, isMethod = false, forInit = false, tsConfig) {
				if (this.match(tt.colon)) node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
				const bodilessType = tsConfig?.isFunctionDeclaration ? "TSDeclareFunction" : tsConfig?.isClassMethod ? "TSDeclareMethod" : void 0;
				if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) return this.finishNode(node, bodilessType);
				if (bodilessType === "TSDeclareFunction" && this.isAmbientContext) {
					this.raise(node.start, TypeScriptError.DeclareFunctionHasImplementation);
					if (node.declare) {
						super.parseFunctionBody(node, isArrowFunction, isMethod, false);
						return this.finishNode(node, bodilessType);
					}
				}
				super.parseFunctionBody(node, isArrowFunction, isMethod, forInit);
				return node;
			}
			parseNew() {
				if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
				let node = this.startNode();
				let meta = this.parseIdent(true);
				if (this.ecmaVersion >= 6 && this.eat(tt.dot)) {
					node.meta = meta;
					let containsEsc = this.containsEsc;
					node.property = this.parseIdent(true);
					if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
					if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
					if (!this["allowNewDotTarget"]) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
					return this.finishNode(node, "MetaProperty");
				}
				let startPos = this.start, startLoc = this.startLoc, isImport = this.type === tt._import;
				node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
				if (isImport && node.callee.type === "ImportExpression") this.raise(startPos, "Cannot use new with import()");
				const { callee } = node;
				if (callee.type === "TSInstantiationExpression" && !callee.extra?.parenthesized) {
					node.typeArguments = callee.typeArguments;
					node.callee = callee.expression;
				}
				if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false);
else node.arguments = [];
				return this.finishNode(node, "NewExpression");
			}
			parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit) {
				if (tt._in.binop > minPrec && !this.hasPrecedingLineBreak()) {
					let nodeType;
					if (this.isContextual("as")) nodeType = "TSAsExpression";
					if (this.isContextual("satisfies")) nodeType = "TSSatisfiesExpression";
					if (nodeType) {
						const node = this.startNodeAt(leftStartPos, leftStartLoc);
						node.expression = left;
						const _const = this.tsTryNextParseConstantContext();
						if (_const) node.typeAnnotation = _const;
else node.typeAnnotation = this.tsNextThenParseType();
						this.finishNode(node, nodeType);
						this.reScan_lt_gt();
						return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
					}
				}
				return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit);
			}
			parseImportSpecifiers() {
				let nodes = [], first = true;
				if (acornTypeScript.tokenIsIdentifier(this.type)) {
					nodes.push(this.parseImportDefaultSpecifier());
					if (!this.eat(tt.comma)) return nodes;
				}
				if (this.type === tt.star) {
					nodes.push(this.parseImportNamespaceSpecifier());
					return nodes;
				}
				this.expect(tt.braceL);
				while (!this.eat(tt.braceR)) {
					if (!first) {
						this.expect(tt.comma);
						if (this.afterTrailingComma(tt.braceR)) break;
					} else first = false;
					nodes.push(this.parseImportSpecifier());
				}
				return nodes;
			}
			/**
			* @param {Node} node this may be ImportDeclaration |
			* TsImportEqualsDeclaration
			* @returns AnyImport
			* */
			parseImport(node) {
				let enterHead = this.lookahead();
				node.importKind = "value";
				this.importOrExportOuterKind = "value";
				if (tokenIsIdentifier(enterHead.type) || this.match(tt.star) || this.match(tt.braceL)) {
					let ahead = this.lookahead(2);
					if (ahead.type !== tt.comma && !this.isContextualWithState("from", ahead) && ahead.type !== tt.eq && this.ts_eatContextualWithState("type", 1, enterHead)) {
						this.importOrExportOuterKind = "type";
						node.importKind = "type";
						enterHead = this.lookahead();
						ahead = this.lookahead(2);
					}
					if (tokenIsIdentifier(enterHead.type) && ahead.type === tt.eq) {
						this.next();
						const importNode = this.tsParseImportEqualsDeclaration(node);
						this.importOrExportOuterKind = "value";
						return importNode;
					}
				}
				this.next();
				if (this.type === tt.string) {
					node.specifiers = [];
					node.source = this.parseExprAtom();
				} else {
					node.specifiers = this.parseImportSpecifiers();
					this.expectContextual("from");
					node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
				}
				this.parseMaybeImportAttributes(node);
				this.semicolon();
				this.finishNode(node, "ImportDeclaration");
				this.importOrExportOuterKind = "value";
				if (node.importKind === "type" && node.specifiers.length > 1 && node.specifiers[0].type === "ImportDefaultSpecifier") this.raise(node.start, TypeScriptError.TypeImportCannotSpecifyDefaultAndNamed);
				return node;
			}
			parseExportDefaultDeclaration() {
				if (this.isAbstractClass()) {
					const cls = this.startNode();
					this.next();
					cls.abstract = true;
					return this.parseClass(cls, true);
				}
				if (this.match(tokTypes2.interface)) {
					const result = this.tsParseInterfaceDeclaration(this.startNode());
					if (result) return result;
				}
				return super.parseExportDefaultDeclaration();
			}
			parseExportAllDeclaration(node, exports$1) {
				if (this.ecmaVersion >= 11) if (this.eatContextual("as")) {
					node.exported = this.parseModuleExportName();
					this.checkExport(exports$1, node.exported, this.lastTokStart);
				} else node.exported = null;
				this.expectContextual("from");
				if (this.type !== tt.string) this.unexpected();
				node.source = this.parseExprAtom();
				this.parseMaybeImportAttributes(node);
				this.semicolon();
				return this.finishNode(node, "ExportAllDeclaration");
			}
			parseDynamicImport(node) {
				this.next();
				node.source = this.parseMaybeAssign();
				if (this.eat(tt.comma)) {
					const expr = this.parseExpression();
					node.arguments = [expr];
				}
				if (!this.eat(tt.parenR)) {
					const errorPos = this.start;
					if (this.eat(tt.comma) && this.eat(tt.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
else this.unexpected(errorPos);
				}
				return this.finishNode(node, "ImportExpression");
			}
			parseExport(node, exports$1) {
				let enterHead = this.lookahead();
				if (this.ts_eatWithState(tt._import, 2, enterHead)) {
					if (this.ts_isContextual(tokTypes2.type) && this.lookaheadCharCode() !== 61) {
						node.importKind = "type";
						this.importOrExportOuterKind = "type";
						this.next();
					} else {
						node.importKind = "value";
						this.importOrExportOuterKind = "value";
					}
					const exportEqualsNode = this.tsParseImportEqualsDeclaration(
						node,
						/* isExport */
						true
);
					this.importOrExportOuterKind = void 0;
					return exportEqualsNode;
				} else if (this.ts_eatWithState(tt.eq, 2, enterHead)) {
					const assign = node;
					assign.expression = this.parseExpression();
					this.semicolon();
					this.importOrExportOuterKind = void 0;
					return this.finishNode(assign, "TSExportAssignment");
				} else if (this.ts_eatContextualWithState("as", 2, enterHead)) {
					const decl$1 = node;
					this.expectContextual("namespace");
					decl$1.id = this.parseIdent();
					this.semicolon();
					this.importOrExportOuterKind = void 0;
					return this.finishNode(decl$1, "TSNamespaceExportDeclaration");
				} else {
					if (this.ts_isContextualWithState(enterHead, tokTypes2.type) && this.lookahead(2).type === tt.braceL) {
						this.next();
						this.importOrExportOuterKind = "type";
						node.exportKind = "type";
					} else {
						this.importOrExportOuterKind = "value";
						node.exportKind = "value";
					}
					this.next();
					if (this.eat(tt.star)) return this.parseExportAllDeclaration(node, exports$1);
					if (this.eat(tt._default)) {
						this.checkExport(exports$1, "default", this.lastTokStart);
						node.declaration = this.parseExportDefaultDeclaration();
						return this.finishNode(node, "ExportDefaultDeclaration");
					}
					if (this.shouldParseExportStatement()) {
						node.declaration = this.parseExportDeclaration(node);
						if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports$1, node.declaration.declarations);
else this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
						node.specifiers = [];
						node.source = null;
					} else {
						node.declaration = null;
						node.specifiers = this.parseExportSpecifiers(exports$1);
						if (this.eatContextual("from")) {
							if (this.type !== tt.string) this.unexpected();
							node.source = this.parseExprAtom();
							this.parseMaybeImportAttributes(node);
						} else {
							for (let spec of node.specifiers) {
								this.checkUnreserved(spec.local);
								this.checkLocalExport(spec.local);
								if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
							}
							node.source = null;
						}
						this.semicolon();
					}
					return this.finishNode(node, "ExportNamedDeclaration");
				}
			}
			checkExport(exports$1, name, _) {
				if (!exports$1) return;
				if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
				exports$1[name] = true;
			}
			parseMaybeDefault(startPos, startLoc, left) {
				const node = super.parseMaybeDefault(startPos, startLoc, left);
				if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) this.raise(node.typeAnnotation.start, TypeScriptError.TypeAnnotationAfterAssign);
				return node;
			}
			typeCastToParameter(node) {
				node.expression.typeAnnotation = node.typeAnnotation;
				this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc?.end);
				return node.expression;
			}
			toAssignableList(exprList, isBinding) {
				for (let i$1 = 0; i$1 < exprList.length; i$1++) {
					const expr = exprList[i$1];
					if (expr?.type === "TSTypeCastExpression") exprList[i$1] = this.typeCastToParameter(expr);
				}
				return super.toAssignableList(exprList, isBinding);
			}
			reportReservedArrowTypeParam(node) {
				if (node.params.length === 1 && !node.extra?.trailingComma && disallowAmbiguousJSXLike) this.raise(node.start, TypeScriptError.ReservedArrowTypeParam);
			}
			parseExprAtom(refDestructuringErrors, forInit, forNew) {
				if (this.type === tokTypes2.jsxText) return this.jsx_parseText();
else if (this.type === tokTypes2.jsxTagStart) return this.jsx_parseElement();
else if (this.type === tokTypes2.at) {
					this.parseDecorators();
					return this.parseExprAtom();
				} else if (tokenIsIdentifier(this.type)) {
					let canBeArrow = this.potentialArrowAt === this.start;
					let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
					let id = this.parseIdent(false);
					if (this.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(tt._function)) {
						this.overrideContext(tokContexts.f_expr);
						return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
					}
					if (canBeArrow && !this.canInsertSemicolon()) {
						if (this.eat(tt.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
						if (this.ecmaVersion >= 8 && id.name === "async" && this.type === tt.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
							id = this.parseIdent(false);
							if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
							return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
						}
					}
					return id;
				} else return super.parseExprAtom(refDestructuringErrors, forInit, forNew);
			}
			parseExprAtomDefault() {
				if (tokenIsIdentifier(this.type)) {
					const canBeArrow = this["potentialArrowAt"] === this.start;
					const containsEsc = this.containsEsc;
					const id = this.parseIdent();
					if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
						const { type } = this;
						if (type === tt._function) {
							this.next();
							return this.parseFunction(this.startNodeAtNode(id), void 0, true, true);
						} else if (tokenIsIdentifier(type)) if (this.lookaheadCharCode() === 61) {
							const paramId = this.parseIdent(false);
							if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
							return this.parseArrowExpression(this.startNodeAtNode(id), [paramId], true);
						} else return id;
					}
					if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {
						this.next();
						return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
					}
					return id;
				} else this.unexpected();
			}
			parseIdentNode() {
				let node = this.startNode();
				if (tokenIsKeywordOrIdentifier(this.type) && !((this.type.keyword === "class" || this.type.keyword === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))) node.name = this.value;
else return super.parseIdentNode();
				return node;
			}
			parseVarStatement(node, kind, allowMissingInitializer = false) {
				const { isAmbientContext } = this;
				this.next();
				super.parseVar(node, false, kind, allowMissingInitializer || isAmbientContext);
				this.semicolon();
				const declaration = this.finishNode(node, "VariableDeclaration");
				if (!isAmbientContext) return declaration;
				for (const { id, init } of declaration.declarations) {
					if (!init) continue;
					if (kind !== "const" || !!id.typeAnnotation) this.raise(init.start, TypeScriptError.InitializerNotAllowedInAmbientContext);
else if (init.type !== "StringLiteral" && init.type !== "BooleanLiteral" && init.type !== "NumericLiteral" && init.type !== "BigIntLiteral" && (init.type !== "TemplateLiteral" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) this.raise(init.start, TypeScriptError.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference);
				}
				return declaration;
			}
			parseStatement(context, topLevel, exports$1) {
				if (this.match(tokTypes2.at)) this.parseDecorators(true);
				if (this.match(tt._const) && this.isLookaheadContextual("enum")) {
					const node = this.startNode();
					this.expect(tt._const);
					return this.tsParseEnumDeclaration(node, { const: true });
				}
				if (this.ts_isContextual(tokTypes2.enum)) return this.tsParseEnumDeclaration(this.startNode());
				if (this.ts_isContextual(tokTypes2.interface)) {
					const result = this.tsParseInterfaceDeclaration(this.startNode());
					if (result) return result;
				}
				return super.parseStatement(context, topLevel, exports$1);
			}
			parseAccessModifier() {
				return this.tsParseModifier([
					"public",
					"protected",
					"private"
				]);
			}
			parsePostMemberNameModifiers(methodOrProp) {
				const optional = this.eat(tt.question);
				if (optional) methodOrProp.optional = true;
				if (methodOrProp.readonly && this.match(tt.parenL)) this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasReadonly);
				if (methodOrProp.declare && this.match(tt.parenL)) this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasDeclare);
			}
			parseExpressionStatement(node, expr) {
				const decl$1 = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
				return decl$1 || super.parseExpressionStatement(node, expr);
			}
			shouldParseExportStatement() {
				if (this.tsIsDeclarationStart()) return true;
				if (this.match(tokTypes2.at)) return true;
				return super.shouldParseExportStatement();
			}
			parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors) {
				if (this.eat(tt.question)) {
					let node = this.startNodeAt(startPos, startLoc);
					node.test = expr;
					node.consequent = this.parseMaybeAssign();
					this.expect(tt.colon);
					node.alternate = this.parseMaybeAssign(forInit);
					return this.finishNode(node, "ConditionalExpression");
				}
				return expr;
			}
			parseMaybeConditional(forInit, refDestructuringErrors) {
				let startPos = this.start, startLoc = this.startLoc;
				let expr = this.parseExprOps(forInit, refDestructuringErrors);
				if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
				if (!this.maybeInArrowParameters || !this.match(tt.question)) return this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors);
				const result = this.tryParse(() => this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors));
				if (!result.node) {
					if (result.error) this.setOptionalParametersError(refDestructuringErrors, result.error);
					return expr;
				}
				if (result.error) this.setLookaheadState(result.failState);
				return result.node;
			}
			parseParenItem(node) {
				const startPos = this.start;
				const startLoc = this.startLoc;
				node = super.parseParenItem(node);
				if (this.eat(tt.question)) {
					node.optional = true;
					this.resetEndLocation(node);
				}
				if (this.match(tt.colon)) {
					const typeCastNode = this.startNodeAt(startPos, startLoc);
					typeCastNode.expression = node;
					typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
					return this.finishNode(typeCastNode, "TSTypeCastExpression");
				}
				return node;
			}
			parseExportDeclaration(node) {
				if (!this.isAmbientContext && this.ts_isContextual(tokTypes2.declare)) return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
				const startPos = this.start;
				const startLoc = this.startLoc;
				const isDeclare = this.eatContextual("declare");
				if (isDeclare && (this.ts_isContextual(tokTypes2.declare) || !this.shouldParseExportStatement())) this.raise(this.start, TypeScriptError.ExpectedAmbientAfterExportDeclare);
				const isIdentifier = tokenIsIdentifier(this.type);
				const declaration = isIdentifier && this.tsTryParseExportDeclaration() || this.parseStatement(null);
				if (!declaration) return null;
				if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) node.exportKind = "type";
				if (isDeclare) {
					this.resetStartLocation(declaration, startPos, startLoc);
					declaration.declare = true;
				}
				return declaration;
			}
			parseClassId(node, isStatement) {
				if (!isStatement && this.isContextual("implements")) return;
				super.parseClassId(node, isStatement);
				const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
				if (typeParameters) node.typeParameters = typeParameters;
			}
			parseClassPropertyAnnotation(node) {
				if (!node.optional) {
					if (this.value === "!" && this.eat(tt.prefix)) node.definite = true;
else if (this.eat(tt.question)) node.optional = true;
				}
				const type = this.tsTryParseTypeAnnotation();
				if (type) node.typeAnnotation = type;
			}
			parseClassField(field) {
				const isPrivate = field.key.type === "PrivateIdentifier";
				if (isPrivate) {
					if (field.abstract) this.raise(field.start, TypeScriptError.PrivateElementHasAbstract);
					if (field.accessibility) this.raise(field.start, TypeScriptError.PrivateElementHasAccessibility({ modifier: field.accessibility }));
					this.parseClassPropertyAnnotation(field);
				} else {
					this.parseClassPropertyAnnotation(field);
					if (this.isAmbientContext && !(field.readonly && !field.typeAnnotation) && this.match(tt.eq)) this.raise(this.start, TypeScriptError.DeclareClassFieldHasInitializer);
					if (field.abstract && this.match(tt.eq)) {
						const { key } = field;
						this.raise(this.start, TypeScriptError.AbstractPropertyHasInitializer({ propertyName: key.type === "Identifier" && !field.computed ? key.name : `[${this.input.slice(key.start, key.end)}]` }));
					}
				}
				return super.parseClassField(field);
			}
			parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper) {
				const isConstructor = method.kind === "constructor";
				const isPrivate = method.key.type === "PrivateIdentifier";
				const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				if (isPrivate) {
					if (typeParameters) method.typeParameters = typeParameters;
					if (method.accessibility) this.raise(method.start, TypeScriptError.PrivateMethodsHasAccessibility({ modifier: method.accessibility }));
				} else if (typeParameters && isConstructor) this.raise(typeParameters.start, TypeScriptError.ConstructorHasTypeParameters);
				const { declare = false, kind } = method;
				if (declare && (kind === "get" || kind === "set")) this.raise(method.start, TypeScriptError.DeclareAccessor({ kind }));
				if (typeParameters) method.typeParameters = typeParameters;
				const key = method.key;
				if (method.kind === "constructor") {
					if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
					if (isAsync) this.raise(key.start, "Constructor can't be an async method");
				} else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
				const value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper, true, method);
				if (method.kind === "get" && value["params"].length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
				if (method.kind === "set" && value["params"].length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
				if (method.kind === "set" && value["params"][0].type === "RestElement") this.raiseRecoverable(value["params"][0].start, "Setter cannot use rest params");
				return this.finishNode(method, "MethodDefinition");
			}
			isClassMethod() {
				return this.match(tt.relational);
			}
			parseClassElement(constructorAllowsSuper) {
				if (this.eat(tt.semi)) return null;
				let node = this.startNode();
				let keyName = "";
				let isGenerator = false;
				let isAsync = false;
				let kind = "method";
				let isStatic = false;
				const modifiers = [
					"declare",
					"private",
					"public",
					"protected",
					"accessor",
					"override",
					"abstract",
					"readonly",
					"static"
				];
				const modifierMap = this.tsParseModifiers({
					modified: node,
					allowedModifiers: modifiers,
					disallowedModifiers: ["in", "out"],
					stopOnStartOfClassStaticBlock: true,
					errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
				});
				isStatic = Boolean(modifierMap.static);
				const callParseClassMemberWithIsStatic = () => {
					if (this.tsIsStartOfStaticBlocks()) {
						this.next();
						this.next();
						if (this.tsHasSomeModifiers(node, modifiers)) this.raise(this.start, TypeScriptError.StaticBlockCannotHaveModifier);
						if (this.ecmaVersion >= 13) {
							super.parseClassStaticBlock(node);
							return node;
						}
					} else {
						const idx = this.tsTryParseIndexSignature(node);
						if (idx) {
							if (node.abstract) this.raise(node.start, TypeScriptError.IndexSignatureHasAbstract);
							if (node.accessibility) this.raise(node.start, TypeScriptError.IndexSignatureHasAccessibility({ modifier: node.accessibility }));
							if (node.declare) this.raise(node.start, TypeScriptError.IndexSignatureHasDeclare);
							if (node.override) this.raise(node.start, TypeScriptError.IndexSignatureHasOverride);
							return idx;
						}
						if (!this.inAbstractClass && node.abstract) this.raise(node.start, TypeScriptError.NonAbstractClassHasAbstractMethod);
						if (node.override) {
							if (!constructorAllowsSuper) this.raise(node.start, TypeScriptError.OverrideNotInSubClass);
						}
						node.static = isStatic;
						if (isStatic) {
							if (!(this.isClassElementNameStart() || this.type === tt.star)) keyName = "static";
						}
						if (!keyName && this.ecmaVersion >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === tt.star) && !this.canInsertSemicolon()) isAsync = true;
else keyName = "async";
						if (!keyName && (this.ecmaVersion >= 9 || !isAsync) && this.eat(tt.star)) isGenerator = true;
						if (!keyName && !isAsync && !isGenerator) {
							const lastValue = this.value;
							if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
else keyName = lastValue;
						}
						if (keyName) {
							node.computed = false;
							node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
							node.key.name = keyName;
							this.finishNode(node.key, "Identifier");
						} else this.parseClassElementName(node);
						this.parsePostMemberNameModifiers(node);
						if (this.isClassMethod() || this.ecmaVersion < 13 || this.type === tt.parenL || kind !== "method" || isGenerator || isAsync) {
							const isConstructor = !node.static && checkKeyName(node, "constructor");
							const allowsDirectSuper = isConstructor && constructorAllowsSuper;
							if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
							node.kind = isConstructor ? "constructor" : kind;
							this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
						} else this.parseClassField(node);
						return node;
					}
				};
				if (node.declare) this.tsInAmbientContext(callParseClassMemberWithIsStatic);
else callParseClassMemberWithIsStatic();
				return node;
			}
			isClassElementNameStart() {
				if (this.tsIsIdentifier()) return true;
				return super.isClassElementNameStart();
			}
			parseClassSuper(node) {
				super.parseClassSuper(node);
				if (node.superClass && (this.tsMatchLeftRelational() || this.match(tt.bitShift))) node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
				if (this.eatContextual("implements")) node.implements = this.tsParseHeritageClause("implements");
			}
			parseFunctionParams(node) {
				const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				if (typeParameters) node.typeParameters = typeParameters;
				super.parseFunctionParams(node);
			}
			parseVarId(decl$1, kind) {
				super.parseVarId(decl$1, kind);
				if (decl$1.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.value === "!" && this.eat(tt.prefix)) decl$1.definite = true;
				const type = this.tsTryParseTypeAnnotation();
				if (type) {
					decl$1.id.typeAnnotation = type;
					this.resetEndLocation(decl$1.id);
				}
			}
			parseArrowExpression(node, params, isAsync, forInit) {
				if (this.match(tt.colon)) node.returnType = this.tsParseTypeAnnotation();
				let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
				this.enterScope(functionFlags(isAsync, false) | acornScope.SCOPE_ARROW);
				this.initFunction(node);
				const oldMaybeInArrowParameters = this.maybeInArrowParameters;
				if (this.ecmaVersion >= 8) node.async = !!isAsync;
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.maybeInArrowParameters = true;
				node.params = this.toAssignableList(params, true);
				this.maybeInArrowParameters = false;
				this.parseFunctionBody(node, true, false, forInit);
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				this.maybeInArrowParameters = oldMaybeInArrowParameters;
				return this.finishNode(node, "ArrowFunctionExpression");
			}
			parseMaybeAssignOrigin(forInit, refDestructuringErrors, afterLeftParse) {
				if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
else this.exprAllowed = false;
				let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
				if (refDestructuringErrors) {
					oldParenAssign = refDestructuringErrors.parenthesizedAssign;
					oldTrailingComma = refDestructuringErrors.trailingComma;
					oldDoubleProto = refDestructuringErrors.doubleProto;
					refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
				} else {
					refDestructuringErrors = new DestructuringErrors();
					ownDestructuringErrors = true;
				}
				let startPos = this.start, startLoc = this.startLoc;
				if (this.type === tt.parenL || tokenIsIdentifier(this.type)) {
					this.potentialArrowAt = this.start;
					this.potentialArrowInForAwait = forInit === "await";
				}
				let left = this.parseMaybeConditional(forInit, refDestructuringErrors);
				if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
				if (this.type.isAssign) {
					let node = this.startNodeAt(startPos, startLoc);
					node.operator = this.value;
					if (this.type === tt.eq) left = this.toAssignable(left, true, refDestructuringErrors);
					if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
					if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
					if (!this.maybeInArrowParameters) if (this.type === tt.eq) this.checkLValPattern(left);
else this.checkLValSimple(left);
					node.left = left;
					this.next();
					node.right = this.parseMaybeAssign(forInit);
					if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
					return this.finishNode(node, "AssignmentExpression");
				} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
				if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
				if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
				return left;
			}
			parseMaybeAssign(forInit, refExpressionErrors, afterLeftParse) {
				let state;
				let jsx;
				let typeCast;
				if (options?.jsx && (this.matchJsx("jsxTagStart") || this.tsMatchLeftRelational())) {
					state = this.cloneCurLookaheadState();
					jsx = this.tryParse(() => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse), state);
					if (!jsx.error) return jsx.node;
					const context = this.context;
					const currentContext = context[context.length - 1];
					const lastCurrentContext = context[context.length - 2];
					if (currentContext === acornTypeScript.tokContexts.tc_oTag && lastCurrentContext === acornTypeScript.tokContexts.tc_expr) {
						context.pop();
						context.pop();
					} else if (currentContext === acornTypeScript.tokContexts.tc_oTag || currentContext === acornTypeScript.tokContexts.tc_expr) context.pop();
				}
				if (!jsx?.error && !this.tsMatchLeftRelational()) return this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
				if (!state || this.compareLookaheadState(state, this.getCurLookaheadState())) state = this.cloneCurLookaheadState();
				let typeParameters;
				const arrow = this.tryParse((abort) => {
					typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
					const expr = this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
					if (expr.type !== "ArrowFunctionExpression" || expr.extra?.parenthesized) abort();
					if (typeParameters?.params.length !== 0) this.resetStartLocationFromNode(expr, typeParameters);
					expr.typeParameters = typeParameters;
					return expr;
				}, state);
				if (!arrow.error && !arrow.aborted) {
					if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
					return arrow.node;
				}
				if (!jsx) {
					assert(true);
					typeCast = this.tryParse(() => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse), state);
					if (!typeCast.error) return typeCast.node;
				}
				if (jsx?.node) {
					this.setLookaheadState(jsx.failState);
					return jsx.node;
				}
				if (arrow.node) {
					this.setLookaheadState(arrow.failState);
					if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
					return arrow.node;
				}
				if (typeCast?.node) {
					this.setLookaheadState(typeCast.failState);
					return typeCast.node;
				}
				if (jsx?.thrown) throw jsx.error;
				if (arrow.thrown) throw arrow.error;
				if (typeCast?.thrown) throw typeCast.error;
				throw jsx?.error || arrow.error || typeCast?.error;
			}
			parseAssignableListItem(allowModifiers) {
				const decorators = [];
				while (this.match(tokTypes2.at)) decorators.push(this.parseDecorator());
				const startPos = this.start;
				const startLoc = this.startLoc;
				let accessibility;
				let readonly = false;
				let override = false;
				if (allowModifiers !== void 0) {
					const modified = {};
					this.tsParseModifiers({
						modified,
						allowedModifiers: [
							"public",
							"private",
							"protected",
							"override",
							"readonly"
						]
					});
					accessibility = modified.accessibility;
					override = modified.override;
					readonly = modified.readonly;
					if (allowModifiers === false && (accessibility || readonly || override)) this.raise(startLoc.start, TypeScriptError.UnexpectedParameterModifier);
				}
				const left = this.parseMaybeDefault(startPos, startLoc);
				this.parseBindingListItem(left);
				const elt = this.parseMaybeDefault(left["start"], left["loc"], left);
				if (decorators.length) elt.decorators = decorators;
				if (accessibility || readonly || override) {
					const pp$10 = this.startNodeAt(startPos, startLoc);
					if (accessibility) pp$10.accessibility = accessibility;
					if (readonly) pp$10.readonly = readonly;
					if (override) pp$10.override = override;
					if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") this.raise(pp$10.start, TypeScriptError.UnsupportedParameterPropertyKind);
					pp$10.parameter = elt;
					return this.finishNode(pp$10, "TSParameterProperty");
				}
				return elt;
			}
			checkLValInnerPattern(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
				switch (expr.type) {
					case "TSParameterProperty":
						this.checkLValInnerPattern(expr.parameter, bindingType, checkClashes);
						break;
					default: {
						super.checkLValInnerPattern(expr, bindingType, checkClashes);
						break;
					}
				}
			}
			parseBindingListItem(param) {
				if (this.eat(tt.question)) {
					if (param.type !== "Identifier" && !this.isAmbientContext && !this.inType) this.raise(param.start, TypeScriptError.PatternIsOptional);
					param.optional = true;
				}
				const type = this.tsTryParseTypeAnnotation();
				if (type) param.typeAnnotation = type;
				this.resetEndLocation(param);
				return param;
			}
			isAssignable(node, isBinding) {
				switch (node.type) {
					case "TSTypeCastExpression": return this.isAssignable(node.expression, isBinding);
					case "TSParameterProperty": return true;
					case "Identifier":
					case "ObjectPattern":
					case "ArrayPattern":
					case "AssignmentPattern":
					case "RestElement": return true;
					case "ObjectExpression": {
						const last = node.properties.length - 1;
						return node.properties.every((prop, i$1) => {
							return prop.type !== "ObjectMethod" && (i$1 === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
						});
					}
					case "Property":
					case "ObjectProperty": return this.isAssignable(node.value);
					case "SpreadElement": return this.isAssignable(node.argument);
					case "ArrayExpression": return node.elements.every((element) => element === null || this.isAssignable(element));
					case "AssignmentExpression": return node.operator === "=";
					case "ParenthesizedExpression": return this.isAssignable(node.expression);
					case "MemberExpression":
					case "OptionalMemberExpression": return !isBinding;
					default: return false;
				}
			}
			toAssignable(node, isBinding = false, refDestructuringErrors = new DestructuringErrors()) {
				switch (node.type) {
					case "ParenthesizedExpression": return this.toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors);
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSNonNullExpression":
					case "TSTypeAssertion":
						if (isBinding) {} else this.raise(node.start, TypeScriptError.UnexpectedTypeCastInParameter);
						return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
					case "MemberExpression": break;
					case "AssignmentExpression":
						if (!isBinding && node.left.type === "TSTypeCastExpression") node.left = this.typeCastToParameter(node.left);
						return super.toAssignable(node, isBinding, refDestructuringErrors);
					case "TSTypeCastExpression": return this.typeCastToParameter(node);
					default: return super.toAssignable(node, isBinding, refDestructuringErrors);
				}
				return node;
			}
			toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors) {
				switch (node.expression.type) {
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSNonNullExpression":
					case "TSTypeAssertion":
					case "ParenthesizedExpression": return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
					default: return super.toAssignable(node, isBinding, refDestructuringErrors);
				}
			}
			parseBindingAtom() {
				switch (this.type) {
					case tt._this: return this.parseIdent(
						/* liberal */
						true
);
					default: return super.parseBindingAtom();
				}
			}
			shouldParseArrow(exprList) {
				let shouldParseArrowRes;
				if (this.match(tt.colon)) shouldParseArrowRes = exprList.every((expr) => this.isAssignable(expr, true));
else shouldParseArrowRes = !this.canInsertSemicolon();
				if (shouldParseArrowRes) {
					if (this.match(tt.colon)) {
						const result = this.tryParse((abort) => {
							const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
							if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
							return returnType;
						});
						if (result.aborted) {
							this.shouldParseArrowReturnType = void 0;
							return false;
						}
						if (!result.thrown) {
							if (result.error) this.setLookaheadState(result.failState);
							this.shouldParseArrowReturnType = result.node;
						}
					}
					if (!this.match(tt.arrow)) {
						this.shouldParseArrowReturnType = void 0;
						return false;
					}
					return true;
				}
				this.shouldParseArrowReturnType = void 0;
				return shouldParseArrowRes;
			}
			parseParenArrowList(startPos, startLoc, exprList, forInit) {
				const node = this.startNodeAt(startPos, startLoc);
				node.returnType = this.shouldParseArrowReturnType;
				this.shouldParseArrowReturnType = void 0;
				return this.parseArrowExpression(node, exprList, false, forInit);
			}
			parseParenAndDistinguishExpression(canBeArrow, forInit) {
				let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.ecmaVersion >= 8;
				if (this.ecmaVersion >= 6) {
					const oldMaybeInArrowParameters = this.maybeInArrowParameters;
					this.maybeInArrowParameters = true;
					this.next();
					let innerStartPos = this.start, innerStartLoc = this.startLoc;
					let exprList = [], first = true, lastIsComma = false;
					let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
					this.yieldPos = 0;
					this.awaitPos = 0;
					while (this.type !== tt.parenR) {
						first ? first = false : this.expect(tt.comma);
						if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {
							lastIsComma = true;
							break;
						} else if (this.type === tt.ellipsis) {
							spreadStart = this.start;
							exprList.push(this.parseParenItem(this.parseRestBinding()));
							if (this.type === tt.comma) this.raise(this.start, "Comma is not permitted after the rest element");
							break;
						} else exprList.push(this.parseMaybeAssign(forInit, refDestructuringErrors, this.parseParenItem));
					}
					let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
					this.expect(tt.parenR);
					this.maybeInArrowParameters = oldMaybeInArrowParameters;
					if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt.arrow)) {
						this.checkPatternErrors(refDestructuringErrors, false);
						this.checkYieldAwaitInDefaultParams();
						this.yieldPos = oldYieldPos;
						this.awaitPos = oldAwaitPos;
						return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
					}
					if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
					if (spreadStart) this.unexpected(spreadStart);
					this.checkExpressionErrors(refDestructuringErrors, true);
					this.yieldPos = oldYieldPos || this.yieldPos;
					this.awaitPos = oldAwaitPos || this.awaitPos;
					if (exprList.length > 1) {
						val = this.startNodeAt(innerStartPos, innerStartLoc);
						val.expressions = exprList;
						this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
					} else val = exprList[0];
				} else val = this.parseParenExpression();
				if (this.options.preserveParens) {
					let par = this.startNodeAt(startPos, startLoc);
					par.expression = val;
					return this.finishNode(par, "ParenthesizedExpression");
				} else return val;
			}
			parseTaggedTemplateExpression(base, startPos, startLoc, optionalChainMember) {
				const node = this.startNodeAt(startPos, startLoc);
				node.tag = base;
				node.quasi = this.parseTemplate({ isTagged: true });
				if (optionalChainMember) this.raise(startPos, "Tagged Template Literals are not allowed in optionalChain.");
				return this.finishNode(node, "TaggedTemplateExpression");
			}
			shouldParseAsyncArrow() {
				if (this.match(tt.colon)) {
					const result = this.tryParse((abort) => {
						const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
						if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
						return returnType;
					});
					if (result.aborted) {
						this.shouldParseAsyncArrowReturnType = void 0;
						return false;
					}
					if (!result.thrown) {
						if (result.error) this.setLookaheadState(result.failState);
						this.shouldParseAsyncArrowReturnType = result.node;
						return !this.canInsertSemicolon() && this.eat(tt.arrow);
					}
				} else return !this.canInsertSemicolon() && this.eat(tt.arrow);
			}
			parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit) {
				const arrN = this.startNodeAt(startPos, startLoc);
				arrN.returnType = this.shouldParseAsyncArrowReturnType;
				this.shouldParseAsyncArrowReturnType = void 0;
				return this.parseArrowExpression(arrN, exprList, true, forInit);
			}
			parseExprList(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
				let elts = [], first = true;
				while (!this.eat(close)) {
					if (!first) {
						this.expect(tt.comma);
						if (allowTrailingComma && this.afterTrailingComma(close)) break;
					} else first = false;
					let elt;
					if (allowEmpty && this.type === tt.comma) elt = null;
else if (this.type === tt.ellipsis) {
						elt = this.parseSpread(refDestructuringErrors);
						if (this.maybeInArrowParameters && this.match(tt.colon)) elt.typeAnnotation = this.tsParseTypeAnnotation();
						if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
					} else elt = this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem);
					elts.push(elt);
				}
				return elts;
			}
			parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
				let _optionalChained = optionalChained;
				if (!this.hasPrecedingLineBreak() && this.value === "!" && this.match(tt.prefix)) {
					this.exprAllowed = false;
					this.next();
					const nonNullExpression = this.startNodeAt(startPos, startLoc);
					nonNullExpression.expression = base;
					base = this.finishNode(nonNullExpression, "TSNonNullExpression");
					return base;
				}
				let isOptionalCall = false;
				if (this.match(tt.questionDot) && this.lookaheadCharCode() === 60) {
					if (noCalls) return base;
					base.optional = true;
					_optionalChained = isOptionalCall = true;
					this.next();
				}
				if (this.tsMatchLeftRelational() || this.match(tt.bitShift)) {
					let missingParenErrorLoc;
					const result = this.tsTryParseAndCatch(() => {
						if (!noCalls && this.atPossibleAsyncArrow(base)) {
							const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit);
							if (asyncArrowFn) {
								base = asyncArrowFn;
								return base;
							}
						}
						const typeArguments = this.tsParseTypeArgumentsInExpression();
						if (!typeArguments) return base;
						if (isOptionalCall && !this.match(tt.parenL)) {
							missingParenErrorLoc = this.curPosition();
							return base;
						}
						if (tokenIsTemplate(this.type) || this.type === tt.backQuote) {
							const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, _optionalChained);
							result2.typeArguments = typeArguments;
							return result2;
						}
						if (!noCalls && this.eat(tt.parenL)) {
							let refDestructuringErrors = new DestructuringErrors();
							const node2 = this.startNodeAt(startPos, startLoc);
							node2.callee = base;
							node2.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false, refDestructuringErrors);
							this.tsCheckForInvalidTypeCasts(node2.arguments);
							node2.typeArguments = typeArguments;
							if (_optionalChained) node2.optional = isOptionalCall;
							this.checkExpressionErrors(refDestructuringErrors, true);
							base = this.finishNode(node2, "CallExpression");
							return base;
						}
						const tokenType = this.type;
						if (this.tsMatchRightRelational() || tokenType === tt.bitShift || tokenType !== tt.parenL && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) return;
						const node = this.startNodeAt(startPos, startLoc);
						node.expression = base;
						node.typeArguments = typeArguments;
						return this.finishNode(node, "TSInstantiationExpression");
					});
					if (missingParenErrorLoc) this.unexpected(missingParenErrorLoc);
					if (result) {
						if (result.type === "TSInstantiationExpression" && (this.match(tt.dot) || this.match(tt.questionDot) && this.lookaheadCharCode() !== 40)) this.raise(this.start, TypeScriptError.InvalidPropertyAccessAfterInstantiationExpression);
						base = result;
						return base;
					}
				}
				let optionalSupported = this.ecmaVersion >= 11;
				let optional = optionalSupported && this.eat(tt.questionDot);
				if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
				let computed = this.eat(tt.bracketL);
				if (computed || optional && this.type !== tt.parenL && this.type !== tt.backQuote || this.eat(tt.dot)) {
					let node = this.startNodeAt(startPos, startLoc);
					node.object = base;
					if (computed) {
						node.property = this.parseExpression();
						this.expect(tt.bracketR);
					} else if (this.type === tt.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
else node.property = this.parseIdent(this.options.allowReserved !== "never");
					node.computed = !!computed;
					if (optionalSupported) node.optional = optional;
					base = this.finishNode(node, "MemberExpression");
				} else if (!noCalls && this.eat(tt.parenL)) {
					const oldMaybeInArrowParameters = this.maybeInArrowParameters;
					this.maybeInArrowParameters = true;
					let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
					this.yieldPos = 0;
					this.awaitPos = 0;
					this.awaitIdentPos = 0;
					let exprList = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false, refDestructuringErrors);
					if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
						this.checkPatternErrors(refDestructuringErrors, false);
						this.checkYieldAwaitInDefaultParams();
						if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
						this.yieldPos = oldYieldPos;
						this.awaitPos = oldAwaitPos;
						this.awaitIdentPos = oldAwaitIdentPos;
						base = this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
					} else {
						this.checkExpressionErrors(refDestructuringErrors, true);
						this.yieldPos = oldYieldPos || this.yieldPos;
						this.awaitPos = oldAwaitPos || this.awaitPos;
						this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
						let node = this.startNodeAt(startPos, startLoc);
						node.callee = base;
						node.arguments = exprList;
						if (optionalSupported) node.optional = optional;
						base = this.finishNode(node, "CallExpression");
					}
					this.maybeInArrowParameters = oldMaybeInArrowParameters;
				} else if (this.type === tt.backQuote) {
					if (optional || _optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
					let node = this.startNodeAt(startPos, startLoc);
					node.tag = base;
					node.quasi = this.parseTemplate({ isTagged: true });
					base = this.finishNode(node, "TaggedTemplateExpression");
				}
				return base;
			}
			parseGetterSetter(prop) {
				prop.kind = prop.key.name;
				this.parsePropertyName(prop);
				prop.value = this.parseMethod(false);
				let paramCount = prop.kind === "get" ? 0 : 1;
				const firstParam = prop.value.params[0];
				const hasContextParam = firstParam && this.isThisParam(firstParam);
				paramCount = hasContextParam ? paramCount + 1 : paramCount;
				if (prop.value.params.length !== paramCount) {
					let start = prop.value.start;
					if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
else this.raiseRecoverable(start, "setter should have exactly one param");
				} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
			}
			parseProperty(isPattern, refDestructuringErrors) {
				if (!isPattern) {
					let decorators = [];
					if (this.match(tokTypes2.at)) while (this.match(tokTypes2.at)) decorators.push(this.parseDecorator());
					const property = super.parseProperty(isPattern, refDestructuringErrors);
					if (property.type === "SpreadElement") {
						if (decorators.length) this.raise(property.start, DecoratorsError.SpreadElementDecorator);
					}
					if (decorators.length) {
						property.decorators = decorators;
						decorators = [];
					}
					return property;
				}
				return super.parseProperty(isPattern, refDestructuringErrors);
			}
			parseCatchClauseParam() {
				const param = this.parseBindingAtom();
				let simple = param.type === "Identifier";
				this.enterScope(simple ? acornScope.SCOPE_SIMPLE_CATCH : 0);
				this.checkLValPattern(param, simple ? acornScope.BIND_SIMPLE_CATCH : acornScope.BIND_LEXICAL);
				const type = this.tsTryParseTypeAnnotation();
				if (type) {
					param.typeAnnotation = type;
					this.resetEndLocation(param);
				}
				this.expect(tt.parenR);
				return param;
			}
			parseClass(node, isStatement) {
				const oldInAbstractClass = this.inAbstractClass;
				this.inAbstractClass = !!node.abstract;
				try {
					this.next();
					this.takeDecorators(node);
					const oldStrict = this.strict;
					this.strict = true;
					this.parseClassId(node, isStatement);
					this.parseClassSuper(node);
					const privateNameMap = this.enterClassBody();
					const classBody = this.startNode();
					let hadConstructor = false;
					classBody.body = [];
					let decorators = [];
					this.expect(tt.braceL);
					while (this.type !== tt.braceR) {
						if (this.match(tokTypes2.at)) {
							decorators.push(this.parseDecorator());
							continue;
						}
						const element = this.parseClassElement(node.superClass !== null);
						if (decorators.length) {
							element.decorators = decorators;
							this.resetStartLocationFromNode(element, decorators[0]);
							decorators = [];
						}
						if (element) {
							classBody.body.push(element);
							if (element.type === "MethodDefinition" && element.kind === "constructor" && element.value.type === "FunctionExpression") {
								if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
								hadConstructor = true;
								if (element.decorators && element.decorators.length > 0) this.raise(element.start, DecoratorsError.DecoratorConstructor);
							} else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, `Identifier '#${element.key.name}' has already been declared`);
						}
					}
					this.strict = oldStrict;
					this.next();
					if (decorators.length) this.raise(this.start, DecoratorsError.TrailingDecorator);
					node.body = this.finishNode(classBody, "ClassBody");
					this.exitClassBody();
					return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
				} finally {
					this.inAbstractClass = oldInAbstractClass;
				}
			}
			parseClassFunctionParams() {
				const typeParameters = this.tsTryParseTypeParameters();
				let params = this.parseBindingList(tt.parenR, false, this.ecmaVersion >= 8, true);
				if (typeParameters) params.typeParameters = typeParameters;
				return params;
			}
			parseMethod(isGenerator, isAsync, allowDirectSuper, inClassScope, method) {
				let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
				this.initFunction(node);
				if (this.ecmaVersion >= 6) node.generator = isGenerator;
				if (this.ecmaVersion >= 8) node.async = !!isAsync;
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.enterScope(functionFlags(isAsync, node.generator) | acornScope.SCOPE_SUPER | (allowDirectSuper ? acornScope.SCOPE_DIRECT_SUPER : 0));
				this.expect(tt.parenL);
				node.params = this.parseClassFunctionParams();
				this.checkYieldAwaitInDefaultParams();
				this.parseFunctionBody(node, false, true, false, { isClassMethod: inClassScope });
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				if (method && method.abstract) {
					const hasBody = !!node.body;
					if (hasBody) {
						const { key } = method;
						this.raise(method.start, TypeScriptError.AbstractMethodHasImplementation({ methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]` }));
					}
				}
				return this.finishNode(node, "FunctionExpression");
			}
			static parse(input, options2) {
				if (options2.locations === false) throw new Error(`You have to enable options.locations while using acorn-typescript`);
else options2.locations = true;
				const parser = new this(options2, input);
				if (dts) parser.isAmbientContext = true;
				return parser.parse();
			}
			static parseExpressionAt(input, pos, options2) {
				if (options2.locations === false) throw new Error(`You have to enable options.locations while using acorn-typescript`);
else options2.locations = true;
				const parser = new this(options2, input, pos);
				if (dts) parser.isAmbientContext = true;
				parser.nextToken();
				return parser.parseExpression();
			}
			parseImportSpecifier() {
				const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
				if (isMaybeTypeOnly) {
					let node = this.startNode();
					node.imported = this.parseModuleExportName();
					this.parseTypeOnlyImportExportSpecifier(
						node,
						/* isImport */
						true,
						this.importOrExportOuterKind === "type"
);
					return this.finishNode(node, "ImportSpecifier");
				} else {
					const node = super.parseImportSpecifier();
					node.importKind = "value";
					return node;
				}
			}
			parseExportSpecifier(exports$1) {
				const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
				const isString = this.match(tt.string);
				if (!isString && isMaybeTypeOnly) {
					let node = this.startNode();
					node.local = this.parseModuleExportName();
					this.parseTypeOnlyImportExportSpecifier(
						node,
						/* isImport */
						false,
						this.importOrExportOuterKind === "type"
);
					this.finishNode(node, "ExportSpecifier");
					this.checkExport(exports$1, node.exported, node.exported.start);
					return node;
				} else {
					const node = super.parseExportSpecifier(exports$1);
					node.exportKind = "value";
					return node;
				}
			}
			parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
				const leftOfAsKey = isImport ? "imported" : "local";
				const rightOfAsKey = isImport ? "local" : "exported";
				let leftOfAs = node[leftOfAsKey];
				let rightOfAs;
				let hasTypeSpecifier = false;
				let canParseAsKeyword = true;
				const loc = leftOfAs.start;
				if (this.isContextual("as")) {
					const firstAs = this.parseIdent();
					if (this.isContextual("as")) {
						const secondAs = this.parseIdent();
						if (tokenIsKeywordOrIdentifier(this.type)) {
							hasTypeSpecifier = true;
							leftOfAs = firstAs;
							rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
							canParseAsKeyword = false;
						} else {
							rightOfAs = secondAs;
							canParseAsKeyword = false;
						}
					} else if (tokenIsKeywordOrIdentifier(this.type)) {
						canParseAsKeyword = false;
						rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
					} else {
						hasTypeSpecifier = true;
						leftOfAs = firstAs;
					}
				} else if (tokenIsKeywordOrIdentifier(this.type)) {
					hasTypeSpecifier = true;
					if (isImport) {
						leftOfAs = super.parseIdent(true);
						if (!this.isContextual("as")) this.checkUnreserved(leftOfAs);
					} else leftOfAs = this.parseModuleExportName();
				}
				if (hasTypeSpecifier && isInTypeOnlyImportExport) this.raise(loc, isImport ? TypeScriptError.TypeModifierIsUsedInTypeImports : TypeScriptError.TypeModifierIsUsedInTypeExports);
				node[leftOfAsKey] = leftOfAs;
				node[rightOfAsKey] = rightOfAs;
				const kindKey = isImport ? "importKind" : "exportKind";
				node[kindKey] = hasTypeSpecifier ? "type" : "value";
				if (canParseAsKeyword && this.eatContextual("as")) node[rightOfAsKey] = isImport ? this.parseIdent() : this.parseModuleExportName();
				if (!node[rightOfAsKey]) node[rightOfAsKey] = this.copyNode(node[leftOfAsKey]);
				if (isImport) this.checkLValSimple(node[rightOfAsKey], acornScope.BIND_LEXICAL);
			}
			raiseCommonCheck(pos, message, recoverable) {
				switch (message) {
					case "Comma is not permitted after the rest element": if (this.isAmbientContext && this.match(tt.comma) && this.lookaheadCharCode() === 41) {
						this.next();
						return;
					} else return super.raise(pos, message);
				}
				return recoverable ? super.raiseRecoverable(pos, message) : super.raise(pos, message);
			}
			raiseRecoverable(pos, message) {
				return this.raiseCommonCheck(pos, message, true);
			}
			raise(pos, message) {
				return this.raiseCommonCheck(pos, message, true);
			}
			updateContext(prevType) {
				const { type } = this;
				if (type == tt.braceL) {
					var curContext = this.curContext();
					if (curContext == tsTokContexts.tc_oTag) this.context.push(tokContexts.b_expr);
else if (curContext == tsTokContexts.tc_expr) this.context.push(tokContexts.b_tmpl);
else super.updateContext(prevType);
					this.exprAllowed = true;
				} else if (type === tt.slash && prevType === tokTypes2.jsxTagStart) {
					this.context.length -= 2;
					this.context.push(tsTokContexts.tc_cTag);
					this.exprAllowed = false;
				} else return super.updateContext(prevType);
			}
			jsx_parseOpeningElementAt(startPos, startLoc) {
				let node = this.startNodeAt(startPos, startLoc);
				let nodeName = this.jsx_parseElementName();
				if (nodeName) node.name = nodeName;
				if (this.match(tt.relational) || this.match(tt.bitShift)) {
					const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
					if (typeArguments) node.typeArguments = typeArguments;
				}
				node.attributes = [];
				while (this.type !== tt.slash && this.type !== tokTypes2.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());
				node.selfClosing = this.eat(tt.slash);
				this.expect(tokTypes2.jsxTagEnd);
				return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
			}
			enterScope(flags) {
				if (flags === TS_SCOPE_TS_MODULE) this.importsStack.push([]);
				super.enterScope(flags);
				const scope = super.currentScope();
				scope.types = [];
				scope.enums = [];
				scope.constEnums = [];
				scope.classes = [];
				scope.exportOnlyBindings = [];
			}
			exitScope() {
				const scope = super.currentScope();
				if (scope.flags === TS_SCOPE_TS_MODULE) this.importsStack.pop();
				super.exitScope();
			}
			hasImport(name, allowShadow) {
				const len = this.importsStack.length;
				if (this.importsStack[len - 1].indexOf(name) > -1) return true;
				if (!allowShadow && len > 1) {
					for (let i$1 = 0; i$1 < len - 1; i$1++) if (this.importsStack[i$1].indexOf(name) > -1) return true;
				}
				return false;
			}
			maybeExportDefined(scope, name) {
				if (this.inModule && scope.flags & acornScope.SCOPE_TOP) this.undefinedExports.delete(name);
			}
			declareName(name, bindingType, pos) {
				if (bindingType & acornScope.BIND_FLAGS_TS_IMPORT) {
					if (this.hasImport(name, true)) this.raise(pos, `Identifier '${name}' has already been declared.`);
					this.importsStack[this.importsStack.length - 1].push(name);
					return;
				}
				const scope = this.currentScope();
				if (bindingType & acornScope.BIND_FLAGS_TS_EXPORT_ONLY) {
					this.maybeExportDefined(scope, name);
					scope.exportOnlyBindings.push(name);
					return;
				}
				if (bindingType === acornScope.BIND_TS_TYPE || bindingType === acornScope.BIND_TS_INTERFACE) {
					if (bindingType === acornScope.BIND_TS_TYPE && scope.types.includes(name)) this.raise(pos, `type '${name}' has already been declared.`);
					scope.types.push(name);
				} else super.declareName(name, bindingType, pos);
				if (bindingType & acornScope.BIND_FLAGS_TS_ENUM) scope.enums.push(name);
				if (bindingType & acornScope.BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
				if (bindingType & acornScope.BIND_FLAGS_CLASS) scope.classes.push(name);
			}
			checkLocalExport(id) {
				const { name } = id;
				if (this.hasImport(name)) return;
				const len = this.scopeStack.length;
				for (let i$1 = len - 1; i$1 >= 0; i$1--) {
					const scope = this.scopeStack[i$1];
					if (scope.types.indexOf(name) > -1 || scope.exportOnlyBindings.indexOf(name) > -1) return;
				}
				super.checkLocalExport(id);
			}
		}
		return TypeScriptParser;
	};
}
var import_silver_fleece_umd = __toESM(require_silver_fleece_umd(), 1);
function parseScript(content) {
	const comments = [];
	const acornTs = Parser.extend(tsPlugin());
	const ast = acornTs.parse(content, {
		ecmaVersion: "latest",
		sourceType: "module",
		locations: true,
		onComment: (block$1, value, start, end) => {
			if (block$1 && /\n/.test(value)) {
				let a = start;
				while (a > 0 && content[a - 1] !== "\n") a -= 1;
				let b = a;
				while (/[ \t]/.test(content[b])) b += 1;
				const indentation = content.slice(a, b);
				value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
			}
			comments.push({
				type: block$1 ? "Block" : "Line",
				value,
				start,
				end
			});
		}
	});
	walk(ast, null, { _(commentNode, { next }) {
		let comment$1 = comments.shift();
		while (comment$1 && comment$1.start < commentNode.start) {
			commentNode.leadingComments ??= [];
			commentNode.leadingComments.push(comment$1);
			comment$1 = comments.shift();
		}
		next();
		comment$1 = comments.shift();
		if (comment$1) {
			const slice = content.slice(commentNode.end, comment$1.start);
			if (/^[,) \t]*$/.test(slice)) commentNode.trailingComments = [comment$1];
		}
	} });
	return ast;
}
function serializeScript(ast, previousContent) {
	const { code } = print(ast, {
		indent: guessIndentString(previousContent),
		quotes: guessQuoteStyle(ast)
	});
	return code;
}
function parseCss(content) {
	return parse$1(content);
}
function parseHtml(content) {
	return parseDocument(content, {
		recognizeSelfClosing: true,
		lowerCaseTags: false
	});
}
function serializeHtml(ast) {
	return esm_default(ast, {
		encodeEntities: "utf8",
		selfClosingTags: true
	});
}
function stripAst(node, propsToRemove) {
	if (typeof node !== "object" || node === null) return node;
	for (const key in node) {
		if (propsToRemove.includes(key)) {
			delete node[key];
			continue;
		}
		const child = node[key];
		if (child && typeof child === "object") if (Array.isArray(child)) child.forEach((element) => stripAst(element, propsToRemove));
else stripAst(child, propsToRemove);
	}
	return node;
}
function parseJson(content) {
	return import_silver_fleece_umd.evaluate(content);
}
function serializeJson(originalInput, data$1) {
	const indentString = guessIndentString(originalInput);
	let spaces;
	if (indentString && indentString.includes(" ")) spaces = (indentString.match(/ /g) || []).length;
	return import_silver_fleece_umd.stringify(data$1, { spaces });
}
function guessIndentString(str) {
	if (!str) return "	";
	const lines = str.split("\n");
	let tabs = 0;
	let spaces = 0;
	let minSpaces = 8;
	lines.forEach((line) => {
		const match = /^(?: +|\t+)/.exec(line);
		if (!match) return;
		const whitespace = match[0];
		if (whitespace.length === line.length) return;
		if (whitespace[0] === "	") tabs += 1;
else {
			spaces += 1;
			if (whitespace.length > 1 && whitespace.length < minSpaces) minSpaces = whitespace.length;
		}
	});
	if (spaces > tabs) {
		let result = "";
		while (minSpaces--) result += " ";
		return result;
	} else return "	";
}
function guessQuoteStyle(ast) {
	let singleCount = 0;
	let doubleCount = 0;
	walk(ast, null, { Literal(node) {
		if (node.raw && node.raw.length >= 2) {
			const quotes = [node.raw[0], node.raw[node.raw.length - 1]];
			for (const quote$1 of quotes) switch (quote$1) {
				case "'":
					singleCount++;
					break;
				case "\"":
					doubleCount++;
					break;
				default: break;
			}
		}
	} });
	if (singleCount === 0 && doubleCount === 0) return undefined;
	return singleCount > doubleCount ? "single" : "double";
}

//#endregion
//#region packages/core/dist/parsers.js
var BitSet = class BitSet$1 {
	constructor(arg) {
		this.bits = arg instanceof BitSet$1 ? arg.bits.slice() : [];
	}
	add(n$1) {
		this.bits[n$1 >> 5] |= 1 << (n$1 & 31);
	}
	has(n$1) {
		return !!(this.bits[n$1 >> 5] & 1 << (n$1 & 31));
	}
};
var Chunk = class Chunk$1 {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;
		this.intro = "";
		this.outro = "";
		this.content = content;
		this.storeName = false;
		this.edited = false;
		{
			this.previous = null;
			this.next = null;
		}
	}
	appendLeft(content) {
		this.outro += content;
	}
	appendRight(content) {
		this.intro = this.intro + content;
	}
	clone() {
		const chunk = new Chunk$1(this.start, this.end, this.original);
		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;
		return chunk;
	}
	contains(index) {
		return this.start < index && index < this.end;
	}
	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}
	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}
	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = "";
			this.outro = "";
		}
		this.storeName = storeName;
		this.edited = true;
		return this;
	}
	prependLeft(content) {
		this.outro = content + this.outro;
	}
	prependRight(content) {
		this.intro = content + this.intro;
	}
	reset() {
		this.intro = "";
		this.outro = "";
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}
	split(index) {
		const sliceIndex = index - this.start;
		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);
		this.original = originalBefore;
		const newChunk = new Chunk$1(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = "";
		this.end = index;
		if (this.edited) {
			newChunk.edit("", false);
			this.content = "";
		} else this.content = originalBefore;
		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;
		return newChunk;
	}
	toString() {
		return this.intro + this.content + this.outro;
	}
	trimEnd(rx) {
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit("", undefined, true);
				if (this.edited) this.edit(trimmed, this.storeName, true);
			}
			return true;
		} else {
			this.edit("", undefined, true);
			this.intro = this.intro.replace(rx, "");
			if (this.intro.length) return true;
		}
	}
	trimStart(rx) {
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) newChunk.edit(trimmed, this.storeName, true);
				this.edit("", undefined, true);
			}
			return true;
		} else {
			this.edit("", undefined, true);
			this.outro = this.outro.replace(rx, "");
			if (this.outro.length) return true;
		}
	}
};
function getBtoa() {
	if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
else if (typeof Buffer === "function") return (str) => Buffer.from(str, "utf-8").toString("base64");
else return () => {
		throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
	};
}
const btoa = /*#__PURE__*/ getBtoa();
var SourceMap = class {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
		if (typeof properties.debugId !== "undefined") this.debugId = properties.debugId;
	}
	toString() {
		return JSON.stringify(this);
	}
	toUrl() {
		return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
	}
};
function guessIndent(code) {
	const lines = code.split("\n");
	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));
	if (tabbed.length === 0 && spaced.length === 0) return null;
	if (tabbed.length >= spaced.length) return "	";
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);
	return new Array(min + 1).join(" ");
}
function getRelativePath(from$1, to) {
	const fromParts = from$1.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);
	fromParts.pop();
	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}
	if (fromParts.length) {
		let i$1 = fromParts.length;
		while (i$1--) fromParts[i$1] = "..";
	}
	return fromParts.concat(toParts).join("/");
}
const toString = Object.prototype.toString;
function isObject(thing) {
	return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
	const originalLines = source.split("\n");
	const lineOffsets = [];
	for (let i$1 = 0, pos = 0; i$1 < originalLines.length; i$1++) {
		lineOffsets.push(pos);
		pos += originalLines[i$1].length + 1;
	}
	return function locate(index) {
		let i$1 = 0;
		let j = lineOffsets.length;
		while (i$1 < j) {
			const m = i$1 + j >> 1;
			if (index < lineOffsets[m]) j = m;
else i$1 = m + 1;
		}
		const line = i$1 - 1;
		const column = index - lineOffsets[line];
		return {
			line,
			column
		};
	};
}
const wordRegex = /\w/;
var Mappings = class {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}
	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf("\n", 0);
			let previousContentLineEnd = -1;
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment$1 = [
					this.generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column
				];
				if (nameIndex >= 0) segment$1.push(nameIndex);
				this.rawSegments.push(segment$1);
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
			}
			const segment = [
				this.generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column
			];
			if (nameIndex >= 0) segment.push(nameIndex);
			this.rawSegments.push(segment);
			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}
		this.pending = null;
	}
	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		let charInHiresBoundary = false;
		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === "\n") {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [
						this.generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column
					];
					if (this.hires === "boundary") if (wordRegex.test(original[originalCharIndex])) {
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
else this.rawSegments.push(segment);
				}
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}
			originalCharIndex += 1;
		}
		this.pending = null;
	}
	advance(str) {
		if (!str) return;
		const lines = str.split("\n");
		if (lines.length > 1) {
			for (let i$1 = 0; i$1 < lines.length - 1; i$1++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}
		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
};
const n = "\n";
const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};
var MagicString = class MagicString$1 {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);
		Object.defineProperties(this, {
			original: {
				writable: true,
				value: string
			},
			outro: {
				writable: true,
				value: ""
			},
			intro: {
				writable: true,
				value: ""
			},
			firstChunk: {
				writable: true,
				value: chunk
			},
			lastChunk: {
				writable: true,
				value: chunk
			},
			lastSearchedChunk: {
				writable: true,
				value: chunk
			},
			byStart: {
				writable: true,
				value: {}
			},
			byEnd: {
				writable: true,
				value: {}
			},
			filename: {
				writable: true,
				value: options.filename
			},
			indentExclusionRanges: {
				writable: true,
				value: options.indentExclusionRanges
			},
			sourcemapLocations: {
				writable: true,
				value: new BitSet()
			},
			storedNames: {
				writable: true,
				value: {}
			},
			indentStr: {
				writable: true,
				value: undefined
			},
			ignoreList: {
				writable: true,
				value: options.ignoreList
			},
			offset: {
				writable: true,
				value: options.offset || 0
			}
		});
		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}
	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}
	append(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.outro += content;
		return this;
	}
	appendLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.appendLeft(content);
else this.intro += content;
		return this;
	}
	appendRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.appendRight(content);
else this.outro += content;
		return this;
	}
	clone() {
		const cloned = new MagicString$1(this.original, {
			filename: this.filename,
			offset: this.offset
		});
		let originalChunk = this.firstChunk;
		let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;
			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;
				clonedChunk = nextClonedChunk;
			}
			originalChunk = nextOriginalChunk;
		}
		cloned.lastChunk = clonedChunk;
		if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
		cloned.intro = this.intro;
		cloned.outro = this.outro;
		return cloned;
	}
	generateDecodedMap(options) {
		options = options || {};
		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);
		const locate = getLocator(this.original);
		if (this.intro) mappings.advance(this.intro);
		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);
			if (chunk.intro.length) mappings.advance(chunk.intro);
			if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			if (chunk.outro.length) mappings.advance(chunk.outro);
		});
		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: [options.source ? getRelativePath(options.file || "", options.source) : options.file || ""],
			sourcesContent: options.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined
		};
	}
	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}
	_ensureindentStr() {
		if (this.indentStr === undefined) this.indentStr = guessIndent(this.original);
	}
	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}
	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? "	" : this.indentStr;
	}
	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;
		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}
		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || "	";
		}
		if (indentStr === "") return this;
		options = options || {};
		const isExcluded = {};
		if (options.exclude) {
			const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
			exclusions.forEach((exclusion) => {
				for (let i$1 = exclusion[0]; i$1 < exclusion[1]; i$1 += 1) isExcluded[i$1] = true;
			});
		}
		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};
		this.intro = this.intro.replace(pattern, replacer);
		let charIndex = 0;
		let chunk = this.firstChunk;
		while (chunk) {
			const end = chunk.end;
			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);
					if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
				}
			} else {
				charIndex = chunk.start;
				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];
						if (char === "\n") shouldIndentNextCharacter = true;
else if (char !== "\r" && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;
							if (charIndex === chunk.start) chunk.prependRight(indentStr);
else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}
					charIndex += 1;
				}
			}
			charIndex = chunk.end;
			chunk = chunk.next;
		}
		this.outro = this.outro.replace(pattern, replacer);
		return this;
	}
	insert() {
		throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
	}
	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
			warned.insertLeft = true;
		}
		return this.appendLeft(index, content);
	}
	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
			warned.insertRight = true;
		}
		return this.prependRight(index, content);
	}
	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;
		if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
		this._split(start);
		this._split(end);
		this._split(index);
		const first = this.byStart[start];
		const last = this.byEnd[end];
		const oldLeft = first.previous;
		const oldRight = last.next;
		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;
		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;
		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;
		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}
		first.previous = newLeft;
		last.next = newRight || null;
		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}
	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, {
			...options,
			overwrite: !options.contentOnly
		});
	}
	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;
		if (typeof content !== "string") throw new TypeError("replacement content must be a string");
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (end > this.original.length) throw new Error("end is out of bounds");
		if (start === end) throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
		this._split(start);
		this._split(end);
		if (options === true) {
			if (!warned.storeName) {
				console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
				warned.storeName = true;
			}
			options = { storeName: true };
		}
		const storeName = options !== undefined ? options.storeName : false;
		const overwrite = options !== undefined ? options.overwrite : false;
		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true
			});
		}
		const first = this.byStart[start];
		const last = this.byEnd[end];
		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
				chunk = chunk.next;
				chunk.edit("", false);
			}
			first.edit(content, storeName, !overwrite);
		} else {
			const newChunk = new Chunk(start, end, "").edit(content, storeName);
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}
	prepend(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.intro = content + this.intro;
		return this;
	}
	prependLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.prependLeft(content);
else this.intro = content + this.intro;
		return this;
	}
	prependRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.prependRight(content);
else this.outro = content + this.outro;
		return this;
	}
	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.intro = "";
			chunk.outro = "";
			chunk.edit("");
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.reset();
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while (chunk = chunk.previous);
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return "";
	}
	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}
			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}
			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while (chunk = chunk.previous);
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}
	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		let result = "";
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			if (chunk.start < end && chunk.end >= end) return result;
			chunk = chunk.next;
		}
		if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
			result += chunk.content.slice(sliceStart, sliceEnd);
			if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
			if (containsEnd) break;
			chunk = chunk.next;
		}
		return result;
	}
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);
		return clone;
	}
	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;
		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;
		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);
			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}
	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			const loc = getLocator(this.original)(index);
			throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`);
		}
		const newChunk = chunk.split(index);
		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;
		if (chunk === this.lastChunk) this.lastChunk = newChunk;
		this.lastSearchedChunk = chunk;
		return true;
	}
	toString() {
		let str = this.intro;
		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}
		return str + this.outro;
	}
	isEmpty() {
		let chunk = this.firstChunk;
		do 
			if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
		while (chunk = chunk.next);
		return true;
	}
	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do 
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		while (chunk = chunk.next);
		return length;
	}
	trimLines() {
		return this.trim("[\\r\\n]");
	}
	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}
	trimEndAborted(charType) {
		const rx = new RegExp((charType || "\\s") + "+$");
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		let chunk = this.lastChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);
		return false;
	}
	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp("^" + (charType || "\\s") + "+");
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		let chunk = this.firstChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);
			if (chunk.end !== end) {
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);
		return false;
	}
	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}
	hasChanged() {
		return this.original !== this.toString();
	}
	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_, i$1) => {
				if (i$1 === "$") return "$";
				if (i$1 === "&") return match[0];
				const num = +i$1;
				if (num < match.length) return match[+i$1];
				return `$${i$1}`;
			});
else return replacement(...match, match.index, str, match.groups);
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while (match = re.exec(str)) matches.push(match);
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement$1 = getReplacement(match, this.original);
					if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		}
		return this;
	}
	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);
		if (index !== -1) this.overwrite(index, index + string.length, replacement);
		return this;
	}
	replace(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceString(searchValue, replacement);
		return this._replaceRegexp(searchValue, replacement);
	}
	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
			const previous = original.slice(index, index + stringLength);
			if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
		}
		return this;
	}
	replaceAll(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceAllString(searchValue, replacement);
		if (!searchValue.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
		return this._replaceRegexp(searchValue, replacement);
	}
};
function parseScript$1(source) {
	const ast = parseScript(source);
	const generateCode = () => serializeScript(ast, source);
	return {
		ast,
		source,
		generateCode
	};
}
function parseCss$1(source) {
	const ast = parseCss(source);
	const generateCode = () => ast.toString();
	return {
		ast,
		source,
		generateCode
	};
}
function parseHtml$1(source) {
	const ast = parseHtml(source);
	const generateCode = () => serializeHtml(ast);
	return {
		ast,
		source,
		generateCode
	};
}
function parseJson$1(source) {
	if (!source) source = "{}";
	const data$1 = parseJson(source);
	const generateCode = () => serializeJson(source, data$1);
	return {
		data: data$1,
		source,
		generateCode
	};
}
function parseSvelte(source, options) {
	const scripts = extractScripts(source);
	const { tag: scriptTag = "", src: scriptSource = "" } = scripts.find(({ attrs }) => !attrs.includes("module")) ?? {};
	const { tag: moduleScriptTag = "", src: moduleSource = "" } = scripts.find(({ attrs }) => attrs.includes("module")) ?? {};
	const { styleTag, cssSource } = extractStyle(source);
	const templateSource = source.replace(moduleScriptTag, "").replace(scriptTag, "").replace(styleTag, "").trim();
	const script = parseScript$1(scriptSource);
	const module = parseScript$1(moduleSource);
	const css = parseCss$1(cssSource);
	const template = parseHtml$1(templateSource);
	const generateCode = (code) => {
		const ms = new MagicString(source);
		if (code.script !== undefined) if (scriptSource.length === 0) {
			const ts = options?.typescript ? " lang=\"ts\"" : "";
			const indented = code.script.split("\n").join("\n	");
			const script$1 = `<script${ts}>\n\t${indented}\n</script>\n\n`;
			ms.prepend(script$1);
		} else {
			const { start, end } = locations(source, scriptSource);
			const formatted = indent(code.script, ms.getIndentString());
			ms.update(start, end, formatted);
		}
		if (code.module !== undefined) if (moduleSource.length === 0) {
			const ts = options?.typescript ? " lang=\"ts\"" : "";
			const indented = code.module.split("\n").join("\n	");
			const module$1 = `<script${ts} context="module">\n\t${indented}\n</script>\n\n`;
			ms.prepend(module$1);
		} else {
			const { start, end } = locations(source, moduleSource);
			const formatted = indent(code.module, ms.getIndentString());
			ms.update(start, end, formatted);
		}
		if (code.css !== undefined) if (cssSource.length === 0) {
			const indented = code.css.split("\n").join("\n	");
			const style = `\n<style>\n\t${indented}\n</style>\n`;
			ms.append(style);
		} else {
			const { start, end } = locations(source, cssSource);
			const formatted = indent(code.css, ms.getIndentString());
			ms.update(start, end, formatted);
		}
		if (code.template !== undefined) if (templateSource.length === 0) ms.appendLeft(0, code.template);
else {
			const { start, end } = locations(source, templateSource);
			ms.update(start, end, code.template);
		}
		return ms.toString();
	};
	return {
		script: {
			...script,
			source: scriptSource
		},
		module: {
			...module,
			source: moduleSource
		},
		css: {
			...css,
			source: cssSource
		},
		template: {
			...template,
			source: templateSource
		},
		generateCode
	};
}
function locations(source, search) {
	const start = source.indexOf(search);
	const end = start + search.length;
	return {
		start,
		end
	};
}
function indent(content, indent$1$1) {
	const indented = indent$1$1 + content.split("\n").join(`\n${indent$1$1}`);
	return `\n${indented}\n`;
}
const regexScriptTags = /<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/;
const regexStyleTags = /<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/;
function extractScripts(source) {
	const scripts = [];
	const [tag = "", attrs = "", src = ""] = regexScriptTags.exec(source) ?? [];
	if (tag) {
		const stripped = source.replace(tag, "");
		scripts.push({
			tag,
			attrs,
			src
		}, ...extractScripts(stripped));
		return scripts;
	}
	return [];
}
function extractStyle(source) {
	const [styleTag = "", attributes = "", cssSource = ""] = regexStyleTags.exec(source) ?? [];
	return {
		styleTag,
		attributes,
		cssSource
	};
}

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/error.js
var require_error = __commonJS$3({ "node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/error.js"(exports) {
	var CommanderError$3 = class extends Error {
		/**
		* Constructs the CommanderError class
		* @param {number} exitCode suggested exit code which could be used with process.exit
		* @param {string} code an id string representing the error
		* @param {string} message human-readable description of the error
		*/
		constructor(exitCode, code, message) {
			super(message);
			Error.captureStackTrace(this, this.constructor);
			this.name = this.constructor.name;
			this.code = code;
			this.exitCode = exitCode;
			this.nestedError = undefined;
		}
	};
	var InvalidArgumentError$4 = class extends CommanderError$3 {
		/**
		* Constructs the InvalidArgumentError class
		* @param {string} [message] explanation of why argument is invalid
		*/
		constructor(message) {
			super(1, "commander.invalidArgument", message);
			Error.captureStackTrace(this, this.constructor);
			this.name = this.constructor.name;
		}
	};
	exports.CommanderError = CommanderError$3;
	exports.InvalidArgumentError = InvalidArgumentError$4;
} });

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/argument.js
var require_argument = __commonJS$3({ "node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/argument.js"(exports) {
	const { InvalidArgumentError: InvalidArgumentError$3 } = require_error();
	var Argument$3 = class {
		/**
		* Initialize a new command argument with the given name and description.
		* The default is that the argument is required, and you can explicitly
		* indicate this with <> around the name. Put [] around the name for an optional argument.
		*
		* @param {string} name
		* @param {string} [description]
		*/
		constructor(name, description) {
			this.description = description || "";
			this.variadic = false;
			this.parseArg = undefined;
			this.defaultValue = undefined;
			this.defaultValueDescription = undefined;
			this.argChoices = undefined;
			switch (name[0]) {
				case "<":
					this.required = true;
					this._name = name.slice(1, -1);
					break;
				case "[":
					this.required = false;
					this._name = name.slice(1, -1);
					break;
				default:
					this.required = true;
					this._name = name;
					break;
			}
			if (this._name.length > 3 && this._name.slice(-3) === "...") {
				this.variadic = true;
				this._name = this._name.slice(0, -3);
			}
		}
		/**
		* Return argument name.
		*
		* @return {string}
		*/
		name() {
			return this._name;
		}
		/**
		* @package
		*/
		_concatValue(value, previous) {
			if (previous === this.defaultValue || !Array.isArray(previous)) return [value];
			return previous.concat(value);
		}
		/**
		* Set the default value, and optionally supply the description to be displayed in the help.
		*
		* @param {*} value
		* @param {string} [description]
		* @return {Argument}
		*/
		default(value, description) {
			this.defaultValue = value;
			this.defaultValueDescription = description;
			return this;
		}
		/**
		* Set the custom handler for processing CLI command arguments into argument values.
		*
		* @param {Function} [fn]
		* @return {Argument}
		*/
		argParser(fn) {
			this.parseArg = fn;
			return this;
		}
		/**
		* Only allow argument value to be one of choices.
		*
		* @param {string[]} values
		* @return {Argument}
		*/
		choices(values) {
			this.argChoices = values.slice();
			this.parseArg = (arg, previous) => {
				if (!this.argChoices.includes(arg)) throw new InvalidArgumentError$3(`Allowed choices are ${this.argChoices.join(", ")}.`);
				if (this.variadic) return this._concatValue(arg, previous);
				return arg;
			};
			return this;
		}
		/**
		* Make argument required.
		*
		* @returns {Argument}
		*/
		argRequired() {
			this.required = true;
			return this;
		}
		/**
		* Make argument optional.
		*
		* @returns {Argument}
		*/
		argOptional() {
			this.required = false;
			return this;
		}
	};
	/**
	* Takes an argument and returns its human readable equivalent for help usage.
	*
	* @param {Argument} arg
	* @return {string}
	* @private
	*/
	function humanReadableArgName$2(arg) {
		const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
		return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
	}
	exports.Argument = Argument$3;
	exports.humanReadableArgName = humanReadableArgName$2;
} });

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/help.js
var require_help = __commonJS$3({ "node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/help.js"(exports) {
	const { humanReadableArgName: humanReadableArgName$1 } = require_argument();
	var Help$3 = class {
		constructor() {
			this.helpWidth = undefined;
			this.minWidthToWrap = 40;
			this.sortSubcommands = false;
			this.sortOptions = false;
			this.showGlobalOptions = false;
		}
		/**
		* prepareContext is called by Commander after applying overrides from `Command.configureHelp()`
		* and just before calling `formatHelp()`.
		*
		* Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.
		*
		* @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions
		*/
		prepareContext(contextOptions) {
			this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
		}
		/**
		* Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
		*
		* @param {Command} cmd
		* @returns {Command[]}
		*/
		visibleCommands(cmd) {
			const visibleCommands = cmd.commands.filter((cmd$1) => !cmd$1._hidden);
			const helpCommand = cmd._getHelpCommand();
			if (helpCommand && !helpCommand._hidden) visibleCommands.push(helpCommand);
			if (this.sortSubcommands) visibleCommands.sort((a, b) => {
				return a.name().localeCompare(b.name());
			});
			return visibleCommands;
		}
		/**
		* Compare options for sort.
		*
		* @param {Option} a
		* @param {Option} b
		* @returns {number}
		*/
		compareOptions(a, b) {
			const getSortKey = (option) => {
				return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
			};
			return getSortKey(a).localeCompare(getSortKey(b));
		}
		/**
		* Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
		*
		* @param {Command} cmd
		* @returns {Option[]}
		*/
		visibleOptions(cmd) {
			const visibleOptions = cmd.options.filter((option) => !option.hidden);
			const helpOption = cmd._getHelpOption();
			if (helpOption && !helpOption.hidden) {
				const removeShort = helpOption.short && cmd._findOption(helpOption.short);
				const removeLong = helpOption.long && cmd._findOption(helpOption.long);
				if (!removeShort && !removeLong) visibleOptions.push(helpOption);
else if (helpOption.long && !removeLong) visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
else if (helpOption.short && !removeShort) visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
			}
			if (this.sortOptions) visibleOptions.sort(this.compareOptions);
			return visibleOptions;
		}
		/**
		* Get an array of the visible global options. (Not including help.)
		*
		* @param {Command} cmd
		* @returns {Option[]}
		*/
		visibleGlobalOptions(cmd) {
			if (!this.showGlobalOptions) return [];
			const globalOptions = [];
			for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
				const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);
				globalOptions.push(...visibleOptions);
			}
			if (this.sortOptions) globalOptions.sort(this.compareOptions);
			return globalOptions;
		}
		/**
		* Get an array of the arguments if any have a description.
		*
		* @param {Command} cmd
		* @returns {Argument[]}
		*/
		visibleArguments(cmd) {
			if (cmd._argsDescription) cmd.registeredArguments.forEach((argument) => {
				argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
			});
			if (cmd.registeredArguments.find((argument) => argument.description)) return cmd.registeredArguments;
			return [];
		}
		/**
		* Get the command term to show in the list of subcommands.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		subcommandTerm(cmd) {
			const args = cmd.registeredArguments.map((arg) => humanReadableArgName$1(arg)).join(" ");
			return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
		}
		/**
		* Get the option term to show in the list of options.
		*
		* @param {Option} option
		* @returns {string}
		*/
		optionTerm(option) {
			return option.flags;
		}
		/**
		* Get the argument term to show in the list of arguments.
		*
		* @param {Argument} argument
		* @returns {string}
		*/
		argumentTerm(argument) {
			return argument.name();
		}
		/**
		* Get the longest command term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestSubcommandTermLength(cmd, helper) {
			return helper.visibleCommands(cmd).reduce((max, command) => {
				return Math.max(max, this.displayWidth(helper.styleSubcommandTerm(helper.subcommandTerm(command))));
			}, 0);
		}
		/**
		* Get the longest option term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestOptionTermLength(cmd, helper) {
			return helper.visibleOptions(cmd).reduce((max, option) => {
				return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
			}, 0);
		}
		/**
		* Get the longest global option term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestGlobalOptionTermLength(cmd, helper) {
			return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
				return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
			}, 0);
		}
		/**
		* Get the longest argument term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		longestArgumentTermLength(cmd, helper) {
			return helper.visibleArguments(cmd).reduce((max, argument) => {
				return Math.max(max, this.displayWidth(helper.styleArgumentTerm(helper.argumentTerm(argument))));
			}, 0);
		}
		/**
		* Get the command usage to be displayed at the top of the built-in help.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		commandUsage(cmd) {
			let cmdName = cmd._name;
			if (cmd._aliases[0]) cmdName = cmdName + "|" + cmd._aliases[0];
			let ancestorCmdNames = "";
			for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
			return ancestorCmdNames + cmdName + " " + cmd.usage();
		}
		/**
		* Get the description for the command.
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		commandDescription(cmd) {
			return cmd.description();
		}
		/**
		* Get the subcommand summary to show in the list of subcommands.
		* (Fallback to description for backwards compatibility.)
		*
		* @param {Command} cmd
		* @returns {string}
		*/
		subcommandDescription(cmd) {
			return cmd.summary() || cmd.description();
		}
		/**
		* Get the option description to show in the list of options.
		*
		* @param {Option} option
		* @return {string}
		*/
		optionDescription(option) {
			const extraInfo = [];
			if (option.argChoices) extraInfo.push(
				// use stringify to match the display of the default value
				`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
);
			if (option.defaultValue !== undefined) {
				const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
				if (showDefault) extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
			}
			if (option.presetArg !== undefined && option.optional) extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
			if (option.envVar !== undefined) extraInfo.push(`env: ${option.envVar}`);
			if (extraInfo.length > 0) return `${option.description} (${extraInfo.join(", ")})`;
			return option.description;
		}
		/**
		* Get the argument description to show in the list of arguments.
		*
		* @param {Argument} argument
		* @return {string}
		*/
		argumentDescription(argument) {
			const extraInfo = [];
			if (argument.argChoices) extraInfo.push(
				// use stringify to match the display of the default value
				`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
);
			if (argument.defaultValue !== undefined) extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
			if (extraInfo.length > 0) {
				const extraDescription = `(${extraInfo.join(", ")})`;
				if (argument.description) return `${argument.description} ${extraDescription}`;
				return extraDescription;
			}
			return argument.description;
		}
		/**
		* Generate the built-in help text.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {string}
		*/
		formatHelp(cmd, helper) {
			const termWidth = helper.padWidth(cmd, helper);
			const helpWidth = helper.helpWidth ?? 80;
			function callFormatItem(term, description) {
				return helper.formatItem(term, termWidth, description, helper);
			}
			let output = [`${helper.styleTitle("Usage:")} ${helper.styleUsage(helper.commandUsage(cmd))}`, ""];
			const commandDescription = helper.commandDescription(cmd);
			if (commandDescription.length > 0) output = output.concat([helper.boxWrap(helper.styleCommandDescription(commandDescription), helpWidth), ""]);
			const argumentList = helper.visibleArguments(cmd).map((argument) => {
				return callFormatItem(helper.styleArgumentTerm(helper.argumentTerm(argument)), helper.styleArgumentDescription(helper.argumentDescription(argument)));
			});
			if (argumentList.length > 0) output = output.concat([
				helper.styleTitle("Arguments:"),
				...argumentList,
				""
			]);
			const optionList = helper.visibleOptions(cmd).map((option) => {
				return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
			});
			if (optionList.length > 0) output = output.concat([
				helper.styleTitle("Options:"),
				...optionList,
				""
			]);
			if (helper.showGlobalOptions) {
				const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
					return callFormatItem(helper.styleOptionTerm(helper.optionTerm(option)), helper.styleOptionDescription(helper.optionDescription(option)));
				});
				if (globalOptionList.length > 0) output = output.concat([
					helper.styleTitle("Global Options:"),
					...globalOptionList,
					""
				]);
			}
			const commandList = helper.visibleCommands(cmd).map((cmd$1) => {
				return callFormatItem(helper.styleSubcommandTerm(helper.subcommandTerm(cmd$1)), helper.styleSubcommandDescription(helper.subcommandDescription(cmd$1)));
			});
			if (commandList.length > 0) output = output.concat([
				helper.styleTitle("Commands:"),
				...commandList,
				""
			]);
			return output.join("\n");
		}
		/**
		* Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.
		*
		* @param {string} str
		* @returns {number}
		*/
		displayWidth(str) {
			return stripColor$1(str).length;
		}
		/**
		* Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.
		*
		* @param {string} str
		* @returns {string}
		*/
		styleTitle(str) {
			return str;
		}
		styleUsage(str) {
			return str.split(" ").map((word) => {
				if (word === "[options]") return this.styleOptionText(word);
				if (word === "[command]") return this.styleSubcommandText(word);
				if (word[0] === "[" || word[0] === "<") return this.styleArgumentText(word);
				return this.styleCommandText(word);
			}).join(" ");
		}
		styleCommandDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleOptionDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleSubcommandDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleArgumentDescription(str) {
			return this.styleDescriptionText(str);
		}
		styleDescriptionText(str) {
			return str;
		}
		styleOptionTerm(str) {
			return this.styleOptionText(str);
		}
		styleSubcommandTerm(str) {
			return str.split(" ").map((word) => {
				if (word === "[options]") return this.styleOptionText(word);
				if (word[0] === "[" || word[0] === "<") return this.styleArgumentText(word);
				return this.styleSubcommandText(word);
			}).join(" ");
		}
		styleArgumentTerm(str) {
			return this.styleArgumentText(str);
		}
		styleOptionText(str) {
			return str;
		}
		styleArgumentText(str) {
			return str;
		}
		styleSubcommandText(str) {
			return str;
		}
		styleCommandText(str) {
			return str;
		}
		/**
		* Calculate the pad width from the maximum term length.
		*
		* @param {Command} cmd
		* @param {Help} helper
		* @returns {number}
		*/
		padWidth(cmd, helper) {
			return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
		}
		/**
		* Detect manually wrapped and indented strings by checking for line break followed by whitespace.
		*
		* @param {string} str
		* @returns {boolean}
		*/
		preformatted(str) {
			return /\n[^\S\r\n]/.test(str);
		}
		/**
		* Format the "item", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.
		*
		* So "TTT", 5, "DDD DDDD DD DDD" might be formatted for this.helpWidth=17 like so:
		*   TTT  DDD DDDD
		*        DD DDD
		*
		* @param {string} term
		* @param {number} termWidth
		* @param {string} description
		* @param {Help} helper
		* @returns {string}
		*/
		formatItem(term, termWidth, description, helper) {
			const itemIndent = 2;
			const itemIndentStr = " ".repeat(itemIndent);
			if (!description) return itemIndentStr + term;
			const paddedTerm = term.padEnd(termWidth + term.length - helper.displayWidth(term));
			const spacerWidth = 2;
			const helpWidth = this.helpWidth ?? 80;
			const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
			let formattedDescription;
			if (remainingWidth < this.minWidthToWrap || helper.preformatted(description)) formattedDescription = description;
else {
				const wrappedDescription = helper.boxWrap(description, remainingWidth);
				formattedDescription = wrappedDescription.replace(/\n/g, "\n" + " ".repeat(termWidth + spacerWidth));
			}
			return itemIndentStr + paddedTerm + " ".repeat(spacerWidth) + formattedDescription.replace(/\n/g, `\n${itemIndentStr}`);
		}
		/**
		* Wrap a string at whitespace, preserving existing line breaks.
		* Wrapping is skipped if the width is less than `minWidthToWrap`.
		*
		* @param {string} str
		* @param {number} width
		* @returns {string}
		*/
		boxWrap(str, width) {
			if (width < this.minWidthToWrap) return str;
			const rawLines = str.split(/\r\n|\n/);
			const chunkPattern = /[\s]*[^\s]+/g;
			const wrappedLines = [];
			rawLines.forEach((line) => {
				const chunks = line.match(chunkPattern);
				if (chunks === null) {
					wrappedLines.push("");
					return;
				}
				let sumChunks = [chunks.shift()];
				let sumWidth = this.displayWidth(sumChunks[0]);
				chunks.forEach((chunk) => {
					const visibleWidth = this.displayWidth(chunk);
					if (sumWidth + visibleWidth <= width) {
						sumChunks.push(chunk);
						sumWidth += visibleWidth;
						return;
					}
					wrappedLines.push(sumChunks.join(""));
					const nextChunk = chunk.trimStart();
					sumChunks = [nextChunk];
					sumWidth = this.displayWidth(nextChunk);
				});
				wrappedLines.push(sumChunks.join(""));
			});
			return wrappedLines.join("\n");
		}
	};
	/**
	* Strip style ANSI escape sequences from the string. In particular, SGR (Select Graphic Rendition) codes.
	*
	* @param {string} str
	* @returns {string}
	* @package
	*/
	function stripColor$1(str) {
		const sgrPattern = /\x1b\[\d*(;\d*)*m/g;
		return str.replace(sgrPattern, "");
	}
	exports.Help = Help$3;
	exports.stripColor = stripColor$1;
} });

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/option.js
var require_option = __commonJS$3({ "node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/option.js"(exports) {
	const { InvalidArgumentError: InvalidArgumentError$2 } = require_error();
	var Option$3 = class {
		/**
		* Initialize a new `Option` with the given `flags` and `description`.
		*
		* @param {string} flags
		* @param {string} [description]
		*/
		constructor(flags, description) {
			this.flags = flags;
			this.description = description || "";
			this.required = flags.includes("<");
			this.optional = flags.includes("[");
			this.variadic = /\w\.\.\.[>\]]$/.test(flags);
			this.mandatory = false;
			const optionFlags = splitOptionFlags(flags);
			this.short = optionFlags.shortFlag;
			this.long = optionFlags.longFlag;
			this.negate = false;
			if (this.long) this.negate = this.long.startsWith("--no-");
			this.defaultValue = undefined;
			this.defaultValueDescription = undefined;
			this.presetArg = undefined;
			this.envVar = undefined;
			this.parseArg = undefined;
			this.hidden = false;
			this.argChoices = undefined;
			this.conflictsWith = [];
			this.implied = undefined;
		}
		/**
		* Set the default value, and optionally supply the description to be displayed in the help.
		*
		* @param {*} value
		* @param {string} [description]
		* @return {Option}
		*/
		default(value, description) {
			this.defaultValue = value;
			this.defaultValueDescription = description;
			return this;
		}
		/**
		* Preset to use when option used without option-argument, especially optional but also boolean and negated.
		* The custom processing (parseArg) is called.
		*
		* @example
		* new Option('--color').default('GREYSCALE').preset('RGB');
		* new Option('--donate [amount]').preset('20').argParser(parseFloat);
		*
		* @param {*} arg
		* @return {Option}
		*/
		preset(arg) {
			this.presetArg = arg;
			return this;
		}
		/**
		* Add option name(s) that conflict with this option.
		* An error will be displayed if conflicting options are found during parsing.
		*
		* @example
		* new Option('--rgb').conflicts('cmyk');
		* new Option('--js').conflicts(['ts', 'jsx']);
		*
		* @param {(string | string[])} names
		* @return {Option}
		*/
		conflicts(names) {
			this.conflictsWith = this.conflictsWith.concat(names);
			return this;
		}
		/**
		* Specify implied option values for when this option is set and the implied options are not.
		*
		* The custom processing (parseArg) is not called on the implied values.
		*
		* @example
		* program
		*   .addOption(new Option('--log', 'write logging information to file'))
		*   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
		*
		* @param {object} impliedOptionValues
		* @return {Option}
		*/
		implies(impliedOptionValues) {
			let newImplied = impliedOptionValues;
			if (typeof impliedOptionValues === "string") newImplied = { [impliedOptionValues]: true };
			this.implied = Object.assign(this.implied || {}, newImplied);
			return this;
		}
		/**
		* Set environment variable to check for option value.
		*
		* An environment variable is only used if when processed the current option value is
		* undefined, or the source of the current value is 'default' or 'config' or 'env'.
		*
		* @param {string} name
		* @return {Option}
		*/
		env(name) {
			this.envVar = name;
			return this;
		}
		/**
		* Set the custom handler for processing CLI option arguments into option values.
		*
		* @param {Function} [fn]
		* @return {Option}
		*/
		argParser(fn) {
			this.parseArg = fn;
			return this;
		}
		/**
		* Whether the option is mandatory and must have a value after parsing.
		*
		* @param {boolean} [mandatory=true]
		* @return {Option}
		*/
		makeOptionMandatory(mandatory = true) {
			this.mandatory = !!mandatory;
			return this;
		}
		/**
		* Hide option in help.
		*
		* @param {boolean} [hide=true]
		* @return {Option}
		*/
		hideHelp(hide = true) {
			this.hidden = !!hide;
			return this;
		}
		/**
		* @package
		*/
		_concatValue(value, previous) {
			if (previous === this.defaultValue || !Array.isArray(previous)) return [value];
			return previous.concat(value);
		}
		/**
		* Only allow option value to be one of choices.
		*
		* @param {string[]} values
		* @return {Option}
		*/
		choices(values) {
			this.argChoices = values.slice();
			this.parseArg = (arg, previous) => {
				if (!this.argChoices.includes(arg)) throw new InvalidArgumentError$2(`Allowed choices are ${this.argChoices.join(", ")}.`);
				if (this.variadic) return this._concatValue(arg, previous);
				return arg;
			};
			return this;
		}
		/**
		* Return option name.
		*
		* @return {string}
		*/
		name() {
			if (this.long) return this.long.replace(/^--/, "");
			return this.short.replace(/^-/, "");
		}
		/**
		* Return option name, in a camelcase format that can be used
		* as an object attribute key.
		*
		* @return {string}
		*/
		attributeName() {
			if (this.negate) return camelcase(this.name().replace(/^no-/, ""));
			return camelcase(this.name());
		}
		/**
		* Check if `arg` matches the short or long flag.
		*
		* @param {string} arg
		* @return {boolean}
		* @package
		*/
		is(arg) {
			return this.short === arg || this.long === arg;
		}
		/**
		* Return whether a boolean option.
		*
		* Options are one of boolean, negated, required argument, or optional argument.
		*
		* @return {boolean}
		* @package
		*/
		isBoolean() {
			return !this.required && !this.optional && !this.negate;
		}
	};
	var DualOptions$1 = class {
		/**
		* @param {Option[]} options
		*/
		constructor(options) {
			this.positiveOptions = new Map();
			this.negativeOptions = new Map();
			this.dualOptions = new Set();
			options.forEach((option) => {
				if (option.negate) this.negativeOptions.set(option.attributeName(), option);
else this.positiveOptions.set(option.attributeName(), option);
			});
			this.negativeOptions.forEach((value, key) => {
				if (this.positiveOptions.has(key)) this.dualOptions.add(key);
			});
		}
		/**
		* Did the value come from the option, and not from possible matching dual option?
		*
		* @param {*} value
		* @param {Option} option
		* @returns {boolean}
		*/
		valueFromOption(value, option) {
			const optionKey = option.attributeName();
			if (!this.dualOptions.has(optionKey)) return true;
			const preset = this.negativeOptions.get(optionKey).presetArg;
			const negativeValue = preset !== undefined ? preset : false;
			return option.negate === (negativeValue === value);
		}
	};
	/**
	* Convert string from kebab-case to camelCase.
	*
	* @param {string} str
	* @return {string}
	* @private
	*/
	function camelcase(str) {
		return str.split("-").reduce((str$1, word) => {
			return str$1 + word[0].toUpperCase() + word.slice(1);
		});
	}
	/**
	* Split the short and long flag out of something like '-m,--mixed <value>'
	*
	* @private
	*/
	function splitOptionFlags(flags) {
		let shortFlag;
		let longFlag;
		const shortFlagExp = /^-[^-]$/;
		const longFlagExp = /^--[^-]/;
		const flagParts = flags.split(/[ |,]+/).concat("guard");
		if (shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
		if (longFlagExp.test(flagParts[0])) longFlag = flagParts.shift();
		if (!shortFlag && shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
		if (!shortFlag && longFlagExp.test(flagParts[0])) {
			shortFlag = longFlag;
			longFlag = flagParts.shift();
		}
		if (flagParts[0].startsWith("-")) {
			const unsupportedFlag = flagParts[0];
			const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
			if (/^-[^-][^-]/.test(unsupportedFlag)) throw new Error(`${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);
			if (shortFlagExp.test(unsupportedFlag)) throw new Error(`${baseError}
- too many short flags`);
			if (longFlagExp.test(unsupportedFlag)) throw new Error(`${baseError}
- too many long flags`);
			throw new Error(`${baseError}
- unrecognised flag format`);
		}
		if (shortFlag === undefined && longFlag === undefined) throw new Error(`option creation failed due to no flags found in '${flags}'.`);
		return {
			shortFlag,
			longFlag
		};
	}
	exports.Option = Option$3;
	exports.DualOptions = DualOptions$1;
} });

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS$3({ "node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/suggestSimilar.js"(exports) {
	const maxDistance = 3;
	function editDistance(a, b) {
		if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);
		const d = [];
		for (let i$1 = 0; i$1 <= a.length; i$1++) d[i$1] = [i$1];
		for (let j = 0; j <= b.length; j++) d[0][j] = j;
		for (let j = 1; j <= b.length; j++) for (let i$1 = 1; i$1 <= a.length; i$1++) {
			let cost = 1;
			if (a[i$1 - 1] === b[j - 1]) cost = 0;
else cost = 1;
			d[i$1][j] = Math.min(d[i$1 - 1][j] + 1, d[i$1][j - 1] + 1, d[i$1 - 1][j - 1] + cost);
			if (i$1 > 1 && j > 1 && a[i$1 - 1] === b[j - 2] && a[i$1 - 2] === b[j - 1]) d[i$1][j] = Math.min(d[i$1][j], d[i$1 - 2][j - 2] + 1);
		}
		return d[a.length][b.length];
	}
	/**
	* Find close matches, restricted to same number of edits.
	*
	* @param {string} word
	* @param {string[]} candidates
	* @returns {string}
	*/
	function suggestSimilar$1(word, candidates) {
		if (!candidates || candidates.length === 0) return "";
		candidates = Array.from(new Set(candidates));
		const searchingOptions = word.startsWith("--");
		if (searchingOptions) {
			word = word.slice(2);
			candidates = candidates.map((candidate) => candidate.slice(2));
		}
		let similar = [];
		let bestDistance = maxDistance;
		const minSimilarity = .4;
		candidates.forEach((candidate) => {
			if (candidate.length <= 1) return;
			const distance = editDistance(word, candidate);
			const length = Math.max(word.length, candidate.length);
			const similarity = (length - distance) / length;
			if (similarity > minSimilarity) {
				if (distance < bestDistance) {
					bestDistance = distance;
					similar = [candidate];
				} else if (distance === bestDistance) similar.push(candidate);
			}
		});
		similar.sort((a, b) => a.localeCompare(b));
		if (searchingOptions) similar = similar.map((candidate) => `--${candidate}`);
		if (similar.length > 1) return `\n(Did you mean one of ${similar.join(", ")}?)`;
		if (similar.length === 1) return `\n(Did you mean ${similar[0]}?)`;
		return "";
	}
	exports.suggestSimilar = suggestSimilar$1;
} });

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/command.js
var require_command = __commonJS$3({ "node_modules/.pnpm/commander@13.1.0/node_modules/commander/lib/command.js"(exports) {
	const EventEmitter = __require$1("node:events").EventEmitter;
	const childProcess = __require$1("node:child_process");
	const path$1 = __require$1("node:path");
	const fs$1 = __require$1("node:fs");
	const process$2 = __require$1("node:process");
	const { Argument: Argument$2, humanReadableArgName } = require_argument();
	const { CommanderError: CommanderError$2 } = require_error();
	const { Help: Help$2, stripColor } = require_help();
	const { Option: Option$2, DualOptions } = require_option();
	const { suggestSimilar } = require_suggestSimilar();
	var Command$2 = class Command$2 extends EventEmitter {
		/**
		* Initialize a new `Command`.
		*
		* @param {string} [name]
		*/
		constructor(name) {
			super();
			/** @type {Command[]} */
			this.commands = [];
			/** @type {Option[]} */
			this.options = [];
			this.parent = null;
			this._allowUnknownOption = false;
			this._allowExcessArguments = false;
			/** @type {Argument[]} */
			this.registeredArguments = [];
			this._args = this.registeredArguments;
			/** @type {string[]} */
			this.args = [];
			this.rawArgs = [];
			this.processedArgs = [];
			this._scriptPath = null;
			this._name = name || "";
			this._optionValues = {};
			this._optionValueSources = {};
			this._storeOptionsAsProperties = false;
			this._actionHandler = null;
			this._executableHandler = false;
			this._executableFile = null;
			this._executableDir = null;
			this._defaultCommandName = null;
			this._exitCallback = null;
			this._aliases = [];
			this._combineFlagAndOptionalValue = true;
			this._description = "";
			this._summary = "";
			this._argsDescription = undefined;
			this._enablePositionalOptions = false;
			this._passThroughOptions = false;
			this._lifeCycleHooks = {};
			/** @type {(boolean | string)} */
			this._showHelpAfterError = false;
			this._showSuggestionAfterError = true;
			this._savedState = null;
			this._outputConfiguration = {
				writeOut: (str) => process$2.stdout.write(str),
				writeErr: (str) => process$2.stderr.write(str),
				outputError: (str, write) => write(str),
				getOutHelpWidth: () => process$2.stdout.isTTY ? process$2.stdout.columns : undefined,
				getErrHelpWidth: () => process$2.stderr.isTTY ? process$2.stderr.columns : undefined,
				getOutHasColors: () => useColor() ?? (process$2.stdout.isTTY && process$2.stdout.hasColors?.()),
				getErrHasColors: () => useColor() ?? (process$2.stderr.isTTY && process$2.stderr.hasColors?.()),
				stripColor: (str) => stripColor(str)
			};
			this._hidden = false;
			/** @type {(Option | null | undefined)} */
			this._helpOption = undefined;
			this._addImplicitHelpCommand = undefined;
			/** @type {Command} */
			this._helpCommand = undefined;
			this._helpConfiguration = {};
		}
		/**
		* Copy settings that are useful to have in common across root command and subcommands.
		*
		* (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
		*
		* @param {Command} sourceCommand
		* @return {Command} `this` command for chaining
		*/
		copyInheritedSettings(sourceCommand) {
			this._outputConfiguration = sourceCommand._outputConfiguration;
			this._helpOption = sourceCommand._helpOption;
			this._helpCommand = sourceCommand._helpCommand;
			this._helpConfiguration = sourceCommand._helpConfiguration;
			this._exitCallback = sourceCommand._exitCallback;
			this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
			this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
			this._allowExcessArguments = sourceCommand._allowExcessArguments;
			this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
			this._showHelpAfterError = sourceCommand._showHelpAfterError;
			this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
			return this;
		}
		/**
		* @returns {Command[]}
		* @private
		*/
		_getCommandAndAncestors() {
			const result = [];
			for (let command = this; command; command = command.parent) result.push(command);
			return result;
		}
		/**
		* Define a command.
		*
		* There are two styles of command: pay attention to where to put the description.
		*
		* @example
		* // Command implemented using action handler (description is supplied separately to `.command`)
		* program
		*   .command('clone <source> [destination]')
		*   .description('clone a repository into a newly created directory')
		*   .action((source, destination) => {
		*     console.log('clone command called');
		*   });
		*
		* // Command implemented using separate executable file (description is second parameter to `.command`)
		* program
		*   .command('start <service>', 'start named service')
		*   .command('stop [service]', 'stop named service, or all if no name supplied');
		*
		* @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
		* @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
		* @param {object} [execOpts] - configuration options (for executable)
		* @return {Command} returns new command for action handler, or `this` for executable command
		*/
		command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
			let desc = actionOptsOrExecDesc;
			let opts = execOpts;
			if (typeof desc === "object" && desc !== null) {
				opts = desc;
				desc = null;
			}
			opts = opts || {};
			const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
			const cmd = this.createCommand(name);
			if (desc) {
				cmd.description(desc);
				cmd._executableHandler = true;
			}
			if (opts.isDefault) this._defaultCommandName = cmd._name;
			cmd._hidden = !!(opts.noHelp || opts.hidden);
			cmd._executableFile = opts.executableFile || null;
			if (args) cmd.arguments(args);
			this._registerCommand(cmd);
			cmd.parent = this;
			cmd.copyInheritedSettings(this);
			if (desc) return this;
			return cmd;
		}
		/**
		* Factory routine to create a new unattached command.
		*
		* See .command() for creating an attached subcommand, which uses this routine to
		* create the command. You can override createCommand to customise subcommands.
		*
		* @param {string} [name]
		* @return {Command} new command
		*/
		createCommand(name) {
			return new Command$2(name);
		}
		/**
		* You can customise the help with a subclass of Help by overriding createHelp,
		* or by overriding Help properties using configureHelp().
		*
		* @return {Help}
		*/
		createHelp() {
			return Object.assign(new Help$2(), this.configureHelp());
		}
		/**
		* You can customise the help by overriding Help properties using configureHelp(),
		* or with a subclass of Help by overriding createHelp().
		*
		* @param {object} [configuration] - configuration options
		* @return {(Command | object)} `this` command for chaining, or stored configuration
		*/
		configureHelp(configuration) {
			if (configuration === undefined) return this._helpConfiguration;
			this._helpConfiguration = configuration;
			return this;
		}
		/**
		* The default output goes to stdout and stderr. You can customise this for special
		* applications. You can also customise the display of errors by overriding outputError.
		*
		* The configuration properties are all functions:
		*
		*     // change how output being written, defaults to stdout and stderr
		*     writeOut(str)
		*     writeErr(str)
		*     // change how output being written for errors, defaults to writeErr
		*     outputError(str, write) // used for displaying errors and not used for displaying help
		*     // specify width for wrapping help
		*     getOutHelpWidth()
		*     getErrHelpWidth()
		*     // color support, currently only used with Help
		*     getOutHasColors()
		*     getErrHasColors()
		*     stripColor() // used to remove ANSI escape codes if output does not have colors
		*
		* @param {object} [configuration] - configuration options
		* @return {(Command | object)} `this` command for chaining, or stored configuration
		*/
		configureOutput(configuration) {
			if (configuration === undefined) return this._outputConfiguration;
			Object.assign(this._outputConfiguration, configuration);
			return this;
		}
		/**
		* Display the help or a custom message after an error occurs.
		*
		* @param {(boolean|string)} [displayHelp]
		* @return {Command} `this` command for chaining
		*/
		showHelpAfterError(displayHelp = true) {
			if (typeof displayHelp !== "string") displayHelp = !!displayHelp;
			this._showHelpAfterError = displayHelp;
			return this;
		}
		/**
		* Display suggestion of similar commands for unknown commands, or options for unknown options.
		*
		* @param {boolean} [displaySuggestion]
		* @return {Command} `this` command for chaining
		*/
		showSuggestionAfterError(displaySuggestion = true) {
			this._showSuggestionAfterError = !!displaySuggestion;
			return this;
		}
		/**
		* Add a prepared subcommand.
		*
		* See .command() for creating an attached subcommand which inherits settings from its parent.
		*
		* @param {Command} cmd - new subcommand
		* @param {object} [opts] - configuration options
		* @return {Command} `this` command for chaining
		*/
		addCommand(cmd, opts) {
			if (!cmd._name) throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
			opts = opts || {};
			if (opts.isDefault) this._defaultCommandName = cmd._name;
			if (opts.noHelp || opts.hidden) cmd._hidden = true;
			this._registerCommand(cmd);
			cmd.parent = this;
			cmd._checkForBrokenPassThrough();
			return this;
		}
		/**
		* Factory routine to create a new unattached argument.
		*
		* See .argument() for creating an attached argument, which uses this routine to
		* create the argument. You can override createArgument to return a custom argument.
		*
		* @param {string} name
		* @param {string} [description]
		* @return {Argument} new argument
		*/
		createArgument(name, description) {
			return new Argument$2(name, description);
		}
		/**
		* Define argument syntax for command.
		*
		* The default is that the argument is required, and you can explicitly
		* indicate this with <> around the name. Put [] around the name for an optional argument.
		*
		* @example
		* program.argument('<input-file>');
		* program.argument('[output-file]');
		*
		* @param {string} name
		* @param {string} [description]
		* @param {(Function|*)} [fn] - custom argument processing function
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		argument(name, description, fn, defaultValue) {
			const argument = this.createArgument(name, description);
			if (typeof fn === "function") argument.default(defaultValue).argParser(fn);
else argument.default(fn);
			this.addArgument(argument);
			return this;
		}
		/**
		* Define argument syntax for command, adding multiple at once (without descriptions).
		*
		* See also .argument().
		*
		* @example
		* program.arguments('<cmd> [env]');
		*
		* @param {string} names
		* @return {Command} `this` command for chaining
		*/
		arguments(names) {
			names.trim().split(/ +/).forEach((detail) => {
				this.argument(detail);
			});
			return this;
		}
		/**
		* Define argument syntax for command, adding a prepared argument.
		*
		* @param {Argument} argument
		* @return {Command} `this` command for chaining
		*/
		addArgument(argument) {
			const previousArgument = this.registeredArguments.slice(-1)[0];
			if (previousArgument && previousArgument.variadic) throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
			if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
			this.registeredArguments.push(argument);
			return this;
		}
		/**
		* Customise or override default help command. By default a help command is automatically added if your command has subcommands.
		*
		* @example
		*    program.helpCommand('help [cmd]');
		*    program.helpCommand('help [cmd]', 'show help');
		*    program.helpCommand(false); // suppress default help command
		*    program.helpCommand(true); // add help command even if no subcommands
		*
		* @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
		* @param {string} [description] - custom description
		* @return {Command} `this` command for chaining
		*/
		helpCommand(enableOrNameAndArgs, description) {
			if (typeof enableOrNameAndArgs === "boolean") {
				this._addImplicitHelpCommand = enableOrNameAndArgs;
				return this;
			}
			enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
			const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
			const helpDescription = description ?? "display help for command";
			const helpCommand = this.createCommand(helpName);
			helpCommand.helpOption(false);
			if (helpArgs) helpCommand.arguments(helpArgs);
			if (helpDescription) helpCommand.description(helpDescription);
			this._addImplicitHelpCommand = true;
			this._helpCommand = helpCommand;
			return this;
		}
		/**
		* Add prepared custom help command.
		*
		* @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
		* @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
		* @return {Command} `this` command for chaining
		*/
		addHelpCommand(helpCommand, deprecatedDescription) {
			if (typeof helpCommand !== "object") {
				this.helpCommand(helpCommand, deprecatedDescription);
				return this;
			}
			this._addImplicitHelpCommand = true;
			this._helpCommand = helpCommand;
			return this;
		}
		/**
		* Lazy create help command.
		*
		* @return {(Command|null)}
		* @package
		*/
		_getHelpCommand() {
			const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
			if (hasImplicitHelpCommand) {
				if (this._helpCommand === undefined) this.helpCommand(undefined, undefined);
				return this._helpCommand;
			}
			return null;
		}
		/**
		* Add hook for life cycle event.
		*
		* @param {string} event
		* @param {Function} listener
		* @return {Command} `this` command for chaining
		*/
		hook(event, listener) {
			const allowedValues = [
				"preSubcommand",
				"preAction",
				"postAction"
			];
			if (!allowedValues.includes(event)) throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
			if (this._lifeCycleHooks[event]) this._lifeCycleHooks[event].push(listener);
else this._lifeCycleHooks[event] = [listener];
			return this;
		}
		/**
		* Register callback to use as replacement for calling process.exit.
		*
		* @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
		* @return {Command} `this` command for chaining
		*/
		exitOverride(fn) {
			if (fn) this._exitCallback = fn;
else this._exitCallback = (err) => {
				if (err.code !== "commander.executeSubCommandAsync") throw err;
else {}
			};
			return this;
		}
		/**
		* Call process.exit, and _exitCallback if defined.
		*
		* @param {number} exitCode exit code for using with process.exit
		* @param {string} code an id string representing the error
		* @param {string} message human-readable description of the error
		* @return never
		* @private
		*/
		_exit(exitCode, code, message) {
			if (this._exitCallback) this._exitCallback(new CommanderError$2(exitCode, code, message));
			process$2.exit(exitCode);
		}
		/**
		* Register callback `fn` for the command.
		*
		* @example
		* program
		*   .command('serve')
		*   .description('start service')
		*   .action(function() {
		*      // do work here
		*   });
		*
		* @param {Function} fn
		* @return {Command} `this` command for chaining
		*/
		action(fn) {
			const listener = (args) => {
				const expectedArgsCount = this.registeredArguments.length;
				const actionArgs = args.slice(0, expectedArgsCount);
				if (this._storeOptionsAsProperties) actionArgs[expectedArgsCount] = this;
else actionArgs[expectedArgsCount] = this.opts();
				actionArgs.push(this);
				return fn.apply(this, actionArgs);
			};
			this._actionHandler = listener;
			return this;
		}
		/**
		* Factory routine to create a new unattached option.
		*
		* See .option() for creating an attached option, which uses this routine to
		* create the option. You can override createOption to return a custom option.
		*
		* @param {string} flags
		* @param {string} [description]
		* @return {Option} new option
		*/
		createOption(flags, description) {
			return new Option$2(flags, description);
		}
		/**
		* Wrap parseArgs to catch 'commander.invalidArgument'.
		*
		* @param {(Option | Argument)} target
		* @param {string} value
		* @param {*} previous
		* @param {string} invalidArgumentMessage
		* @private
		*/
		_callParseArg(target, value, previous, invalidArgumentMessage) {
			try {
				return target.parseArg(value, previous);
			} catch (err) {
				if (err.code === "commander.invalidArgument") {
					const message = `${invalidArgumentMessage} ${err.message}`;
					this.error(message, {
						exitCode: err.exitCode,
						code: err.code
					});
				}
				throw err;
			}
		}
		/**
		* Check for option flag conflicts.
		* Register option if no conflicts found, or throw on conflict.
		*
		* @param {Option} option
		* @private
		*/
		_registerOption(option) {
			const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
			if (matchingOption) {
				const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
				throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
			}
			this.options.push(option);
		}
		/**
		* Check for command name and alias conflicts with existing commands.
		* Register command if no conflicts found, or throw on conflict.
		*
		* @param {Command} command
		* @private
		*/
		_registerCommand(command) {
			const knownBy = (cmd) => {
				return [cmd.name()].concat(cmd.aliases());
			};
			const alreadyUsed = knownBy(command).find((name) => this._findCommand(name));
			if (alreadyUsed) {
				const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
				const newCmd = knownBy(command).join("|");
				throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
			}
			this.commands.push(command);
		}
		/**
		* Add an option.
		*
		* @param {Option} option
		* @return {Command} `this` command for chaining
		*/
		addOption(option) {
			this._registerOption(option);
			const oname = option.name();
			const name = option.attributeName();
			if (option.negate) {
				const positiveLongFlag = option.long.replace(/^--no-/, "--");
				if (!this._findOption(positiveLongFlag)) this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, "default");
			} else if (option.defaultValue !== undefined) this.setOptionValueWithSource(name, option.defaultValue, "default");
			const handleOptionValue = (val, invalidValueMessage, valueSource) => {
				if (val == null && option.presetArg !== undefined) val = option.presetArg;
				const oldValue = this.getOptionValue(name);
				if (val !== null && option.parseArg) val = this._callParseArg(option, val, oldValue, invalidValueMessage);
else if (val !== null && option.variadic) val = option._concatValue(val, oldValue);
				if (val == null) if (option.negate) val = false;
else if (option.isBoolean() || option.optional) val = true;
else val = "";
				this.setOptionValueWithSource(name, val, valueSource);
			};
			this.on("option:" + oname, (val) => {
				const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
				handleOptionValue(val, invalidValueMessage, "cli");
			});
			if (option.envVar) this.on("optionEnv:" + oname, (val) => {
				const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
				handleOptionValue(val, invalidValueMessage, "env");
			});
			return this;
		}
		/**
		* Internal implementation shared by .option() and .requiredOption()
		*
		* @return {Command} `this` command for chaining
		* @private
		*/
		_optionEx(config, flags, description, fn, defaultValue) {
			if (typeof flags === "object" && flags instanceof Option$2) throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
			const option = this.createOption(flags, description);
			option.makeOptionMandatory(!!config.mandatory);
			if (typeof fn === "function") option.default(defaultValue).argParser(fn);
else if (fn instanceof RegExp) {
				const regex$1 = fn;
				fn = (val, def) => {
					const m = regex$1.exec(val);
					return m ? m[0] : def;
				};
				option.default(defaultValue).argParser(fn);
			} else option.default(fn);
			return this.addOption(option);
		}
		/**
		* Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
		*
		* The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
		* option-argument is indicated by `<>` and an optional option-argument by `[]`.
		*
		* See the README for more details, and see also addOption() and requiredOption().
		*
		* @example
		* program
		*     .option('-p, --pepper', 'add pepper')
		*     .option('--pt, --pizza-type <TYPE>', 'type of pizza') // required option-argument
		*     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
		*     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
		*
		* @param {string} flags
		* @param {string} [description]
		* @param {(Function|*)} [parseArg] - custom option processing function or default value
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		option(flags, description, parseArg, defaultValue) {
			return this._optionEx({}, flags, description, parseArg, defaultValue);
		}
		/**
		* Add a required option which must have a value after parsing. This usually means
		* the option must be specified on the command line. (Otherwise the same as .option().)
		*
		* The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
		*
		* @param {string} flags
		* @param {string} [description]
		* @param {(Function|*)} [parseArg] - custom option processing function or default value
		* @param {*} [defaultValue]
		* @return {Command} `this` command for chaining
		*/
		requiredOption(flags, description, parseArg, defaultValue) {
			return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
		}
		/**
		* Alter parsing of short flags with optional values.
		*
		* @example
		* // for `.option('-f,--flag [value]'):
		* program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
		* program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
		*
		* @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
		* @return {Command} `this` command for chaining
		*/
		combineFlagAndOptionalValue(combine = true) {
			this._combineFlagAndOptionalValue = !!combine;
			return this;
		}
		/**
		* Allow unknown options on the command line.
		*
		* @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
		* @return {Command} `this` command for chaining
		*/
		allowUnknownOption(allowUnknown = true) {
			this._allowUnknownOption = !!allowUnknown;
			return this;
		}
		/**
		* Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
		*
		* @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
		* @return {Command} `this` command for chaining
		*/
		allowExcessArguments(allowExcess = true) {
			this._allowExcessArguments = !!allowExcess;
			return this;
		}
		/**
		* Enable positional options. Positional means global options are specified before subcommands which lets
		* subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
		* The default behaviour is non-positional and global options may appear anywhere on the command line.
		*
		* @param {boolean} [positional]
		* @return {Command} `this` command for chaining
		*/
		enablePositionalOptions(positional = true) {
			this._enablePositionalOptions = !!positional;
			return this;
		}
		/**
		* Pass through options that come after command-arguments rather than treat them as command-options,
		* so actual command-options come before command-arguments. Turning this on for a subcommand requires
		* positional options to have been enabled on the program (parent commands).
		* The default behaviour is non-positional and options may appear before or after command-arguments.
		*
		* @param {boolean} [passThrough] for unknown options.
		* @return {Command} `this` command for chaining
		*/
		passThroughOptions(passThrough = true) {
			this._passThroughOptions = !!passThrough;
			this._checkForBrokenPassThrough();
			return this;
		}
		/**
		* @private
		*/
		_checkForBrokenPassThrough() {
			if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
		}
		/**
		* Whether to store option values as properties on command object,
		* or store separately (specify false). In both cases the option values can be accessed using .opts().
		*
		* @param {boolean} [storeAsProperties=true]
		* @return {Command} `this` command for chaining
		*/
		storeOptionsAsProperties(storeAsProperties = true) {
			if (this.options.length) throw new Error("call .storeOptionsAsProperties() before adding options");
			if (Object.keys(this._optionValues).length) throw new Error("call .storeOptionsAsProperties() before setting option values");
			this._storeOptionsAsProperties = !!storeAsProperties;
			return this;
		}
		/**
		* Retrieve option value.
		*
		* @param {string} key
		* @return {object} value
		*/
		getOptionValue(key) {
			if (this._storeOptionsAsProperties) return this[key];
			return this._optionValues[key];
		}
		/**
		* Store option value.
		*
		* @param {string} key
		* @param {object} value
		* @return {Command} `this` command for chaining
		*/
		setOptionValue(key, value) {
			return this.setOptionValueWithSource(key, value, undefined);
		}
		/**
		* Store option value and where the value came from.
		*
		* @param {string} key
		* @param {object} value
		* @param {string} source - expected values are default/config/env/cli/implied
		* @return {Command} `this` command for chaining
		*/
		setOptionValueWithSource(key, value, source) {
			if (this._storeOptionsAsProperties) this[key] = value;
else this._optionValues[key] = value;
			this._optionValueSources[key] = source;
			return this;
		}
		/**
		* Get source of option value.
		* Expected values are default | config | env | cli | implied
		*
		* @param {string} key
		* @return {string}
		*/
		getOptionValueSource(key) {
			return this._optionValueSources[key];
		}
		/**
		* Get source of option value. See also .optsWithGlobals().
		* Expected values are default | config | env | cli | implied
		*
		* @param {string} key
		* @return {string}
		*/
		getOptionValueSourceWithGlobals(key) {
			let source;
			this._getCommandAndAncestors().forEach((cmd) => {
				if (cmd.getOptionValueSource(key) !== undefined) source = cmd.getOptionValueSource(key);
			});
			return source;
		}
		/**
		* Get user arguments from implied or explicit arguments.
		* Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
		*
		* @private
		*/
		_prepareUserArgs(argv, parseOptions) {
			if (argv !== undefined && !Array.isArray(argv)) throw new Error("first parameter to parse must be array or undefined");
			parseOptions = parseOptions || {};
			if (argv === undefined && parseOptions.from === undefined) {
				if (process$2.versions?.electron) parseOptions.from = "electron";
				const execArgv = process$2.execArgv ?? [];
				if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) parseOptions.from = "eval";
			}
			if (argv === undefined) argv = process$2.argv;
			this.rawArgs = argv.slice();
			let userArgs;
			switch (parseOptions.from) {
				case undefined:
				case "node":
					this._scriptPath = argv[1];
					userArgs = argv.slice(2);
					break;
				case "electron":
					if (process$2.defaultApp) {
						this._scriptPath = argv[1];
						userArgs = argv.slice(2);
					} else userArgs = argv.slice(1);
					break;
				case "user":
					userArgs = argv.slice(0);
					break;
				case "eval":
					userArgs = argv.slice(1);
					break;
				default: throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
			}
			if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
			this._name = this._name || "program";
			return userArgs;
		}
		/**
		* Parse `argv`, setting options and invoking commands when defined.
		*
		* Use parseAsync instead of parse if any of your action handlers are async.
		*
		* Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
		*
		* Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
		* - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
		* - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
		* - `'user'`: just user arguments
		*
		* @example
		* program.parse(); // parse process.argv and auto-detect electron and special node flags
		* program.parse(process.argv); // assume argv[0] is app and argv[1] is script
		* program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
		*
		* @param {string[]} [argv] - optional, defaults to process.argv
		* @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
		* @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
		* @return {Command} `this` command for chaining
		*/
		parse(argv, parseOptions) {
			this._prepareForParse();
			const userArgs = this._prepareUserArgs(argv, parseOptions);
			this._parseCommand([], userArgs);
			return this;
		}
		/**
		* Parse `argv`, setting options and invoking commands when defined.
		*
		* Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
		*
		* Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
		* - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
		* - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
		* - `'user'`: just user arguments
		*
		* @example
		* await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
		* await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
		* await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
		*
		* @param {string[]} [argv]
		* @param {object} [parseOptions]
		* @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
		* @return {Promise}
		*/
		async parseAsync(argv, parseOptions) {
			this._prepareForParse();
			const userArgs = this._prepareUserArgs(argv, parseOptions);
			await this._parseCommand([], userArgs);
			return this;
		}
		_prepareForParse() {
			if (this._savedState === null) this.saveStateBeforeParse();
else this.restoreStateBeforeParse();
		}
		/**
		* Called the first time parse is called to save state and allow a restore before subsequent calls to parse.
		* Not usually called directly, but available for subclasses to save their custom state.
		*
		* This is called in a lazy way. Only commands used in parsing chain will have state saved.
		*/
		saveStateBeforeParse() {
			this._savedState = {
				_name: this._name,
				_optionValues: { ...this._optionValues },
				_optionValueSources: { ...this._optionValueSources }
			};
		}
		/**
		* Restore state before parse for calls after the first.
		* Not usually called directly, but available for subclasses to save their custom state.
		*
		* This is called in a lazy way. Only commands used in parsing chain will have state restored.
		*/
		restoreStateBeforeParse() {
			if (this._storeOptionsAsProperties) throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);
			this._name = this._savedState._name;
			this._scriptPath = null;
			this.rawArgs = [];
			this._optionValues = { ...this._savedState._optionValues };
			this._optionValueSources = { ...this._savedState._optionValueSources };
			this.args = [];
			this.processedArgs = [];
		}
		/**
		* Throw if expected executable is missing. Add lots of help for author.
		*
		* @param {string} executableFile
		* @param {string} executableDir
		* @param {string} subcommandName
		*/
		_checkForMissingExecutable(executableFile, executableDir, subcommandName) {
			if (fs$1.existsSync(executableFile)) return;
			const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
			const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
			throw new Error(executableMissing);
		}
		/**
		* Execute a sub-command executable.
		*
		* @private
		*/
		_executeSubCommand(subcommand, args) {
			args = args.slice();
			let launchWithNode = false;
			const sourceExt = [
				".js",
				".ts",
				".tsx",
				".mjs",
				".cjs"
			];
			function findFile(baseDir, baseName) {
				const localBin = path$1.resolve(baseDir, baseName);
				if (fs$1.existsSync(localBin)) return localBin;
				if (sourceExt.includes(path$1.extname(baseName))) return undefined;
				const foundExt = sourceExt.find((ext) => fs$1.existsSync(`${localBin}${ext}`));
				if (foundExt) return `${localBin}${foundExt}`;
				return undefined;
			}
			this._checkForMissingMandatoryOptions();
			this._checkForConflictingOptions();
			let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
			let executableDir = this._executableDir || "";
			if (this._scriptPath) {
				let resolvedScriptPath;
				try {
					resolvedScriptPath = fs$1.realpathSync(this._scriptPath);
				} catch {
					resolvedScriptPath = this._scriptPath;
				}
				executableDir = path$1.resolve(path$1.dirname(resolvedScriptPath), executableDir);
			}
			if (executableDir) {
				let localFile = findFile(executableDir, executableFile);
				if (!localFile && !subcommand._executableFile && this._scriptPath) {
					const legacyName = path$1.basename(this._scriptPath, path$1.extname(this._scriptPath));
					if (legacyName !== this._name) localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
				}
				executableFile = localFile || executableFile;
			}
			launchWithNode = sourceExt.includes(path$1.extname(executableFile));
			let proc;
			if (process$2.platform !== "win32") if (launchWithNode) {
				args.unshift(executableFile);
				args = incrementNodeInspectorPort(process$2.execArgv).concat(args);
				proc = childProcess.spawn(process$2.argv[0], args, { stdio: "inherit" });
			} else proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
else {
				this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
				args.unshift(executableFile);
				args = incrementNodeInspectorPort(process$2.execArgv).concat(args);
				proc = childProcess.spawn(process$2.execPath, args, { stdio: "inherit" });
			}
			if (!proc.killed) {
				const signals = [
					"SIGUSR1",
					"SIGUSR2",
					"SIGTERM",
					"SIGINT",
					"SIGHUP"
				];
				signals.forEach((signal) => {
					process$2.on(signal, () => {
						if (proc.killed === false && proc.exitCode === null) proc.kill(signal);
					});
				});
			}
			const exitCallback = this._exitCallback;
			proc.on("close", (code) => {
				code = code ?? 1;
				if (!exitCallback) process$2.exit(code);
else exitCallback(new CommanderError$2(code, "commander.executeSubCommandAsync", "(close)"));
			});
			proc.on("error", (err) => {
				if (err.code === "ENOENT") this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
else if (err.code === "EACCES") throw new Error(`'${executableFile}' not executable`);
				if (!exitCallback) process$2.exit(1);
else {
					const wrappedError = new CommanderError$2(1, "commander.executeSubCommandAsync", "(error)");
					wrappedError.nestedError = err;
					exitCallback(wrappedError);
				}
			});
			this.runningCommand = proc;
		}
		/**
		* @private
		*/
		_dispatchSubcommand(commandName, operands, unknown) {
			const subCommand = this._findCommand(commandName);
			if (!subCommand) this.help({ error: true });
			subCommand._prepareForParse();
			let promiseChain;
			promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand");
			promiseChain = this._chainOrCall(promiseChain, () => {
				if (subCommand._executableHandler) this._executeSubCommand(subCommand, operands.concat(unknown));
else return subCommand._parseCommand(operands, unknown);
			});
			return promiseChain;
		}
		/**
		* Invoke help directly if possible, or dispatch if necessary.
		* e.g. help foo
		*
		* @private
		*/
		_dispatchHelpCommand(subcommandName) {
			if (!subcommandName) this.help();
			const subCommand = this._findCommand(subcommandName);
			if (subCommand && !subCommand._executableHandler) subCommand.help();
			return this._dispatchSubcommand(subcommandName, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]);
		}
		/**
		* Check this.args against expected this.registeredArguments.
		*
		* @private
		*/
		_checkNumberOfArguments() {
			this.registeredArguments.forEach((arg, i$1) => {
				if (arg.required && this.args[i$1] == null) this.missingArgument(arg.name());
			});
			if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) return;
			if (this.args.length > this.registeredArguments.length) this._excessArguments(this.args);
		}
		/**
		* Process this.args using this.registeredArguments and save as this.processedArgs!
		*
		* @private
		*/
		_processArguments() {
			const myParseArg = (argument, value, previous) => {
				let parsedValue = value;
				if (value !== null && argument.parseArg) {
					const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
					parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
				}
				return parsedValue;
			};
			this._checkNumberOfArguments();
			const processedArgs = [];
			this.registeredArguments.forEach((declaredArg, index) => {
				let value = declaredArg.defaultValue;
				if (declaredArg.variadic) {
					if (index < this.args.length) {
						value = this.args.slice(index);
						if (declaredArg.parseArg) value = value.reduce((processed, v) => {
							return myParseArg(declaredArg, v, processed);
						}, declaredArg.defaultValue);
					} else if (value === undefined) value = [];
				} else if (index < this.args.length) {
					value = this.args[index];
					if (declaredArg.parseArg) value = myParseArg(declaredArg, value, declaredArg.defaultValue);
				}
				processedArgs[index] = value;
			});
			this.processedArgs = processedArgs;
		}
		/**
		* Once we have a promise we chain, but call synchronously until then.
		*
		* @param {(Promise|undefined)} promise
		* @param {Function} fn
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCall(promise, fn) {
			if (promise && promise.then && typeof promise.then === "function") return promise.then(() => fn());
			return fn();
		}
		/**
		*
		* @param {(Promise|undefined)} promise
		* @param {string} event
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCallHooks(promise, event) {
			let result = promise;
			const hooks = [];
			this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== undefined).forEach((hookedCommand) => {
				hookedCommand._lifeCycleHooks[event].forEach((callback) => {
					hooks.push({
						hookedCommand,
						callback
					});
				});
			});
			if (event === "postAction") hooks.reverse();
			hooks.forEach((hookDetail) => {
				result = this._chainOrCall(result, () => {
					return hookDetail.callback(hookDetail.hookedCommand, this);
				});
			});
			return result;
		}
		/**
		*
		* @param {(Promise|undefined)} promise
		* @param {Command} subCommand
		* @param {string} event
		* @return {(Promise|undefined)}
		* @private
		*/
		_chainOrCallSubCommandHook(promise, subCommand, event) {
			let result = promise;
			if (this._lifeCycleHooks[event] !== undefined) this._lifeCycleHooks[event].forEach((hook) => {
				result = this._chainOrCall(result, () => {
					return hook(this, subCommand);
				});
			});
			return result;
		}
		/**
		* Process arguments in context of this command.
		* Returns action result, in case it is a promise.
		*
		* @private
		*/
		_parseCommand(operands, unknown) {
			const parsed = this.parseOptions(unknown);
			this._parseOptionsEnv();
			this._parseOptionsImplied();
			operands = operands.concat(parsed.operands);
			unknown = parsed.unknown;
			this.args = operands.concat(unknown);
			if (operands && this._findCommand(operands[0])) return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
			if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) return this._dispatchHelpCommand(operands[1]);
			if (this._defaultCommandName) {
				this._outputHelpIfRequested(unknown);
				return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
			}
			if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) this.help({ error: true });
			this._outputHelpIfRequested(parsed.unknown);
			this._checkForMissingMandatoryOptions();
			this._checkForConflictingOptions();
			const checkForUnknownOptions = () => {
				if (parsed.unknown.length > 0) this.unknownOption(parsed.unknown[0]);
			};
			const commandEvent = `command:${this.name()}`;
			if (this._actionHandler) {
				checkForUnknownOptions();
				this._processArguments();
				let promiseChain;
				promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
				promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
				if (this.parent) promiseChain = this._chainOrCall(promiseChain, () => {
					this.parent.emit(commandEvent, operands, unknown);
				});
				promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
				return promiseChain;
			}
			if (this.parent && this.parent.listenerCount(commandEvent)) {
				checkForUnknownOptions();
				this._processArguments();
				this.parent.emit(commandEvent, operands, unknown);
			} else if (operands.length) {
				if (this._findCommand("*")) return this._dispatchSubcommand("*", operands, unknown);
				if (this.listenerCount("command:*")) this.emit("command:*", operands, unknown);
else if (this.commands.length) this.unknownCommand();
else {
					checkForUnknownOptions();
					this._processArguments();
				}
			} else if (this.commands.length) {
				checkForUnknownOptions();
				this.help({ error: true });
			} else {
				checkForUnknownOptions();
				this._processArguments();
			}
		}
		/**
		* Find matching command.
		*
		* @private
		* @return {Command | undefined}
		*/
		_findCommand(name) {
			if (!name) return undefined;
			return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
		}
		/**
		* Return an option matching `arg` if any.
		*
		* @param {string} arg
		* @return {Option}
		* @package
		*/
		_findOption(arg) {
			return this.options.find((option) => option.is(arg));
		}
		/**
		* Display an error message if a mandatory option does not have a value.
		* Called after checking for help flags in leaf subcommand.
		*
		* @private
		*/
		_checkForMissingMandatoryOptions() {
			this._getCommandAndAncestors().forEach((cmd) => {
				cmd.options.forEach((anOption) => {
					if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) cmd.missingMandatoryOptionValue(anOption);
				});
			});
		}
		/**
		* Display an error message if conflicting options are used together in this.
		*
		* @private
		*/
		_checkForConflictingLocalOptions() {
			const definedNonDefaultOptions = this.options.filter((option) => {
				const optionKey = option.attributeName();
				if (this.getOptionValue(optionKey) === undefined) return false;
				return this.getOptionValueSource(optionKey) !== "default";
			});
			const optionsWithConflicting = definedNonDefaultOptions.filter((option) => option.conflictsWith.length > 0);
			optionsWithConflicting.forEach((option) => {
				const conflictingAndDefined = definedNonDefaultOptions.find((defined) => option.conflictsWith.includes(defined.attributeName()));
				if (conflictingAndDefined) this._conflictingOption(option, conflictingAndDefined);
			});
		}
		/**
		* Display an error message if conflicting options are used together.
		* Called after checking for help flags in leaf subcommand.
		*
		* @private
		*/
		_checkForConflictingOptions() {
			this._getCommandAndAncestors().forEach((cmd) => {
				cmd._checkForConflictingLocalOptions();
			});
		}
		/**
		* Parse options from `argv` removing known options,
		* and return argv split into operands and unknown arguments.
		*
		* Side effects: modifies command by storing options. Does not reset state if called again.
		*
		* Examples:
		*
		*     argv => operands, unknown
		*     --known kkk op => [op], []
		*     op --known kkk => [op], []
		*     sub --unknown uuu op => [sub], [--unknown uuu op]
		*     sub -- --unknown uuu op => [sub --unknown uuu op], []
		*
		* @param {string[]} argv
		* @return {{operands: string[], unknown: string[]}}
		*/
		parseOptions(argv) {
			const operands = [];
			const unknown = [];
			let dest = operands;
			const args = argv.slice();
			function maybeOption(arg) {
				return arg.length > 1 && arg[0] === "-";
			}
			let activeVariadicOption = null;
			while (args.length) {
				const arg = args.shift();
				if (arg === "--") {
					if (dest === unknown) dest.push(arg);
					dest.push(...args);
					break;
				}
				if (activeVariadicOption && !maybeOption(arg)) {
					this.emit(`option:${activeVariadicOption.name()}`, arg);
					continue;
				}
				activeVariadicOption = null;
				if (maybeOption(arg)) {
					const option = this._findOption(arg);
					if (option) {
						if (option.required) {
							const value = args.shift();
							if (value === undefined) this.optionMissingArgument(option);
							this.emit(`option:${option.name()}`, value);
						} else if (option.optional) {
							let value = null;
							if (args.length > 0 && !maybeOption(args[0])) value = args.shift();
							this.emit(`option:${option.name()}`, value);
						} else this.emit(`option:${option.name()}`);
						activeVariadicOption = option.variadic ? option : null;
						continue;
					}
				}
				if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
					const option = this._findOption(`-${arg[1]}`);
					if (option) {
						if (option.required || option.optional && this._combineFlagAndOptionalValue) this.emit(`option:${option.name()}`, arg.slice(2));
else {
							this.emit(`option:${option.name()}`);
							args.unshift(`-${arg.slice(2)}`);
						}
						continue;
					}
				}
				if (/^--[^=]+=/.test(arg)) {
					const index = arg.indexOf("=");
					const option = this._findOption(arg.slice(0, index));
					if (option && (option.required || option.optional)) {
						this.emit(`option:${option.name()}`, arg.slice(index + 1));
						continue;
					}
				}
				if (maybeOption(arg)) dest = unknown;
				if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
					if (this._findCommand(arg)) {
						operands.push(arg);
						if (args.length > 0) unknown.push(...args);
						break;
					} else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
						operands.push(arg);
						if (args.length > 0) operands.push(...args);
						break;
					} else if (this._defaultCommandName) {
						unknown.push(arg);
						if (args.length > 0) unknown.push(...args);
						break;
					}
				}
				if (this._passThroughOptions) {
					dest.push(arg);
					if (args.length > 0) dest.push(...args);
					break;
				}
				dest.push(arg);
			}
			return {
				operands,
				unknown
			};
		}
		/**
		* Return an object containing local option values as key-value pairs.
		*
		* @return {object}
		*/
		opts() {
			if (this._storeOptionsAsProperties) {
				const result = {};
				const len = this.options.length;
				for (let i$1 = 0; i$1 < len; i$1++) {
					const key = this.options[i$1].attributeName();
					result[key] = key === this._versionOptionName ? this._version : this[key];
				}
				return result;
			}
			return this._optionValues;
		}
		/**
		* Return an object containing merged local and global option values as key-value pairs.
		*
		* @return {object}
		*/
		optsWithGlobals() {
			return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
		}
		/**
		* Display error message and exit (or call exitOverride).
		*
		* @param {string} message
		* @param {object} [errorOptions]
		* @param {string} [errorOptions.code] - an id string representing the error
		* @param {number} [errorOptions.exitCode] - used with process.exit
		*/
		error(message, errorOptions) {
			this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
			if (typeof this._showHelpAfterError === "string") this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
else if (this._showHelpAfterError) {
				this._outputConfiguration.writeErr("\n");
				this.outputHelp({ error: true });
			}
			const config = errorOptions || {};
			const exitCode = config.exitCode || 1;
			const code = config.code || "commander.error";
			this._exit(exitCode, code, message);
		}
		/**
		* Apply any option related environment variables, if option does
		* not have a value from cli or client code.
		*
		* @private
		*/
		_parseOptionsEnv() {
			this.options.forEach((option) => {
				if (option.envVar && option.envVar in process$2.env) {
					const optionKey = option.attributeName();
					if (this.getOptionValue(optionKey) === undefined || [
						"default",
						"config",
						"env"
					].includes(this.getOptionValueSource(optionKey))) if (option.required || option.optional) this.emit(`optionEnv:${option.name()}`, process$2.env[option.envVar]);
else this.emit(`optionEnv:${option.name()}`);
				}
			});
		}
		/**
		* Apply any implied option values, if option is undefined or default value.
		*
		* @private
		*/
		_parseOptionsImplied() {
			const dualHelper = new DualOptions(this.options);
			const hasCustomOptionValue = (optionKey) => {
				return this.getOptionValue(optionKey) !== undefined && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
			};
			this.options.filter((option) => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
				Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
					this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
				});
			});
		}
		/**
		* Argument `name` is missing.
		*
		* @param {string} name
		* @private
		*/
		missingArgument(name) {
			const message = `error: missing required argument '${name}'`;
			this.error(message, { code: "commander.missingArgument" });
		}
		/**
		* `Option` is missing an argument.
		*
		* @param {Option} option
		* @private
		*/
		optionMissingArgument(option) {
			const message = `error: option '${option.flags}' argument missing`;
			this.error(message, { code: "commander.optionMissingArgument" });
		}
		/**
		* `Option` does not have a value, and is a mandatory option.
		*
		* @param {Option} option
		* @private
		*/
		missingMandatoryOptionValue(option) {
			const message = `error: required option '${option.flags}' not specified`;
			this.error(message, { code: "commander.missingMandatoryOptionValue" });
		}
		/**
		* `Option` conflicts with another option.
		*
		* @param {Option} option
		* @param {Option} conflictingOption
		* @private
		*/
		_conflictingOption(option, conflictingOption) {
			const findBestOptionFromValue = (option$1) => {
				const optionKey = option$1.attributeName();
				const optionValue = this.getOptionValue(optionKey);
				const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
				const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
				if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) return negativeOption;
				return positiveOption || option$1;
			};
			const getErrorMessage = (option$1) => {
				const bestOption = findBestOptionFromValue(option$1);
				const optionKey = bestOption.attributeName();
				const source = this.getOptionValueSource(optionKey);
				if (source === "env") return `environment variable '${bestOption.envVar}'`;
				return `option '${bestOption.flags}'`;
			};
			const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
			this.error(message, { code: "commander.conflictingOption" });
		}
		/**
		* Unknown option `flag`.
		*
		* @param {string} flag
		* @private
		*/
		unknownOption(flag) {
			if (this._allowUnknownOption) return;
			let suggestion = "";
			if (flag.startsWith("--") && this._showSuggestionAfterError) {
				let candidateFlags = [];
				let command = this;
				do {
					const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
					candidateFlags = candidateFlags.concat(moreFlags);
					command = command.parent;
				} while (command && !command._enablePositionalOptions);
				suggestion = suggestSimilar(flag, candidateFlags);
			}
			const message = `error: unknown option '${flag}'${suggestion}`;
			this.error(message, { code: "commander.unknownOption" });
		}
		/**
		* Excess arguments, more than expected.
		*
		* @param {string[]} receivedArgs
		* @private
		*/
		_excessArguments(receivedArgs) {
			if (this._allowExcessArguments) return;
			const expected = this.registeredArguments.length;
			const s$1 = expected === 1 ? "" : "s";
			const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
			const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s$1} but got ${receivedArgs.length}.`;
			this.error(message, { code: "commander.excessArguments" });
		}
		/**
		* Unknown command.
		*
		* @private
		*/
		unknownCommand() {
			const unknownName = this.args[0];
			let suggestion = "";
			if (this._showSuggestionAfterError) {
				const candidateNames = [];
				this.createHelp().visibleCommands(this).forEach((command) => {
					candidateNames.push(command.name());
					if (command.alias()) candidateNames.push(command.alias());
				});
				suggestion = suggestSimilar(unknownName, candidateNames);
			}
			const message = `error: unknown command '${unknownName}'${suggestion}`;
			this.error(message, { code: "commander.unknownCommand" });
		}
		/**
		* Get or set the program version.
		*
		* This method auto-registers the "-V, --version" option which will print the version number.
		*
		* You can optionally supply the flags and description to override the defaults.
		*
		* @param {string} [str]
		* @param {string} [flags]
		* @param {string} [description]
		* @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
		*/
		version(str, flags, description) {
			if (str === undefined) return this._version;
			this._version = str;
			flags = flags || "-V, --version";
			description = description || "output the version number";
			const versionOption = this.createOption(flags, description);
			this._versionOptionName = versionOption.attributeName();
			this._registerOption(versionOption);
			this.on("option:" + versionOption.name(), () => {
				this._outputConfiguration.writeOut(`${str}\n`);
				this._exit(0, "commander.version", str);
			});
			return this;
		}
		/**
		* Set the description.
		*
		* @param {string} [str]
		* @param {object} [argsDescription]
		* @return {(string|Command)}
		*/
		description(str, argsDescription) {
			if (str === undefined && argsDescription === undefined) return this._description;
			this._description = str;
			if (argsDescription) this._argsDescription = argsDescription;
			return this;
		}
		/**
		* Set the summary. Used when listed as subcommand of parent.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		summary(str) {
			if (str === undefined) return this._summary;
			this._summary = str;
			return this;
		}
		/**
		* Set an alias for the command.
		*
		* You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
		*
		* @param {string} [alias]
		* @return {(string|Command)}
		*/
		alias(alias) {
			if (alias === undefined) return this._aliases[0];
			/** @type {Command} */
			let command = this;
			if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) command = this.commands[this.commands.length - 1];
			if (alias === command._name) throw new Error("Command alias can't be the same as its name");
			const matchingCommand = this.parent?._findCommand(alias);
			if (matchingCommand) {
				const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
				throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
			}
			command._aliases.push(alias);
			return this;
		}
		/**
		* Set aliases for the command.
		*
		* Only the first alias is shown in the auto-generated help.
		*
		* @param {string[]} [aliases]
		* @return {(string[]|Command)}
		*/
		aliases(aliases$1) {
			if (aliases$1 === undefined) return this._aliases;
			aliases$1.forEach((alias) => this.alias(alias));
			return this;
		}
		/**
		* Set / get the command usage `str`.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		usage(str) {
			if (str === undefined) {
				if (this._usage) return this._usage;
				const args = this.registeredArguments.map((arg) => {
					return humanReadableArgName(arg);
				});
				return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
			}
			this._usage = str;
			return this;
		}
		/**
		* Get or set the name of the command.
		*
		* @param {string} [str]
		* @return {(string|Command)}
		*/
		name(str) {
			if (str === undefined) return this._name;
			this._name = str;
			return this;
		}
		/**
		* Set the name of the command from script filename, such as process.argv[1],
		* or require.main.filename, or __filename.
		*
		* (Used internally and public although not documented in README.)
		*
		* @example
		* program.nameFromFilename(require.main.filename);
		*
		* @param {string} filename
		* @return {Command}
		*/
		nameFromFilename(filename) {
			this._name = path$1.basename(filename, path$1.extname(filename));
			return this;
		}
		/**
		* Get or set the directory for searching for executable subcommands of this command.
		*
		* @example
		* program.executableDir(__dirname);
		* // or
		* program.executableDir('subcommands');
		*
		* @param {string} [path]
		* @return {(string|null|Command)}
		*/
		executableDir(path$2) {
			if (path$2 === undefined) return this._executableDir;
			this._executableDir = path$2;
			return this;
		}
		/**
		* Return program help documentation.
		*
		* @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
		* @return {string}
		*/
		helpInformation(contextOptions) {
			const helper = this.createHelp();
			const context = this._getOutputContext(contextOptions);
			helper.prepareContext({
				error: context.error,
				helpWidth: context.helpWidth,
				outputHasColors: context.hasColors
			});
			const text$1 = helper.formatHelp(this, helper);
			if (context.hasColors) return text$1;
			return this._outputConfiguration.stripColor(text$1);
		}
		/**
		* @typedef HelpContext
		* @type {object}
		* @property {boolean} error
		* @property {number} helpWidth
		* @property {boolean} hasColors
		* @property {function} write - includes stripColor if needed
		*
		* @returns {HelpContext}
		* @private
		*/
		_getOutputContext(contextOptions) {
			contextOptions = contextOptions || {};
			const error = !!contextOptions.error;
			let baseWrite;
			let hasColors;
			let helpWidth;
			if (error) {
				baseWrite = (str) => this._outputConfiguration.writeErr(str);
				hasColors = this._outputConfiguration.getErrHasColors();
				helpWidth = this._outputConfiguration.getErrHelpWidth();
			} else {
				baseWrite = (str) => this._outputConfiguration.writeOut(str);
				hasColors = this._outputConfiguration.getOutHasColors();
				helpWidth = this._outputConfiguration.getOutHelpWidth();
			}
			const write = (str) => {
				if (!hasColors) str = this._outputConfiguration.stripColor(str);
				return baseWrite(str);
			};
			return {
				error,
				write,
				hasColors,
				helpWidth
			};
		}
		/**
		* Output help information for this command.
		*
		* Outputs built-in help, and custom text added using `.addHelpText()`.
		*
		* @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
		*/
		outputHelp(contextOptions) {
			let deprecatedCallback;
			if (typeof contextOptions === "function") {
				deprecatedCallback = contextOptions;
				contextOptions = undefined;
			}
			const outputContext = this._getOutputContext(contextOptions);
			/** @type {HelpTextEventContext} */
			const eventContext = {
				error: outputContext.error,
				write: outputContext.write,
				command: this
			};
			this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", eventContext));
			this.emit("beforeHelp", eventContext);
			let helpInformation = this.helpInformation({ error: outputContext.error });
			if (deprecatedCallback) {
				helpInformation = deprecatedCallback(helpInformation);
				if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) throw new Error("outputHelp callback must return a string or a Buffer");
			}
			outputContext.write(helpInformation);
			if (this._getHelpOption()?.long) this.emit(this._getHelpOption().long);
			this.emit("afterHelp", eventContext);
			this._getCommandAndAncestors().forEach((command) => command.emit("afterAllHelp", eventContext));
		}
		/**
		* You can pass in flags and a description to customise the built-in help option.
		* Pass in false to disable the built-in help option.
		*
		* @example
		* program.helpOption('-?, --help' 'show help'); // customise
		* program.helpOption(false); // disable
		*
		* @param {(string | boolean)} flags
		* @param {string} [description]
		* @return {Command} `this` command for chaining
		*/
		helpOption(flags, description) {
			if (typeof flags === "boolean") {
				if (flags) this._helpOption = this._helpOption ?? undefined;
else this._helpOption = null;
				return this;
			}
			flags = flags ?? "-h, --help";
			description = description ?? "display help for command";
			this._helpOption = this.createOption(flags, description);
			return this;
		}
		/**
		* Lazy create help option.
		* Returns null if has been disabled with .helpOption(false).
		*
		* @returns {(Option | null)} the help option
		* @package
		*/
		_getHelpOption() {
			if (this._helpOption === undefined) this.helpOption(undefined, undefined);
			return this._helpOption;
		}
		/**
		* Supply your own option to use for the built-in help option.
		* This is an alternative to using helpOption() to customise the flags and description etc.
		*
		* @param {Option} option
		* @return {Command} `this` command for chaining
		*/
		addHelpOption(option) {
			this._helpOption = option;
			return this;
		}
		/**
		* Output help information and exit.
		*
		* Outputs built-in help, and custom text added using `.addHelpText()`.
		*
		* @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
		*/
		help(contextOptions) {
			this.outputHelp(contextOptions);
			let exitCode = Number(process$2.exitCode ?? 0);
			if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) exitCode = 1;
			this._exit(exitCode, "commander.help", "(outputHelp)");
		}
		/**
		* // Do a little typing to coordinate emit and listener for the help text events.
		* @typedef HelpTextEventContext
		* @type {object}
		* @property {boolean} error
		* @property {Command} command
		* @property {function} write
		*/
		/**
		* Add additional text to be displayed with the built-in help.
		*
		* Position is 'before' or 'after' to affect just this command,
		* and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
		*
		* @param {string} position - before or after built-in help
		* @param {(string | Function)} text - string to add, or a function returning a string
		* @return {Command} `this` command for chaining
		*/
		addHelpText(position, text$1) {
			const allowedValues = [
				"beforeAll",
				"before",
				"after",
				"afterAll"
			];
			if (!allowedValues.includes(position)) throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
			const helpEvent = `${position}Help`;
			this.on(helpEvent, (context) => {
				let helpStr;
				if (typeof text$1 === "function") helpStr = text$1({
					error: context.error,
					command: context.command
				});
else helpStr = text$1;
				if (helpStr) context.write(`${helpStr}\n`);
			});
			return this;
		}
		/**
		* Output help information if help flags specified
		*
		* @param {Array} args - array of options to search for help flags
		* @private
		*/
		_outputHelpIfRequested(args) {
			const helpOption = this._getHelpOption();
			const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
			if (helpRequested) {
				this.outputHelp();
				this._exit(0, "commander.helpDisplayed", "(outputHelp)");
			}
		}
	};
	/**
	* Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
	*
	* @param {string[]} args - array of arguments from node.execArgv
	* @returns {string[]}
	* @private
	*/
	function incrementNodeInspectorPort(args) {
		return args.map((arg) => {
			if (!arg.startsWith("--inspect")) return arg;
			let debugOption;
			let debugHost = "127.0.0.1";
			let debugPort = "9229";
			let match;
			if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) debugOption = match[1];
else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
				debugOption = match[1];
				if (/^\d+$/.test(match[3])) debugPort = match[3];
else debugHost = match[3];
			} else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
				debugOption = match[1];
				debugHost = match[3];
				debugPort = match[4];
			}
			if (debugOption && debugPort !== "0") return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
			return arg;
		});
	}
	/**
	* @returns {boolean | undefined}
	* @package
	*/
	function useColor() {
		if (process$2.env.NO_COLOR || process$2.env.FORCE_COLOR === "0" || process$2.env.FORCE_COLOR === "false") return false;
		if (process$2.env.FORCE_COLOR || process$2.env.CLICOLOR_FORCE !== undefined) return true;
		return undefined;
	}
	exports.Command = Command$2;
	exports.useColor = useColor;
} });

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/index.js
var require_commander = __commonJS$3({ "node_modules/.pnpm/commander@13.1.0/node_modules/commander/index.js"(exports) {
	const { Argument: Argument$1 } = require_argument();
	const { Command: Command$1 } = require_command();
	const { CommanderError: CommanderError$1, InvalidArgumentError: InvalidArgumentError$1 } = require_error();
	const { Help: Help$1 } = require_help();
	const { Option: Option$1 } = require_option();
	exports.program = new Command$1();
	exports.createCommand = (name) => new Command$1(name);
	exports.createOption = (flags, description) => new Option$1(flags, description);
	exports.createArgument = (name, description) => new Argument$1(name, description);
	/**
	* Expose classes
	*/
	exports.Command = Command$1;
	exports.Option = Option$1;
	exports.Argument = Argument$1;
	exports.Help = Help$1;
	exports.CommanderError = CommanderError$1;
	exports.InvalidArgumentError = InvalidArgumentError$1;
	exports.InvalidOptionArgumentError = InvalidArgumentError$1;
} });

//#endregion
//#region node_modules/.pnpm/commander@13.1.0/node_modules/commander/esm.mjs
var import_commander = __toESM$3(require_commander(), 1);
const { program, createCommand, createArgument, createOption, CommanderError, InvalidArgumentError, InvalidOptionArgumentError, Command, Argument, Option, Help } = import_commander.default;

//#endregion
//#region packages/cli/utils/package-manager.ts
const AGENT_NAMES = AGENTS.filter((agent) => !agent.includes("@"));
const agentOptions = AGENT_NAMES.map((pm) => ({
	value: pm,
	label: pm
}));
agentOptions.unshift({
	label: "None",
	value: undefined
});
const installOption = new Option("--install <package-manager>", "installs dependencies with a specified package manager").choices(AGENT_NAMES);
async function packageManagerPrompt(cwd$1) {
	const detected = await detect({ cwd: cwd$1 });
	const agent = detected?.name ?? getUserAgent();
	if (!process$1.stdout.isTTY) return agent;
	const pm = await select({
		message: "Which package manager do you want to install dependencies with?",
		options: agentOptions,
		initialValue: agent
	});
	if (isCancel(pm)) {
		cancel("Operation cancelled.");
		process$1.exit(1);
	}
	return pm;
}
async function installDependencies(agent, cwd$1) {
	const task = taskLog(`Installing dependencies with ${agent}...`);
	try {
		const { command, args } = constructCommand(COMMANDS[agent].install, []);
		const proc = be(command, args, {
			nodeOptions: {
				cwd: cwd$1,
				stdio: "pipe"
			},
			throwOnError: true
		});
		proc.process?.stdout?.on("data", (data$1) => {
			task.text = data$1;
		});
		proc.process?.stderr?.on("data", (data$1) => {
			task.text = data$1;
		});
		await proc;
		task.success("Successfully installed dependencies");
	} catch {
		task.fail("Failed to install dependencies");
		cancel("Operation failed.");
		process$1.exit(2);
	}
}
function getUserAgent() {
	const userAgent = process$1.env.npm_config_user_agent;
	if (!userAgent) return undefined;
	const pmSpec = userAgent.split(" ")[0];
	const separatorPos = pmSpec.lastIndexOf("/");
	const name = pmSpec.substring(0, separatorPos);
	return AGENTS.includes(name) ? name : undefined;
}
function addPnpmBuildDependencies(cwd$1, packageManager, allowedPackages) {
	if (!packageManager || packageManager !== "pnpm") return;
	const pnpmWorkspacePath = up("pnpm-workspace.yaml", { cwd: cwd$1 });
	let packageDirectory;
	if (pnpmWorkspacePath) packageDirectory = path.dirname(pnpmWorkspacePath);
else packageDirectory = cwd$1;
	const pkgPath = path.join(packageDirectory, "package.json");
	const content = fs.readFileSync(pkgPath, "utf-8");
	const { data: data$1, generateCode } = parseJson$1(content);
	data$1.pnpm ??= {};
	data$1.pnpm.onlyBuiltDependencies ??= [];
	for (const allowedPackage of allowedPackages) {
		if (data$1.pnpm.onlyBuiltDependencies.includes(allowedPackage)) continue;
		data$1.pnpm.onlyBuiltDependencies.push(allowedPackage);
	}
	const newContent = generateCode();
	fs.writeFileSync(pkgPath, newContent);
}

//#endregion
export { AGENT_NAMES, Command, Element, Option, Tag, __commonJS$3 as __commonJS, __export, __require$1 as __require, __toESM, __toESM$3 as __toESM$1, addPnpmBuildDependencies, be, box, cancel, confirm, create, detect, esm_exports, from, getUserAgent, group, installDependencies, installOption, intro, isCancel, log, multiselect, note, outro, packageManagerPrompt, parseCss$1, parseHtml, parseHtml$1, parseJson$1, parseScript, parseScript$1, parseSvelte, program, require_picocolors, resolveCommand, select, serializeScript, spinner, stripAst, templates, text, up, walk, walk_exports };