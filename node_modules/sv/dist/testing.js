import { __commonJS, __require, __toESM$1 as __toESM, addPnpmBuildDependencies, be, create } from "./package-manager-D3PRQ-L_.js";
import fs from "node:fs";
import path from "node:path";
import process$1 from "node:process";

//#region node_modules/.pnpm/degit@2.8.4/node_modules/degit/dist/index-688c5d50.js
var require_index_688c5d50 = __commonJS({ "node_modules/.pnpm/degit@2.8.4/node_modules/degit/dist/index-688c5d50.js"(exports) {
	var fs$1 = __require("fs");
	var path$1 = __require("path");
	var Events = __require("events");
	var Stream$1$1 = __require("stream");
	var require$$0 = __require("string_decoder");
	var assert = __require("assert");
	var require$$0$1 = __require("buffer");
	var realZlib = __require("zlib");
	var util$1 = __require("util");
	var crypto = __require("crypto");
	var os = __require("os");
	var tty = __require("tty");
	var constants$1 = __require("constants");
	var https = __require("https");
	var child_process = __require("child_process");
	var require$$2 = __require("url");
	var require$$0$2 = __require("net");
	var require$$1 = __require("tls");
	function _interopDefaultLegacy(e) {
		return e && typeof e === "object" && "default" in e ? e : { "default": e };
	}
	var fs__default = /*#__PURE__*/ _interopDefaultLegacy(fs$1);
	var path__default = /*#__PURE__*/ _interopDefaultLegacy(path$1);
	var Events__default = /*#__PURE__*/ _interopDefaultLegacy(Events);
	var Stream__default = /*#__PURE__*/ _interopDefaultLegacy(Stream$1$1);
	var require$$0__default = /*#__PURE__*/ _interopDefaultLegacy(require$$0);
	var assert__default = /*#__PURE__*/ _interopDefaultLegacy(assert);
	var require$$0__default$1 = /*#__PURE__*/ _interopDefaultLegacy(require$$0$1);
	var realZlib__default = /*#__PURE__*/ _interopDefaultLegacy(realZlib);
	var util__default = /*#__PURE__*/ _interopDefaultLegacy(util$1);
	var crypto__default = /*#__PURE__*/ _interopDefaultLegacy(crypto);
	var os__default = /*#__PURE__*/ _interopDefaultLegacy(os);
	var tty__default = /*#__PURE__*/ _interopDefaultLegacy(tty);
	var constants__default = /*#__PURE__*/ _interopDefaultLegacy(constants$1);
	var https__default = /*#__PURE__*/ _interopDefaultLegacy(https);
	var child_process__default = /*#__PURE__*/ _interopDefaultLegacy(child_process);
	var require$$2__default = /*#__PURE__*/ _interopDefaultLegacy(require$$2);
	var require$$0__default$2 = /*#__PURE__*/ _interopDefaultLegacy(require$$0$2);
	var require$$1__default = /*#__PURE__*/ _interopDefaultLegacy(require$$1);
	var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
	function createCommonjsModule(fn) {
		var module$1 = { exports: {} };
		return fn(module$1, module$1.exports), module$1.exports;
	}
	const argmap = new Map([
		["C", "cwd"],
		["f", "file"],
		["z", "gzip"],
		["P", "preservePaths"],
		["U", "unlink"],
		["strip-components", "strip"],
		["stripComponents", "strip"],
		["keep-newer", "newer"],
		["keepNewer", "newer"],
		["keep-newer-files", "newer"],
		["keepNewerFiles", "newer"],
		["k", "keep"],
		["keep-existing", "keep"],
		["keepExisting", "keep"],
		["m", "noMtime"],
		["no-mtime", "noMtime"],
		["p", "preserveOwner"],
		["L", "follow"],
		["h", "follow"]
	]);
	var highLevelOpt = (opt) => opt ? Object.keys(opt).map((k) => [argmap.has(k) ? argmap.get(k) : k, opt[k]]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {};
	var iterator = function(Yallist$1) {
		Yallist$1.prototype[Symbol.iterator] = function* () {
			for (let walker = this.head; walker; walker = walker.next) yield walker.value;
		};
	};
	var yallist = Yallist;
	Yallist.Node = Node;
	Yallist.create = Yallist;
	function Yallist(list$1) {
		var self$1 = this;
		if (!(self$1 instanceof Yallist)) self$1 = new Yallist();
		self$1.tail = null;
		self$1.head = null;
		self$1.length = 0;
		if (list$1 && typeof list$1.forEach === "function") list$1.forEach(function(item) {
			self$1.push(item);
		});
else if (arguments.length > 0) for (var i = 0, l = arguments.length; i < l; i++) self$1.push(arguments[i]);
		return self$1;
	}
	Yallist.prototype.removeNode = function(node$1) {
		if (node$1.list !== this) throw new Error("removing node which does not belong to this list");
		var next = node$1.next;
		var prev = node$1.prev;
		if (next) next.prev = prev;
		if (prev) prev.next = next;
		if (node$1 === this.head) this.head = next;
		if (node$1 === this.tail) this.tail = prev;
		node$1.list.length--;
		node$1.next = null;
		node$1.prev = null;
		node$1.list = null;
		return next;
	};
	Yallist.prototype.unshiftNode = function(node$1) {
		if (node$1 === this.head) return;
		if (node$1.list) node$1.list.removeNode(node$1);
		var head = this.head;
		node$1.list = this;
		node$1.next = head;
		if (head) head.prev = node$1;
		this.head = node$1;
		if (!this.tail) this.tail = node$1;
		this.length++;
	};
	Yallist.prototype.pushNode = function(node$1) {
		if (node$1 === this.tail) return;
		if (node$1.list) node$1.list.removeNode(node$1);
		var tail = this.tail;
		node$1.list = this;
		node$1.prev = tail;
		if (tail) tail.next = node$1;
		this.tail = node$1;
		if (!this.head) this.head = node$1;
		this.length++;
	};
	Yallist.prototype.push = function() {
		for (var i = 0, l = arguments.length; i < l; i++) push(this, arguments[i]);
		return this.length;
	};
	Yallist.prototype.unshift = function() {
		for (var i = 0, l = arguments.length; i < l; i++) unshift(this, arguments[i]);
		return this.length;
	};
	Yallist.prototype.pop = function() {
		if (!this.tail) return undefined;
		var res = this.tail.value;
		this.tail = this.tail.prev;
		if (this.tail) this.tail.next = null;
else this.head = null;
		this.length--;
		return res;
	};
	Yallist.prototype.shift = function() {
		if (!this.head) return undefined;
		var res = this.head.value;
		this.head = this.head.next;
		if (this.head) this.head.prev = null;
else this.tail = null;
		this.length--;
		return res;
	};
	Yallist.prototype.forEach = function(fn, thisp) {
		thisp = thisp || this;
		for (var walker = this.head, i = 0; walker !== null; i++) {
			fn.call(thisp, walker.value, i, this);
			walker = walker.next;
		}
	};
	Yallist.prototype.forEachReverse = function(fn, thisp) {
		thisp = thisp || this;
		for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
			fn.call(thisp, walker.value, i, this);
			walker = walker.prev;
		}
	};
	Yallist.prototype.get = function(n) {
		for (var i = 0, walker = this.head; walker !== null && i < n; i++) walker = walker.next;
		if (i === n && walker !== null) return walker.value;
	};
	Yallist.prototype.getReverse = function(n) {
		for (var i = 0, walker = this.tail; walker !== null && i < n; i++) walker = walker.prev;
		if (i === n && walker !== null) return walker.value;
	};
	Yallist.prototype.map = function(fn, thisp) {
		thisp = thisp || this;
		var res = new Yallist();
		for (var walker = this.head; walker !== null;) {
			res.push(fn.call(thisp, walker.value, this));
			walker = walker.next;
		}
		return res;
	};
	Yallist.prototype.mapReverse = function(fn, thisp) {
		thisp = thisp || this;
		var res = new Yallist();
		for (var walker = this.tail; walker !== null;) {
			res.push(fn.call(thisp, walker.value, this));
			walker = walker.prev;
		}
		return res;
	};
	Yallist.prototype.reduce = function(fn, initial) {
		var acc;
		var walker = this.head;
		if (arguments.length > 1) acc = initial;
else if (this.head) {
			walker = this.head.next;
			acc = this.head.value;
		} else throw new TypeError("Reduce of empty list with no initial value");
		for (var i = 0; walker !== null; i++) {
			acc = fn(acc, walker.value, i);
			walker = walker.next;
		}
		return acc;
	};
	Yallist.prototype.reduceReverse = function(fn, initial) {
		var acc;
		var walker = this.tail;
		if (arguments.length > 1) acc = initial;
else if (this.tail) {
			walker = this.tail.prev;
			acc = this.tail.value;
		} else throw new TypeError("Reduce of empty list with no initial value");
		for (var i = this.length - 1; walker !== null; i--) {
			acc = fn(acc, walker.value, i);
			walker = walker.prev;
		}
		return acc;
	};
	Yallist.prototype.toArray = function() {
		var arr = new Array(this.length);
		for (var i = 0, walker = this.head; walker !== null; i++) {
			arr[i] = walker.value;
			walker = walker.next;
		}
		return arr;
	};
	Yallist.prototype.toArrayReverse = function() {
		var arr = new Array(this.length);
		for (var i = 0, walker = this.tail; walker !== null; i++) {
			arr[i] = walker.value;
			walker = walker.prev;
		}
		return arr;
	};
	Yallist.prototype.slice = function(from$1, to) {
		to = to || this.length;
		if (to < 0) to += this.length;
		from$1 = from$1 || 0;
		if (from$1 < 0) from$1 += this.length;
		var ret = new Yallist();
		if (to < from$1 || to < 0) return ret;
		if (from$1 < 0) from$1 = 0;
		if (to > this.length) to = this.length;
		for (var i = 0, walker = this.head; walker !== null && i < from$1; i++) walker = walker.next;
		for (; walker !== null && i < to; i++, walker = walker.next) ret.push(walker.value);
		return ret;
	};
	Yallist.prototype.sliceReverse = function(from$1, to) {
		to = to || this.length;
		if (to < 0) to += this.length;
		from$1 = from$1 || 0;
		if (from$1 < 0) from$1 += this.length;
		var ret = new Yallist();
		if (to < from$1 || to < 0) return ret;
		if (from$1 < 0) from$1 = 0;
		if (to > this.length) to = this.length;
		for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) walker = walker.prev;
		for (; walker !== null && i > from$1; i--, walker = walker.prev) ret.push(walker.value);
		return ret;
	};
	Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
		if (start > this.length) start = this.length - 1;
		if (start < 0) start = this.length + start;
		for (var i = 0, walker = this.head; walker !== null && i < start; i++) walker = walker.next;
		var ret = [];
		for (var i = 0; walker && i < deleteCount; i++) {
			ret.push(walker.value);
			walker = this.removeNode(walker);
		}
		if (walker === null) walker = this.tail;
		if (walker !== this.head && walker !== this.tail) walker = walker.prev;
		for (var i = 0; i < nodes.length; i++) walker = insert(this, walker, nodes[i]);
		return ret;
	};
	Yallist.prototype.reverse = function() {
		var head = this.head;
		var tail = this.tail;
		for (var walker = head; walker !== null; walker = walker.prev) {
			var p = walker.prev;
			walker.prev = walker.next;
			walker.next = p;
		}
		this.head = tail;
		this.tail = head;
		return this;
	};
	function insert(self$1, node$1, value) {
		var inserted = node$1 === self$1.head ? new Node(value, null, node$1, self$1) : new Node(value, node$1, node$1.next, self$1);
		if (inserted.next === null) self$1.tail = inserted;
		if (inserted.prev === null) self$1.head = inserted;
		self$1.length++;
		return inserted;
	}
	function push(self$1, item) {
		self$1.tail = new Node(item, self$1.tail, null, self$1);
		if (!self$1.head) self$1.head = self$1.tail;
		self$1.length++;
	}
	function unshift(self$1, item) {
		self$1.head = new Node(item, null, self$1.head, self$1);
		if (!self$1.tail) self$1.tail = self$1.head;
		self$1.length++;
	}
	function Node(value, prev, next, list$1) {
		if (!(this instanceof Node)) return new Node(value, prev, next, list$1);
		this.list = list$1;
		this.value = value;
		if (prev) {
			prev.next = this;
			this.prev = prev;
		} else this.prev = null;
		if (next) {
			next.prev = this;
			this.next = next;
		} else this.next = null;
	}
	try {
		iterator(Yallist);
	} catch (er) {}
	const SD = require$$0__default["default"].StringDecoder;
	const EOF$1 = Symbol("EOF");
	const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
	const EMITTED_END = Symbol("emittedEnd");
	const EMITTING_END = Symbol("emittingEnd");
	const CLOSED = Symbol("closed");
	const READ$1 = Symbol("read");
	const FLUSH = Symbol("flush");
	const FLUSHCHUNK = Symbol("flushChunk");
	const ENCODING = Symbol("encoding");
	const DECODER = Symbol("decoder");
	const FLOWING = Symbol("flowing");
	const PAUSED = Symbol("paused");
	const RESUME = Symbol("resume");
	const BUFFERLENGTH = Symbol("bufferLength");
	const BUFFERPUSH = Symbol("bufferPush");
	const BUFFERSHIFT = Symbol("bufferShift");
	const OBJECTMODE = Symbol("objectMode");
	const DESTROYED = Symbol("destroyed");
	const doIter = commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== "1";
	const ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
	const ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
	const isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
	const isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
	const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
	var minipass = class Minipass extends Stream__default["default"] {
		constructor(options) {
			super();
			this[FLOWING] = false;
			this[PAUSED] = false;
			this.pipes = new yallist();
			this.buffer = new yallist();
			this[OBJECTMODE] = options && options.objectMode || false;
			if (this[OBJECTMODE]) this[ENCODING] = null;
else this[ENCODING] = options && options.encoding || null;
			if (this[ENCODING] === "buffer") this[ENCODING] = null;
			this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
			this[EOF$1] = false;
			this[EMITTED_END] = false;
			this[EMITTING_END] = false;
			this[CLOSED] = false;
			this.writable = true;
			this.readable = true;
			this[BUFFERLENGTH] = 0;
			this[DESTROYED] = false;
		}
		get bufferLength() {
			return this[BUFFERLENGTH];
		}
		get encoding() {
			return this[ENCODING];
		}
		set encoding(enc) {
			if (this[OBJECTMODE]) throw new Error("cannot set encoding in objectMode");
			if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error("cannot change encoding");
			if (this[ENCODING] !== enc) {
				this[DECODER] = enc ? new SD(enc) : null;
				if (this.buffer.length) this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
			}
			this[ENCODING] = enc;
		}
		setEncoding(enc) {
			this.encoding = enc;
		}
		get objectMode() {
			return this[OBJECTMODE];
		}
		set objectMode(om) {
			this[OBJECTMODE] = this[OBJECTMODE] || !!om;
		}
		write(chunk, encoding, cb) {
			if (this[EOF$1]) throw new Error("write after end");
			if (this[DESTROYED]) {
				this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
				return true;
			}
			if (typeof encoding === "function") cb = encoding, encoding = "utf8";
			if (!encoding) encoding = "utf8";
			if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
				if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
else if (typeof chunk !== "string") this.objectMode = true;
			}
			if (!this.objectMode && !chunk.length) {
				if (this[BUFFERLENGTH] !== 0) this.emit("readable");
				if (cb) cb();
				return this.flowing;
			}
			if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) chunk = Buffer.from(chunk, encoding);
			if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);
			if (this.flowing) {
				if (this[BUFFERLENGTH] !== 0) this[FLUSH](true);
				this.emit("data", chunk);
			} else this[BUFFERPUSH](chunk);
			if (this[BUFFERLENGTH] !== 0) this.emit("readable");
			if (cb) cb();
			return this.flowing;
		}
		read(n) {
			if (this[DESTROYED]) return null;
			try {
				if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;
				if (this[OBJECTMODE]) n = null;
				if (this.buffer.length > 1 && !this[OBJECTMODE]) if (this.encoding) this.buffer = new yallist([Array.from(this.buffer).join("")]);
else this.buffer = new yallist([Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);
				return this[READ$1](n || null, this.buffer.head.value);
			} finally {
				this[MAYBE_EMIT_END]();
			}
		}
		[READ$1](n, chunk) {
			if (n === chunk.length || n === null) this[BUFFERSHIFT]();
else {
				this.buffer.head.value = chunk.slice(n);
				chunk = chunk.slice(0, n);
				this[BUFFERLENGTH] -= n;
			}
			this.emit("data", chunk);
			if (!this.buffer.length && !this[EOF$1]) this.emit("drain");
			return chunk;
		}
		end(chunk, encoding, cb) {
			if (typeof chunk === "function") cb = chunk, chunk = null;
			if (typeof encoding === "function") cb = encoding, encoding = "utf8";
			if (chunk) this.write(chunk, encoding);
			if (cb) this.once("end", cb);
			this[EOF$1] = true;
			this.writable = false;
			if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
			return this;
		}
		[RESUME]() {
			if (this[DESTROYED]) return;
			this[PAUSED] = false;
			this[FLOWING] = true;
			this.emit("resume");
			if (this.buffer.length) this[FLUSH]();
else if (this[EOF$1]) this[MAYBE_EMIT_END]();
else this.emit("drain");
		}
		resume() {
			return this[RESUME]();
		}
		pause() {
			this[FLOWING] = false;
			this[PAUSED] = true;
		}
		get destroyed() {
			return this[DESTROYED];
		}
		get flowing() {
			return this[FLOWING];
		}
		get paused() {
			return this[PAUSED];
		}
		[BUFFERPUSH](chunk) {
			if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
else this[BUFFERLENGTH] += chunk.length;
			return this.buffer.push(chunk);
		}
		[BUFFERSHIFT]() {
			if (this.buffer.length) if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
else this[BUFFERLENGTH] -= this.buffer.head.value.length;
			return this.buffer.shift();
		}
		[FLUSH](noDrain) {
			do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
			if (!noDrain && !this.buffer.length && !this[EOF$1]) this.emit("drain");
		}
		[FLUSHCHUNK](chunk) {
			return chunk ? (this.emit("data", chunk), this.flowing) : false;
		}
		pipe(dest, opts) {
			if (this[DESTROYED]) return;
			const ended = this[EMITTED_END];
			opts = opts || {};
			if (dest === process.stdout || dest === process.stderr) opts.end = false;
else opts.end = opts.end !== false;
			const p = {
				dest,
				opts,
				ondrain: (_) => this[RESUME]()
			};
			this.pipes.push(p);
			dest.on("drain", p.ondrain);
			this[RESUME]();
			if (ended && p.opts.end) p.dest.end();
			return dest;
		}
		addListener(ev, fn) {
			return this.on(ev, fn);
		}
		on(ev, fn) {
			try {
				return super.on(ev, fn);
			} finally {
				if (ev === "data" && !this.pipes.length && !this.flowing) this[RESUME]();
else if (isEndish(ev) && this[EMITTED_END]) {
					super.emit(ev);
					this.removeAllListeners(ev);
				}
			}
		}
		get emittedEnd() {
			return this[EMITTED_END];
		}
		[MAYBE_EMIT_END]() {
			if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF$1]) {
				this[EMITTING_END] = true;
				this.emit("end");
				this.emit("prefinish");
				this.emit("finish");
				if (this[CLOSED]) this.emit("close");
				this[EMITTING_END] = false;
			}
		}
		emit(ev, data) {
			if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) return;
else if (ev === "data") {
				if (!data) return;
				if (this.pipes.length) this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
			} else if (ev === "end") {
				if (this[EMITTED_END] === true) return;
				this[EMITTED_END] = true;
				this.readable = false;
				if (this[DECODER]) {
					data = this[DECODER].end();
					if (data) {
						this.pipes.forEach((p) => p.dest.write(data));
						super.emit("data", data);
					}
				}
				this.pipes.forEach((p) => {
					p.dest.removeListener("drain", p.ondrain);
					if (p.opts.end) p.dest.end();
				});
			} else if (ev === "close") {
				this[CLOSED] = true;
				if (!this[EMITTED_END] && !this[DESTROYED]) return;
			}
			const args = new Array(arguments.length);
			args[0] = ev;
			args[1] = data;
			if (arguments.length > 2) for (let i = 2; i < arguments.length; i++) args[i] = arguments[i];
			try {
				return super.emit.apply(this, args);
			} finally {
				if (!isEndish(ev)) this[MAYBE_EMIT_END]();
else this.removeAllListeners(ev);
			}
		}
		collect() {
			const buf = [];
			if (!this[OBJECTMODE]) buf.dataLength = 0;
			const p = this.promise();
			this.on("data", (c) => {
				buf.push(c);
				if (!this[OBJECTMODE]) buf.dataLength += c.length;
			});
			return p.then(() => buf);
		}
		concat() {
			return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
		}
		promise() {
			return new Promise((resolve$2, reject) => {
				this.on(DESTROYED, () => reject(new Error("stream destroyed")));
				this.on("end", () => resolve$2());
				this.on("error", (er) => reject(er));
			});
		}
		[ASYNCITERATOR]() {
			const next = () => {
				const res = this.read();
				if (res !== null) return Promise.resolve({
					done: false,
					value: res
				});
				if (this[EOF$1]) return Promise.resolve({ done: true });
				let resolve$2 = null;
				let reject = null;
				const onerr = (er) => {
					this.removeListener("data", ondata);
					this.removeListener("end", onend);
					reject(er);
				};
				const ondata = (value) => {
					this.removeListener("error", onerr);
					this.removeListener("end", onend);
					this.pause();
					resolve$2({
						value,
						done: !!this[EOF$1]
					});
				};
				const onend = () => {
					this.removeListener("error", onerr);
					this.removeListener("data", ondata);
					resolve$2({ done: true });
				};
				const ondestroy = () => onerr(new Error("stream destroyed"));
				return new Promise((res$1, rej) => {
					reject = rej;
					resolve$2 = res$1;
					this.once(DESTROYED, ondestroy);
					this.once("error", onerr);
					this.once("end", onend);
					this.once("data", ondata);
				});
			};
			return { next };
		}
		[ITERATOR]() {
			const next = () => {
				const value = this.read();
				const done = value === null;
				return {
					value,
					done
				};
			};
			return { next };
		}
		destroy(er) {
			if (this[DESTROYED]) {
				if (er) this.emit("error", er);
else this.emit(DESTROYED);
				return this;
			}
			this[DESTROYED] = true;
			this.buffer = new yallist();
			this[BUFFERLENGTH] = 0;
			if (typeof this.close === "function" && !this[CLOSED]) this.close();
			if (er) this.emit("error", er);
else this.emit(DESTROYED);
			return this;
		}
		static isStream(s$1) {
			return !!s$1 && (s$1 instanceof Minipass || s$1 instanceof Stream__default["default"] || s$1 instanceof Events__default["default"] && (typeof s$1.pipe === "function" || typeof s$1.write === "function" && typeof s$1.end === "function"));
		}
	};
	const realZlibConstants = realZlib__default["default"].constants || { ZLIB_VERNUM: 4736 };
	var constants$2 = Object.freeze(Object.assign(Object.create(null), {
		Z_NO_FLUSH: 0,
		Z_PARTIAL_FLUSH: 1,
		Z_SYNC_FLUSH: 2,
		Z_FULL_FLUSH: 3,
		Z_FINISH: 4,
		Z_BLOCK: 5,
		Z_OK: 0,
		Z_STREAM_END: 1,
		Z_NEED_DICT: 2,
		Z_ERRNO: -1,
		Z_STREAM_ERROR: -2,
		Z_DATA_ERROR: -3,
		Z_MEM_ERROR: -4,
		Z_BUF_ERROR: -5,
		Z_VERSION_ERROR: -6,
		Z_NO_COMPRESSION: 0,
		Z_BEST_SPEED: 1,
		Z_BEST_COMPRESSION: 9,
		Z_DEFAULT_COMPRESSION: -1,
		Z_FILTERED: 1,
		Z_HUFFMAN_ONLY: 2,
		Z_RLE: 3,
		Z_FIXED: 4,
		Z_DEFAULT_STRATEGY: 0,
		DEFLATE: 1,
		INFLATE: 2,
		GZIP: 3,
		GUNZIP: 4,
		DEFLATERAW: 5,
		INFLATERAW: 6,
		UNZIP: 7,
		BROTLI_DECODE: 8,
		BROTLI_ENCODE: 9,
		Z_MIN_WINDOWBITS: 8,
		Z_MAX_WINDOWBITS: 15,
		Z_DEFAULT_WINDOWBITS: 15,
		Z_MIN_CHUNK: 64,
		Z_MAX_CHUNK: Infinity,
		Z_DEFAULT_CHUNK: 16384,
		Z_MIN_MEMLEVEL: 1,
		Z_MAX_MEMLEVEL: 9,
		Z_DEFAULT_MEMLEVEL: 8,
		Z_MIN_LEVEL: -1,
		Z_MAX_LEVEL: 9,
		Z_DEFAULT_LEVEL: -1,
		BROTLI_OPERATION_PROCESS: 0,
		BROTLI_OPERATION_FLUSH: 1,
		BROTLI_OPERATION_FINISH: 2,
		BROTLI_OPERATION_EMIT_METADATA: 3,
		BROTLI_MODE_GENERIC: 0,
		BROTLI_MODE_TEXT: 1,
		BROTLI_MODE_FONT: 2,
		BROTLI_DEFAULT_MODE: 0,
		BROTLI_MIN_QUALITY: 0,
		BROTLI_MAX_QUALITY: 11,
		BROTLI_DEFAULT_QUALITY: 11,
		BROTLI_MIN_WINDOW_BITS: 10,
		BROTLI_MAX_WINDOW_BITS: 24,
		BROTLI_LARGE_MAX_WINDOW_BITS: 30,
		BROTLI_DEFAULT_WINDOW: 22,
		BROTLI_MIN_INPUT_BLOCK_BITS: 16,
		BROTLI_MAX_INPUT_BLOCK_BITS: 24,
		BROTLI_PARAM_MODE: 0,
		BROTLI_PARAM_QUALITY: 1,
		BROTLI_PARAM_LGWIN: 2,
		BROTLI_PARAM_LGBLOCK: 3,
		BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
		BROTLI_PARAM_SIZE_HINT: 5,
		BROTLI_PARAM_LARGE_WINDOW: 6,
		BROTLI_PARAM_NPOSTFIX: 7,
		BROTLI_PARAM_NDIRECT: 8,
		BROTLI_DECODER_RESULT_ERROR: 0,
		BROTLI_DECODER_RESULT_SUCCESS: 1,
		BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
		BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
		BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
		BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
		BROTLI_DECODER_NO_ERROR: 0,
		BROTLI_DECODER_SUCCESS: 1,
		BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
		BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
		BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
		BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
		BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
		BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
		BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
		BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
		BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
		BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
		BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
		BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
		BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
		BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
		BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
		BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
		BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
		BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
		BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
		BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
		BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
		BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
		BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
		BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
		BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
		BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
		BROTLI_DECODER_ERROR_UNREACHABLE: -31
	}, realZlibConstants));
	var minizlib = createCommonjsModule(function(module$1, exports$1) {
		const Buffer$1 = require$$0__default$1["default"].Buffer;
		const constants$1$1 = exports$1.constants = constants$2;
		const OriginalBufferConcat = Buffer$1.concat;
		const _superWrite = Symbol("_superWrite");
		class ZlibError extends Error {
			constructor(err) {
				super("zlib: " + err.message);
				this.code = err.code;
				this.errno = err.errno;
				if (!this.code) this.code = "ZLIB_ERROR";
				this.message = "zlib: " + err.message;
				Error.captureStackTrace(this, this.constructor);
			}
			get name() {
				return "ZlibError";
			}
		}
		const _opts = Symbol("opts");
		const _flushFlag = Symbol("flushFlag");
		const _finishFlushFlag = Symbol("finishFlushFlag");
		const _fullFlushFlag = Symbol("fullFlushFlag");
		const _handle = Symbol("handle");
		const _onError = Symbol("onError");
		const _sawError = Symbol("sawError");
		const _level = Symbol("level");
		const _strategy = Symbol("strategy");
		const _ended$1 = Symbol("ended");
		class ZlibBase extends minipass {
			constructor(opts, mode) {
				if (!opts || typeof opts !== "object") throw new TypeError("invalid options for ZlibBase constructor");
				super(opts);
				this[_sawError] = false;
				this[_ended$1] = false;
				this[_opts] = opts;
				this[_flushFlag] = opts.flush;
				this[_finishFlushFlag] = opts.finishFlush;
				try {
					this[_handle] = new realZlib__default["default"][mode](opts);
				} catch (er) {
					throw new ZlibError(er);
				}
				this[_onError] = (err) => {
					if (this[_sawError]) return;
					this[_sawError] = true;
					this.close();
					this.emit("error", err);
				};
				this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
				this.once("end", () => this.close);
			}
			close() {
				if (this[_handle]) {
					this[_handle].close();
					this[_handle] = null;
					this.emit("close");
				}
			}
			reset() {
				if (!this[_sawError]) {
					assert__default["default"](this[_handle], "zlib binding closed");
					return this[_handle].reset();
				}
			}
			flush(flushFlag) {
				if (this.ended) return;
				if (typeof flushFlag !== "number") flushFlag = this[_fullFlushFlag];
				this.write(Object.assign(Buffer$1.alloc(0), { [_flushFlag]: flushFlag }));
			}
			end(chunk, encoding, cb) {
				if (chunk) this.write(chunk, encoding);
				this.flush(this[_finishFlushFlag]);
				this[_ended$1] = true;
				return super.end(null, null, cb);
			}
			get ended() {
				return this[_ended$1];
			}
			write(chunk, encoding, cb) {
				if (typeof encoding === "function") cb = encoding, encoding = "utf8";
				if (typeof chunk === "string") chunk = Buffer$1.from(chunk, encoding);
				if (this[_sawError]) return;
				assert__default["default"](this[_handle], "zlib binding closed");
				const nativeHandle = this[_handle]._handle;
				const originalNativeClose = nativeHandle.close;
				nativeHandle.close = () => {};
				const originalClose = this[_handle].close;
				this[_handle].close = () => {};
				Buffer$1.concat = (args) => args;
				let result;
				try {
					const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
					result = this[_handle]._processChunk(chunk, flushFlag);
					Buffer$1.concat = OriginalBufferConcat;
				} catch (err) {
					Buffer$1.concat = OriginalBufferConcat;
					this[_onError](new ZlibError(err));
				} finally {
					if (this[_handle]) {
						this[_handle]._handle = nativeHandle;
						nativeHandle.close = originalNativeClose;
						this[_handle].close = originalClose;
						this[_handle].removeAllListeners("error");
					}
				}
				if (this[_handle]) this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
				let writeReturn;
				if (result) if (Array.isArray(result) && result.length > 0) {
					writeReturn = this[_superWrite](Buffer$1.from(result[0]));
					for (let i = 1; i < result.length; i++) writeReturn = this[_superWrite](result[i]);
				} else writeReturn = this[_superWrite](Buffer$1.from(result));
				if (cb) cb();
				return writeReturn;
			}
			[_superWrite](data) {
				return super.write(data);
			}
		}
		class Zlib extends ZlibBase {
			constructor(opts, mode) {
				opts = opts || {};
				opts.flush = opts.flush || constants$1$1.Z_NO_FLUSH;
				opts.finishFlush = opts.finishFlush || constants$1$1.Z_FINISH;
				super(opts, mode);
				this[_fullFlushFlag] = constants$1$1.Z_FULL_FLUSH;
				this[_level] = opts.level;
				this[_strategy] = opts.strategy;
			}
			params(level, strategy) {
				if (this[_sawError]) return;
				if (!this[_handle]) throw new Error("cannot switch params when binding is closed");
				if (!this[_handle].params) throw new Error("not supported in this implementation");
				if (this[_level] !== level || this[_strategy] !== strategy) {
					this.flush(constants$1$1.Z_SYNC_FLUSH);
					assert__default["default"](this[_handle], "zlib binding closed");
					const origFlush = this[_handle].flush;
					this[_handle].flush = (flushFlag, cb) => {
						this.flush(flushFlag);
						cb();
					};
					try {
						this[_handle].params(level, strategy);
					} finally {
						this[_handle].flush = origFlush;
					}
					if (this[_handle]) {
						this[_level] = level;
						this[_strategy] = strategy;
					}
				}
			}
		}
		class Deflate extends Zlib {
			constructor(opts) {
				super(opts, "Deflate");
			}
		}
		class Inflate extends Zlib {
			constructor(opts) {
				super(opts, "Inflate");
			}
		}
		const _portable = Symbol("_portable");
		class Gzip extends Zlib {
			constructor(opts) {
				super(opts, "Gzip");
				this[_portable] = opts && !!opts.portable;
			}
			[_superWrite](data) {
				if (!this[_portable]) return super[_superWrite](data);
				this[_portable] = false;
				data[9] = 255;
				return super[_superWrite](data);
			}
		}
		class Gunzip extends Zlib {
			constructor(opts) {
				super(opts, "Gunzip");
			}
		}
		class DeflateRaw extends Zlib {
			constructor(opts) {
				super(opts, "DeflateRaw");
			}
		}
		class InflateRaw extends Zlib {
			constructor(opts) {
				super(opts, "InflateRaw");
			}
		}
		class Unzip extends Zlib {
			constructor(opts) {
				super(opts, "Unzip");
			}
		}
		class Brotli extends ZlibBase {
			constructor(opts, mode) {
				opts = opts || {};
				opts.flush = opts.flush || constants$1$1.BROTLI_OPERATION_PROCESS;
				opts.finishFlush = opts.finishFlush || constants$1$1.BROTLI_OPERATION_FINISH;
				super(opts, mode);
				this[_fullFlushFlag] = constants$1$1.BROTLI_OPERATION_FLUSH;
			}
		}
		class BrotliCompress extends Brotli {
			constructor(opts) {
				super(opts, "BrotliCompress");
			}
		}
		class BrotliDecompress extends Brotli {
			constructor(opts) {
				super(opts, "BrotliDecompress");
			}
		}
		exports$1.Deflate = Deflate;
		exports$1.Inflate = Inflate;
		exports$1.Gzip = Gzip;
		exports$1.Gunzip = Gunzip;
		exports$1.DeflateRaw = DeflateRaw;
		exports$1.InflateRaw = InflateRaw;
		exports$1.Unzip = Unzip;
		if (typeof realZlib__default["default"].BrotliCompress === "function") {
			exports$1.BrotliCompress = BrotliCompress;
			exports$1.BrotliDecompress = BrotliDecompress;
		} else exports$1.BrotliCompress = exports$1.BrotliDecompress = class {
			constructor() {
				throw new Error("Brotli is not supported in this version of Node.js");
			}
		};
	});
	const SLURP$1 = Symbol("slurp");
	var readEntry = class ReadEntry extends minipass {
		constructor(header$1, ex, gex) {
			super();
			this.pause();
			this.extended = ex;
			this.globalExtended = gex;
			this.header = header$1;
			this.startBlockSize = 512 * Math.ceil(header$1.size / 512);
			this.blockRemain = this.startBlockSize;
			this.remain = header$1.size;
			this.type = header$1.type;
			this.meta = false;
			this.ignore = false;
			switch (this.type) {
				case "File":
				case "OldFile":
				case "Link":
				case "SymbolicLink":
				case "CharacterDevice":
				case "BlockDevice":
				case "Directory":
				case "FIFO":
				case "ContiguousFile":
				case "GNUDumpDir": break;
				case "NextFileHasLongLinkpath":
				case "NextFileHasLongPath":
				case "OldGnuLongPath":
				case "GlobalExtendedHeader":
				case "ExtendedHeader":
				case "OldExtendedHeader":
					this.meta = true;
					break;
				default: this.ignore = true;
			}
			this.path = header$1.path;
			this.mode = header$1.mode;
			if (this.mode) this.mode = this.mode & 4095;
			this.uid = header$1.uid;
			this.gid = header$1.gid;
			this.uname = header$1.uname;
			this.gname = header$1.gname;
			this.size = header$1.size;
			this.mtime = header$1.mtime;
			this.atime = header$1.atime;
			this.ctime = header$1.ctime;
			this.linkpath = header$1.linkpath;
			this.uname = header$1.uname;
			this.gname = header$1.gname;
			if (ex) this[SLURP$1](ex);
			if (gex) this[SLURP$1](gex, true);
		}
		write(data) {
			const writeLen = data.length;
			if (writeLen > this.blockRemain) throw new Error("writing more to entry than is appropriate");
			const r = this.remain;
			const br = this.blockRemain;
			this.remain = Math.max(0, r - writeLen);
			this.blockRemain = Math.max(0, br - writeLen);
			if (this.ignore) return true;
			if (r >= writeLen) return super.write(data);
			return super.write(data.slice(0, r));
		}
		[SLURP$1](ex, global$1) {
			for (const k in ex) if (ex[k] !== null && ex[k] !== undefined && !(global$1 && k === "path")) this[k] = ex[k];
		}
	};
	var types = createCommonjsModule(function(module$1, exports$1) {
		exports$1.name = new Map([
			["0", "File"],
			["", "OldFile"],
			["1", "Link"],
			["2", "SymbolicLink"],
			["3", "CharacterDevice"],
			["4", "BlockDevice"],
			["5", "Directory"],
			["6", "FIFO"],
			["7", "ContiguousFile"],
			["g", "GlobalExtendedHeader"],
			["x", "ExtendedHeader"],
			["A", "SolarisACL"],
			["D", "GNUDumpDir"],
			["I", "Inode"],
			["K", "NextFileHasLongLinkpath"],
			["L", "NextFileHasLongPath"],
			["M", "ContinuationFile"],
			["N", "OldGnuLongPath"],
			["S", "SparseFile"],
			["V", "TapeVolumeHeader"],
			["X", "OldExtendedHeader"]
		]);
		exports$1.code = new Map(Array.from(exports$1.name).map((kv) => [kv[1], kv[0]]));
	});
	const encode = (num, buf) => {
		if (!Number.isSafeInteger(num)) throw Error("cannot encode number outside of javascript safe integer range");
else if (num < 0) encodeNegative(num, buf);
else encodePositive(num, buf);
		return buf;
	};
	const encodePositive = (num, buf) => {
		buf[0] = 128;
		for (var i = buf.length; i > 1; i--) {
			buf[i - 1] = num & 255;
			num = Math.floor(num / 256);
		}
	};
	const encodeNegative = (num, buf) => {
		buf[0] = 255;
		var flipped = false;
		num = num * -1;
		for (var i = buf.length; i > 1; i--) {
			var byte = num & 255;
			num = Math.floor(num / 256);
			if (flipped) buf[i - 1] = onesComp(byte);
else if (byte === 0) buf[i - 1] = 0;
else {
				flipped = true;
				buf[i - 1] = twosComp(byte);
			}
		}
	};
	const parse$5 = (buf) => {
		const pre = buf[0];
		const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
		if (value === null) throw Error("invalid base256 encoding");
		if (!Number.isSafeInteger(value)) throw Error("parsed number outside of javascript safe integer range");
		return value;
	};
	const twos = (buf) => {
		var len = buf.length;
		var sum = 0;
		var flipped = false;
		for (var i = len - 1; i > -1; i--) {
			var byte = buf[i];
			var f;
			if (flipped) f = onesComp(byte);
else if (byte === 0) f = byte;
else {
				flipped = true;
				f = twosComp(byte);
			}
			if (f !== 0) sum -= f * Math.pow(256, len - i - 1);
		}
		return sum;
	};
	const pos = (buf) => {
		var len = buf.length;
		var sum = 0;
		for (var i = len - 1; i > -1; i--) {
			var byte = buf[i];
			if (byte !== 0) sum += byte * Math.pow(256, len - i - 1);
		}
		return sum;
	};
	const onesComp = (byte) => (255 ^ byte) & 255;
	const twosComp = (byte) => (255 ^ byte) + 1 & 255;
	var largeNumbers = {
		encode,
		parse: parse$5
	};
	const pathModule = path__default["default"].posix;
	const SLURP = Symbol("slurp");
	const TYPE = Symbol("type");
	var Header = class {
		constructor(data, off, ex, gex) {
			this.cksumValid = false;
			this.needPax = false;
			this.nullBlock = false;
			this.block = null;
			this.path = null;
			this.mode = null;
			this.uid = null;
			this.gid = null;
			this.size = null;
			this.mtime = null;
			this.cksum = null;
			this[TYPE] = "0";
			this.linkpath = null;
			this.uname = null;
			this.gname = null;
			this.devmaj = 0;
			this.devmin = 0;
			this.atime = null;
			this.ctime = null;
			if (Buffer.isBuffer(data)) this.decode(data, off || 0, ex, gex);
else if (data) this.set(data);
		}
		decode(buf, off, ex, gex) {
			if (!off) off = 0;
			if (!buf || !(buf.length >= off + 512)) throw new Error("need 512 bytes for header");
			this.path = decString(buf, off, 100);
			this.mode = decNumber(buf, off + 100, 8);
			this.uid = decNumber(buf, off + 108, 8);
			this.gid = decNumber(buf, off + 116, 8);
			this.size = decNumber(buf, off + 124, 12);
			this.mtime = decDate(buf, off + 136, 12);
			this.cksum = decNumber(buf, off + 148, 12);
			this[SLURP](ex);
			this[SLURP](gex, true);
			this[TYPE] = decString(buf, off + 156, 1);
			if (this[TYPE] === "") this[TYPE] = "0";
			if (this[TYPE] === "0" && this.path.substr(-1) === "/") this[TYPE] = "5";
			if (this[TYPE] === "5") this.size = 0;
			this.linkpath = decString(buf, off + 157, 100);
			if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
				this.uname = decString(buf, off + 265, 32);
				this.gname = decString(buf, off + 297, 32);
				this.devmaj = decNumber(buf, off + 329, 8);
				this.devmin = decNumber(buf, off + 337, 8);
				if (buf[off + 475] !== 0) {
					const prefix = decString(buf, off + 345, 155);
					this.path = prefix + "/" + this.path;
				} else {
					const prefix = decString(buf, off + 345, 130);
					if (prefix) this.path = prefix + "/" + this.path;
					this.atime = decDate(buf, off + 476, 12);
					this.ctime = decDate(buf, off + 488, 12);
				}
			}
			let sum = 256;
			for (let i = off; i < off + 148; i++) sum += buf[i];
			for (let i = off + 156; i < off + 512; i++) sum += buf[i];
			this.cksumValid = sum === this.cksum;
			if (this.cksum === null && sum === 256) this.nullBlock = true;
		}
		[SLURP](ex, global$1) {
			for (const k in ex) if (ex[k] !== null && ex[k] !== undefined && !(global$1 && k === "path")) this[k] = ex[k];
		}
		encode(buf, off) {
			if (!buf) {
				buf = this.block = Buffer.alloc(512);
				off = 0;
			}
			if (!off) off = 0;
			if (!(buf.length >= off + 512)) throw new Error("need 512 bytes for header");
			const prefixSize = this.ctime || this.atime ? 130 : 155;
			const split$2 = splitPrefix(this.path || "", prefixSize);
			const path$3 = split$2[0];
			const prefix = split$2[1];
			this.needPax = split$2[2];
			this.needPax = encString(buf, off, 100, path$3) || this.needPax;
			this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
			this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
			this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
			this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
			this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
			buf[off + 156] = this[TYPE].charCodeAt(0);
			this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
			buf.write("ustar\x0000", off + 257, 8);
			this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
			this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
			this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
			this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
			this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
			if (buf[off + 475] !== 0) this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
else {
				this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
				this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
				this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
			}
			let sum = 256;
			for (let i = off; i < off + 148; i++) sum += buf[i];
			for (let i = off + 156; i < off + 512; i++) sum += buf[i];
			this.cksum = sum;
			encNumber(buf, off + 148, 8, this.cksum);
			this.cksumValid = true;
			return this.needPax;
		}
		set(data) {
			for (const i in data) if (data[i] !== null && data[i] !== undefined) this[i] = data[i];
		}
		get type() {
			return types.name.get(this[TYPE]) || this[TYPE];
		}
		get typeKey() {
			return this[TYPE];
		}
		set type(type) {
			if (types.code.has(type)) this[TYPE] = types.code.get(type);
else this[TYPE] = type;
		}
	};
	const splitPrefix = (p, prefixSize) => {
		const pathSize = 100;
		let pp = p;
		let prefix = "";
		let ret;
		const root = pathModule.parse(p).root || ".";
		if (Buffer.byteLength(pp) < pathSize) ret = [
			pp,
			prefix,
			false
		];
else {
			prefix = pathModule.dirname(pp);
			pp = pathModule.basename(pp);
			do 
				if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) ret = [
					pp,
					prefix,
					false
				];
else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) ret = [
					pp.substr(0, pathSize - 1),
					prefix,
					true
				];
else {
					pp = pathModule.join(pathModule.basename(prefix), pp);
					prefix = pathModule.dirname(prefix);
				}
			while (prefix !== root && !ret);
			if (!ret) ret = [
				p.substr(0, pathSize - 1),
				"",
				true
			];
		}
		return ret;
	};
	const decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
	const decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
	const numToDate = (num) => num === null ? null : new Date(num * 1e3);
	const decNumber = (buf, off, size) => buf[off] & 128 ? largeNumbers.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
	const nanNull = (value) => isNaN(value) ? null : value;
	const decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
	const MAXNUM = {
		12: 8589934591,
		8: 2097151
	};
	const encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (largeNumbers.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
	const encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
	const octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
	const padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
	const encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
	const NULLS = new Array(156).join("\0");
	const encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
	var header = Header;
	var Pax = class {
		constructor(obj, global$1) {
			this.atime = obj.atime || null;
			this.charset = obj.charset || null;
			this.comment = obj.comment || null;
			this.ctime = obj.ctime || null;
			this.gid = obj.gid || null;
			this.gname = obj.gname || null;
			this.linkpath = obj.linkpath || null;
			this.mtime = obj.mtime || null;
			this.path = obj.path || null;
			this.size = obj.size || null;
			this.uid = obj.uid || null;
			this.uname = obj.uname || null;
			this.dev = obj.dev || null;
			this.ino = obj.ino || null;
			this.nlink = obj.nlink || null;
			this.global = global$1 || false;
		}
		encode() {
			const body = this.encodeBody();
			if (body === "") return null;
			const bodyLen = Buffer.byteLength(body);
			const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
			const buf = Buffer.allocUnsafe(bufLen);
			for (let i = 0; i < 512; i++) buf[i] = 0;
			new header({
				path: ("PaxHeader/" + path__default["default"].basename(this.path)).slice(0, 99),
				mode: this.mode || 420,
				uid: this.uid || null,
				gid: this.gid || null,
				size: bodyLen,
				mtime: this.mtime || null,
				type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
				linkpath: "",
				uname: this.uname || "",
				gname: this.gname || "",
				devmaj: 0,
				devmin: 0,
				atime: this.atime || null,
				ctime: this.ctime || null
			}).encode(buf);
			buf.write(body, 512, bodyLen, "utf8");
			for (let i = bodyLen + 512; i < buf.length; i++) buf[i] = 0;
			return buf;
		}
		encodeBody() {
			return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
		}
		encodeField(field) {
			if (this[field] === null || this[field] === undefined) return "";
			const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
			const s$1 = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
			const byteLen = Buffer.byteLength(s$1);
			let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
			if (byteLen + digits >= Math.pow(10, digits)) digits += 1;
			const len = digits + byteLen;
			return len + s$1;
		}
	};
	Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g);
	const merge = (a, b) => b ? Object.keys(a).reduce((s$1, k) => (s$1[k] = a[k], s$1), b) : a;
	const parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, Object.create(null));
	const parseKVLine = (set, line) => {
		const n = parseInt(line, 10);
		if (n !== Buffer.byteLength(line) + 1) return set;
		line = line.substr((n + " ").length);
		const kv = line.split("=");
		const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
		if (!k) return set;
		const v = kv.join("=");
		set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
		return set;
	};
	var pax = Pax;
	var warnMixin = (Base) => class extends Base {
		warn(code, message, data = {}) {
			if (this.file) data.file = this.file;
			if (this.cwd) data.cwd = this.cwd;
			data.code = message instanceof Error && message.code || code;
			data.tarCode = code;
			if (!this.strict && data.recoverable !== false) {
				if (message instanceof Error) {
					data = Object.assign(message, data);
					message = message.message;
				}
				this.emit("warn", data.tarCode, message, data);
			} else if (message instanceof Error) this.emit("error", Object.assign(message, data));
else this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
		}
	};
	const raw = [
		"|",
		"<",
		">",
		"?",
		":"
	];
	const win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
	const toWin = new Map(raw.map((char, i) => [char, win[i]]));
	const toRaw = new Map(win.map((char, i) => [char, raw[i]]));
	var winchars = {
		encode: (s$1) => raw.reduce((s$2, c) => s$2.split(c).join(toWin.get(c)), s$1),
		decode: (s$1) => win.reduce((s$2, c) => s$2.split(c).join(toRaw.get(c)), s$1)
	};
	var modeFix = (mode, isDir, portable) => {
		mode &= 4095;
		if (portable) mode = (mode | 384) & -19;
		if (isDir) {
			if (mode & 256) mode |= 64;
			if (mode & 32) mode |= 8;
			if (mode & 4) mode |= 1;
		}
		return mode;
	};
	const maxReadSize = 16777216;
	const PROCESS$1 = Symbol("process");
	const FILE$1 = Symbol("file");
	const DIRECTORY$1 = Symbol("directory");
	const SYMLINK$1 = Symbol("symlink");
	const HARDLINK$1 = Symbol("hardlink");
	const HEADER = Symbol("header");
	const READ = Symbol("read");
	const LSTAT = Symbol("lstat");
	const ONLSTAT = Symbol("onlstat");
	const ONREAD = Symbol("onread");
	const ONREADLINK = Symbol("onreadlink");
	const OPENFILE = Symbol("openfile");
	const ONOPENFILE = Symbol("onopenfile");
	const CLOSE = Symbol("close");
	const MODE = Symbol("mode");
	const WriteEntry = warnMixin(class WriteEntry$1 extends minipass {
		constructor(p, opt) {
			opt = opt || {};
			super(opt);
			if (typeof p !== "string") throw new TypeError("path is required");
			this.path = p;
			this.portable = !!opt.portable;
			this.myuid = process.getuid && process.getuid();
			this.myuser = process.env.USER || "";
			this.maxReadSize = opt.maxReadSize || maxReadSize;
			this.linkCache = opt.linkCache || new Map();
			this.statCache = opt.statCache || new Map();
			this.preservePaths = !!opt.preservePaths;
			this.cwd = opt.cwd || process.cwd();
			this.strict = !!opt.strict;
			this.noPax = !!opt.noPax;
			this.noMtime = !!opt.noMtime;
			this.mtime = opt.mtime || null;
			if (typeof opt.onwarn === "function") this.on("warn", opt.onwarn);
			let pathWarn = false;
			if (!this.preservePaths && path__default["default"].win32.isAbsolute(p)) {
				const parsed = path__default["default"].win32.parse(p);
				this.path = p.substr(parsed.root.length);
				pathWarn = parsed.root;
			}
			this.win32 = !!opt.win32 || process.platform === "win32";
			if (this.win32) {
				this.path = winchars.decode(this.path.replace(/\\/g, "/"));
				p = p.replace(/\\/g, "/");
			}
			this.absolute = opt.absolute || path__default["default"].resolve(this.cwd, p);
			if (this.path === "") this.path = "./";
			if (pathWarn) this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
				entry: this,
				path: pathWarn + this.path
			});
			if (this.statCache.has(this.absolute)) this[ONLSTAT](this.statCache.get(this.absolute));
else this[LSTAT]();
		}
		[LSTAT]() {
			fs__default["default"].lstat(this.absolute, (er, stat) => {
				if (er) return this.emit("error", er);
				this[ONLSTAT](stat);
			});
		}
		[ONLSTAT](stat) {
			this.statCache.set(this.absolute, stat);
			this.stat = stat;
			if (!stat.isFile()) stat.size = 0;
			this.type = getType(stat);
			this.emit("stat", stat);
			this[PROCESS$1]();
		}
		[PROCESS$1]() {
			switch (this.type) {
				case "File": return this[FILE$1]();
				case "Directory": return this[DIRECTORY$1]();
				case "SymbolicLink": return this[SYMLINK$1]();
				default: return this.end();
			}
		}
		[MODE](mode) {
			return modeFix(mode, this.type === "Directory", this.portable);
		}
		[HEADER]() {
			if (this.type === "Directory" && this.portable) this.noMtime = true;
			this.header = new header({
				path: this.path,
				linkpath: this.linkpath,
				mode: this[MODE](this.stat.mode),
				uid: this.portable ? null : this.stat.uid,
				gid: this.portable ? null : this.stat.gid,
				size: this.stat.size,
				mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
				type: this.type,
				uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
				atime: this.portable ? null : this.stat.atime,
				ctime: this.portable ? null : this.stat.ctime
			});
			if (this.header.encode() && !this.noPax) this.write(new pax({
				atime: this.portable ? null : this.header.atime,
				ctime: this.portable ? null : this.header.ctime,
				gid: this.portable ? null : this.header.gid,
				mtime: this.noMtime ? null : this.mtime || this.header.mtime,
				path: this.path,
				linkpath: this.linkpath,
				size: this.header.size,
				uid: this.portable ? null : this.header.uid,
				uname: this.portable ? null : this.header.uname,
				dev: this.portable ? null : this.stat.dev,
				ino: this.portable ? null : this.stat.ino,
				nlink: this.portable ? null : this.stat.nlink
			}).encode());
			this.write(this.header.block);
		}
		[DIRECTORY$1]() {
			if (this.path.substr(-1) !== "/") this.path += "/";
			this.stat.size = 0;
			this[HEADER]();
			this.end();
		}
		[SYMLINK$1]() {
			fs__default["default"].readlink(this.absolute, (er, linkpath) => {
				if (er) return this.emit("error", er);
				this[ONREADLINK](linkpath);
			});
		}
		[ONREADLINK](linkpath) {
			this.linkpath = linkpath.replace(/\\/g, "/");
			this[HEADER]();
			this.end();
		}
		[HARDLINK$1](linkpath) {
			this.type = "Link";
			this.linkpath = path__default["default"].relative(this.cwd, linkpath).replace(/\\/g, "/");
			this.stat.size = 0;
			this[HEADER]();
			this.end();
		}
		[FILE$1]() {
			if (this.stat.nlink > 1) {
				const linkKey = this.stat.dev + ":" + this.stat.ino;
				if (this.linkCache.has(linkKey)) {
					const linkpath = this.linkCache.get(linkKey);
					if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK$1](linkpath);
				}
				this.linkCache.set(linkKey, this.absolute);
			}
			this[HEADER]();
			if (this.stat.size === 0) return this.end();
			this[OPENFILE]();
		}
		[OPENFILE]() {
			fs__default["default"].open(this.absolute, "r", (er, fd) => {
				if (er) return this.emit("error", er);
				this[ONOPENFILE](fd);
			});
		}
		[ONOPENFILE](fd) {
			const blockLen = 512 * Math.ceil(this.stat.size / 512);
			const bufLen = Math.min(blockLen, this.maxReadSize);
			const buf = Buffer.allocUnsafe(bufLen);
			this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);
		}
		[READ](fd, buf, offset, length, pos$1, remain, blockRemain) {
			fs__default["default"].read(fd, buf, offset, length, pos$1, (er, bytesRead) => {
				if (er) return this[CLOSE](fd, () => this.emit("error", er));
				this[ONREAD](fd, buf, offset, length, pos$1, remain, blockRemain, bytesRead);
			});
		}
		[CLOSE](fd, cb) {
			fs__default["default"].close(fd, cb);
		}
		[ONREAD](fd, buf, offset, length, pos$1, remain, blockRemain, bytesRead) {
			if (bytesRead <= 0 && remain > 0) {
				const er = new Error("encountered unexpected EOF");
				er.path = this.absolute;
				er.syscall = "read";
				er.code = "EOF";
				return this[CLOSE](fd, () => this.emit("error", er));
			}
			if (bytesRead > remain) {
				const er = new Error("did not encounter expected EOF");
				er.path = this.absolute;
				er.syscall = "read";
				er.code = "EOF";
				return this[CLOSE](fd, () => this.emit("error", er));
			}
			if (bytesRead === remain) for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {
				buf[i + offset] = 0;
				bytesRead++;
				remain++;
			}
			const writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);
			remain -= bytesRead;
			blockRemain -= bytesRead;
			pos$1 += bytesRead;
			offset += bytesRead;
			this.write(writeBuf);
			if (!remain) {
				if (blockRemain) this.write(Buffer.alloc(blockRemain));
				return this[CLOSE](fd, (er) => er ? this.emit("error", er) : this.end());
			}
			if (offset >= length) {
				buf = Buffer.allocUnsafe(length);
				offset = 0;
			}
			length = buf.length - offset;
			this[READ](fd, buf, offset, length, pos$1, remain, blockRemain);
		}
	});
	var WriteEntrySync$1 = class extends WriteEntry {
		[LSTAT]() {
			this[ONLSTAT](fs__default["default"].lstatSync(this.absolute));
		}
		[SYMLINK$1]() {
			this[ONREADLINK](fs__default["default"].readlinkSync(this.absolute));
		}
		[OPENFILE]() {
			this[ONOPENFILE](fs__default["default"].openSync(this.absolute, "r"));
		}
		[READ](fd, buf, offset, length, pos$1, remain, blockRemain) {
			let threw = true;
			try {
				const bytesRead = fs__default["default"].readSync(fd, buf, offset, length, pos$1);
				this[ONREAD](fd, buf, offset, length, pos$1, remain, blockRemain, bytesRead);
				threw = false;
			} finally {
				if (threw) try {
					this[CLOSE](fd, () => {});
				} catch (er) {}
			}
		}
		[CLOSE](fd, cb) {
			fs__default["default"].closeSync(fd);
			cb();
		}
	};
	const WriteEntryTar$1 = warnMixin(class WriteEntryTar$2 extends minipass {
		constructor(readEntry$1, opt) {
			opt = opt || {};
			super(opt);
			this.preservePaths = !!opt.preservePaths;
			this.portable = !!opt.portable;
			this.strict = !!opt.strict;
			this.noPax = !!opt.noPax;
			this.noMtime = !!opt.noMtime;
			this.readEntry = readEntry$1;
			this.type = readEntry$1.type;
			if (this.type === "Directory" && this.portable) this.noMtime = true;
			this.path = readEntry$1.path;
			this.mode = this[MODE](readEntry$1.mode);
			this.uid = this.portable ? null : readEntry$1.uid;
			this.gid = this.portable ? null : readEntry$1.gid;
			this.uname = this.portable ? null : readEntry$1.uname;
			this.gname = this.portable ? null : readEntry$1.gname;
			this.size = readEntry$1.size;
			this.mtime = this.noMtime ? null : opt.mtime || readEntry$1.mtime;
			this.atime = this.portable ? null : readEntry$1.atime;
			this.ctime = this.portable ? null : readEntry$1.ctime;
			this.linkpath = readEntry$1.linkpath;
			if (typeof opt.onwarn === "function") this.on("warn", opt.onwarn);
			let pathWarn = false;
			if (path__default["default"].isAbsolute(this.path) && !this.preservePaths) {
				const parsed = path__default["default"].parse(this.path);
				pathWarn = parsed.root;
				this.path = this.path.substr(parsed.root.length);
			}
			this.remain = readEntry$1.size;
			this.blockRemain = readEntry$1.startBlockSize;
			this.header = new header({
				path: this.path,
				linkpath: this.linkpath,
				mode: this.mode,
				uid: this.portable ? null : this.uid,
				gid: this.portable ? null : this.gid,
				size: this.size,
				mtime: this.noMtime ? null : this.mtime,
				type: this.type,
				uname: this.portable ? null : this.uname,
				atime: this.portable ? null : this.atime,
				ctime: this.portable ? null : this.ctime
			});
			if (pathWarn) this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
				entry: this,
				path: pathWarn + this.path
			});
			if (this.header.encode() && !this.noPax) super.write(new pax({
				atime: this.portable ? null : this.atime,
				ctime: this.portable ? null : this.ctime,
				gid: this.portable ? null : this.gid,
				mtime: this.noMtime ? null : this.mtime,
				path: this.path,
				linkpath: this.linkpath,
				size: this.size,
				uid: this.portable ? null : this.uid,
				uname: this.portable ? null : this.uname,
				dev: this.portable ? null : this.readEntry.dev,
				ino: this.portable ? null : this.readEntry.ino,
				nlink: this.portable ? null : this.readEntry.nlink
			}).encode());
			super.write(this.header.block);
			readEntry$1.pipe(this);
		}
		[MODE](mode) {
			return modeFix(mode, this.type === "Directory", this.portable);
		}
		write(data) {
			const writeLen = data.length;
			if (writeLen > this.blockRemain) throw new Error("writing more to entry than is appropriate");
			this.blockRemain -= writeLen;
			return super.write(data);
		}
		end() {
			if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));
			return super.end();
		}
	});
	WriteEntry.Sync = WriteEntrySync$1;
	WriteEntry.Tar = WriteEntryTar$1;
	const getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
	var writeEntry = WriteEntry;
	var PackJob = class {
		constructor(path$3, absolute) {
			this.path = path$3 || "./";
			this.absolute = absolute;
			this.entry = null;
			this.stat = null;
			this.readdir = null;
			this.pending = false;
			this.ignore = false;
			this.piped = false;
		}
	};
	const WriteEntrySync = writeEntry.Sync;
	const WriteEntryTar = writeEntry.Tar;
	const EOF = Buffer.alloc(1024);
	const ONSTAT = Symbol("onStat");
	const ENDED$2 = Symbol("ended");
	const QUEUE$1 = Symbol("queue");
	const CURRENT = Symbol("current");
	const PROCESS = Symbol("process");
	const PROCESSING = Symbol("processing");
	const PROCESSJOB = Symbol("processJob");
	const JOBS = Symbol("jobs");
	const JOBDONE = Symbol("jobDone");
	const ADDFSENTRY = Symbol("addFSEntry");
	const ADDTARENTRY = Symbol("addTarEntry");
	const STAT = Symbol("stat");
	const READDIR = Symbol("readdir");
	const ONREADDIR = Symbol("onreaddir");
	const PIPE = Symbol("pipe");
	const ENTRY = Symbol("entry");
	const ENTRYOPT = Symbol("entryOpt");
	const WRITEENTRYCLASS = Symbol("writeEntryClass");
	const WRITE = Symbol("write");
	const ONDRAIN = Symbol("ondrain");
	const Pack = warnMixin(class Pack$1 extends minipass {
		constructor(opt) {
			super(opt);
			opt = opt || Object.create(null);
			this.opt = opt;
			this.file = opt.file || "";
			this.cwd = opt.cwd || process.cwd();
			this.maxReadSize = opt.maxReadSize;
			this.preservePaths = !!opt.preservePaths;
			this.strict = !!opt.strict;
			this.noPax = !!opt.noPax;
			this.prefix = (opt.prefix || "").replace(/(\\|\/)+$/, "");
			this.linkCache = opt.linkCache || new Map();
			this.statCache = opt.statCache || new Map();
			this.readdirCache = opt.readdirCache || new Map();
			this[WRITEENTRYCLASS] = writeEntry;
			if (typeof opt.onwarn === "function") this.on("warn", opt.onwarn);
			this.portable = !!opt.portable;
			this.zip = null;
			if (opt.gzip) {
				if (typeof opt.gzip !== "object") opt.gzip = {};
				if (this.portable) opt.gzip.portable = true;
				this.zip = new minizlib.Gzip(opt.gzip);
				this.zip.on("data", (chunk) => super.write(chunk));
				this.zip.on("end", (_) => super.end());
				this.zip.on("drain", (_) => this[ONDRAIN]());
				this.on("resume", (_) => this.zip.resume());
			} else this.on("drain", this[ONDRAIN]);
			this.noDirRecurse = !!opt.noDirRecurse;
			this.follow = !!opt.follow;
			this.noMtime = !!opt.noMtime;
			this.mtime = opt.mtime || null;
			this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
			this[QUEUE$1] = new yallist();
			this[JOBS] = 0;
			this.jobs = +opt.jobs || 4;
			this[PROCESSING] = false;
			this[ENDED$2] = false;
		}
		[WRITE](chunk) {
			return super.write(chunk);
		}
		add(path$3) {
			this.write(path$3);
			return this;
		}
		end(path$3) {
			if (path$3) this.write(path$3);
			this[ENDED$2] = true;
			this[PROCESS]();
			return this;
		}
		write(path$3) {
			if (this[ENDED$2]) throw new Error("write after end");
			if (path$3 instanceof readEntry) this[ADDTARENTRY](path$3);
else this[ADDFSENTRY](path$3);
			return this.flowing;
		}
		[ADDTARENTRY](p) {
			const absolute = path__default["default"].resolve(this.cwd, p.path);
			if (this.prefix) p.path = this.prefix + "/" + p.path.replace(/^\.(\/+|$)/, "");
			if (!this.filter(p.path, p)) p.resume();
else {
				const job = new PackJob(p.path, absolute, false);
				job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
				job.entry.on("end", (_) => this[JOBDONE](job));
				this[JOBS] += 1;
				this[QUEUE$1].push(job);
			}
			this[PROCESS]();
		}
		[ADDFSENTRY](p) {
			const absolute = path__default["default"].resolve(this.cwd, p);
			if (this.prefix) p = this.prefix + "/" + p.replace(/^\.(\/+|$)/, "");
			this[QUEUE$1].push(new PackJob(p, absolute));
			this[PROCESS]();
		}
		[STAT](job) {
			job.pending = true;
			this[JOBS] += 1;
			const stat = this.follow ? "stat" : "lstat";
			fs__default["default"][stat](job.absolute, (er, stat$1) => {
				job.pending = false;
				this[JOBS] -= 1;
				if (er) this.emit("error", er);
else this[ONSTAT](job, stat$1);
			});
		}
		[ONSTAT](job, stat) {
			this.statCache.set(job.absolute, stat);
			job.stat = stat;
			if (!this.filter(job.path, stat)) job.ignore = true;
			this[PROCESS]();
		}
		[READDIR](job) {
			job.pending = true;
			this[JOBS] += 1;
			fs__default["default"].readdir(job.absolute, (er, entries) => {
				job.pending = false;
				this[JOBS] -= 1;
				if (er) return this.emit("error", er);
				this[ONREADDIR](job, entries);
			});
		}
		[ONREADDIR](job, entries) {
			this.readdirCache.set(job.absolute, entries);
			job.readdir = entries;
			this[PROCESS]();
		}
		[PROCESS]() {
			if (this[PROCESSING]) return;
			this[PROCESSING] = true;
			for (let w$1 = this[QUEUE$1].head; w$1 !== null && this[JOBS] < this.jobs; w$1 = w$1.next) {
				this[PROCESSJOB](w$1.value);
				if (w$1.value.ignore) {
					const p = w$1.next;
					this[QUEUE$1].removeNode(w$1);
					w$1.next = p;
				}
			}
			this[PROCESSING] = false;
			if (this[ENDED$2] && !this[QUEUE$1].length && this[JOBS] === 0) if (this.zip) this.zip.end(EOF);
else {
				super.write(EOF);
				super.end();
			}
		}
		get [CURRENT]() {
			return this[QUEUE$1] && this[QUEUE$1].head && this[QUEUE$1].head.value;
		}
		[JOBDONE](job) {
			this[QUEUE$1].shift();
			this[JOBS] -= 1;
			this[PROCESS]();
		}
		[PROCESSJOB](job) {
			if (job.pending) return;
			if (job.entry) {
				if (job === this[CURRENT] && !job.piped) this[PIPE](job);
				return;
			}
			if (!job.stat) if (this.statCache.has(job.absolute)) this[ONSTAT](job, this.statCache.get(job.absolute));
else this[STAT](job);
			if (!job.stat) return;
			if (job.ignore) return;
			if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
				if (this.readdirCache.has(job.absolute)) this[ONREADDIR](job, this.readdirCache.get(job.absolute));
else this[READDIR](job);
				if (!job.readdir) return;
			}
			job.entry = this[ENTRY](job);
			if (!job.entry) {
				job.ignore = true;
				return;
			}
			if (job === this[CURRENT] && !job.piped) this[PIPE](job);
		}
		[ENTRYOPT](job) {
			return {
				onwarn: (code, msg, data) => this.warn(code, msg, data),
				noPax: this.noPax,
				cwd: this.cwd,
				absolute: job.absolute,
				preservePaths: this.preservePaths,
				maxReadSize: this.maxReadSize,
				strict: this.strict,
				portable: this.portable,
				linkCache: this.linkCache,
				statCache: this.statCache,
				noMtime: this.noMtime,
				mtime: this.mtime
			};
		}
		[ENTRY](job) {
			this[JOBS] += 1;
			try {
				return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
			} catch (er) {
				this.emit("error", er);
			}
		}
		[ONDRAIN]() {
			if (this[CURRENT] && this[CURRENT].entry) this[CURRENT].entry.resume();
		}
		[PIPE](job) {
			job.piped = true;
			if (job.readdir) job.readdir.forEach((entry) => {
				const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
				const base$1 = p === "./" ? "" : p.replace(/\/*$/, "/");
				this[ADDFSENTRY](base$1 + entry);
			});
			const source$1 = job.entry;
			const zip = this.zip;
			if (zip) source$1.on("data", (chunk) => {
				if (!zip.write(chunk)) source$1.pause();
			});
else source$1.on("data", (chunk) => {
				if (!super.write(chunk)) source$1.pause();
			});
		}
		pause() {
			if (this.zip) this.zip.pause();
			return super.pause();
		}
	});
	var PackSync = class extends Pack {
		constructor(opt) {
			super(opt);
			this[WRITEENTRYCLASS] = WriteEntrySync;
		}
		pause() {}
		resume() {}
		[STAT](job) {
			const stat = this.follow ? "statSync" : "lstatSync";
			this[ONSTAT](job, fs__default["default"][stat](job.absolute));
		}
		[READDIR](job, stat) {
			this[ONREADDIR](job, fs__default["default"].readdirSync(job.absolute));
		}
		[PIPE](job) {
			const source$1 = job.entry;
			const zip = this.zip;
			if (job.readdir) job.readdir.forEach((entry) => {
				const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
				const base$1 = p === "./" ? "" : p.replace(/\/*$/, "/");
				this[ADDFSENTRY](base$1 + entry);
			});
			if (zip) source$1.on("data", (chunk) => {
				zip.write(chunk);
			});
else source$1.on("data", (chunk) => {
				super[WRITE](chunk);
			});
		}
	};
	Pack.Sync = PackSync;
	var pack = Pack;
	const EE$1 = Events__default["default"].EventEmitter;
	let writev = fs__default["default"].writev;
	if (!writev) {
		const binding = process.binding("fs");
		const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
		writev = (fd, iovec, pos$1, cb) => {
			const done = (er, bw) => cb(er, bw, iovec);
			const req = new FSReqWrap();
			req.oncomplete = done;
			binding.writeBuffers(fd, iovec, pos$1, req);
		};
	}
	const _autoClose = Symbol("_autoClose");
	const _close = Symbol("_close");
	const _ended = Symbol("_ended");
	const _fd = Symbol("_fd");
	const _finished = Symbol("_finished");
	const _flags = Symbol("_flags");
	const _flush = Symbol("_flush");
	const _handleChunk = Symbol("_handleChunk");
	const _makeBuf = Symbol("_makeBuf");
	const _mode = Symbol("_mode");
	const _needDrain = Symbol("_needDrain");
	const _onerror = Symbol("_onerror");
	const _onopen = Symbol("_onopen");
	const _onread = Symbol("_onread");
	const _onwrite = Symbol("_onwrite");
	const _open = Symbol("_open");
	const _path = Symbol("_path");
	const _pos = Symbol("_pos");
	const _queue = Symbol("_queue");
	const _read = Symbol("_read");
	const _readSize = Symbol("_readSize");
	const _reading = Symbol("_reading");
	const _remain = Symbol("_remain");
	const _size = Symbol("_size");
	const _write = Symbol("_write");
	const _writing = Symbol("_writing");
	const _defaultFlag = Symbol("_defaultFlag");
	const _errored = Symbol("_errored");
	var ReadStream = class extends minipass {
		constructor(path$3, opt) {
			opt = opt || {};
			super(opt);
			this.readable = true;
			this.writable = false;
			if (typeof path$3 !== "string") throw new TypeError("path must be a string");
			this[_errored] = false;
			this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
			this[_path] = path$3;
			this[_readSize] = opt.readSize || 16777216;
			this[_reading] = false;
			this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
			this[_remain] = this[_size];
			this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
			if (typeof this[_fd] === "number") this[_read]();
else this[_open]();
		}
		get fd() {
			return this[_fd];
		}
		get path() {
			return this[_path];
		}
		write() {
			throw new TypeError("this is a readable stream");
		}
		end() {
			throw new TypeError("this is a readable stream");
		}
		[_open]() {
			fs__default["default"].open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
		}
		[_onopen](er, fd) {
			if (er) this[_onerror](er);
else {
				this[_fd] = fd;
				this.emit("open", fd);
				this[_read]();
			}
		}
		[_makeBuf]() {
			return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
		}
		[_read]() {
			if (!this[_reading]) {
				this[_reading] = true;
				const buf = this[_makeBuf]();
				if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf));
				fs__default["default"].read(this[_fd], buf, 0, buf.length, null, (er, br, buf$1) => this[_onread](er, br, buf$1));
			}
		}
		[_onread](er, br, buf) {
			this[_reading] = false;
			if (er) this[_onerror](er);
else if (this[_handleChunk](br, buf)) this[_read]();
		}
		[_close]() {
			if (this[_autoClose] && typeof this[_fd] === "number") {
				const fd = this[_fd];
				this[_fd] = null;
				fs__default["default"].close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
			}
		}
		[_onerror](er) {
			this[_reading] = true;
			this[_close]();
			this.emit("error", er);
		}
		[_handleChunk](br, buf) {
			let ret = false;
			this[_remain] -= br;
			if (br > 0) ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
			if (br === 0 || this[_remain] <= 0) {
				ret = false;
				this[_close]();
				super.end();
			}
			return ret;
		}
		emit(ev, data) {
			switch (ev) {
				case "prefinish":
				case "finish": break;
				case "drain":
					if (typeof this[_fd] === "number") this[_read]();
					break;
				case "error":
					if (this[_errored]) return;
					this[_errored] = true;
					return super.emit(ev, data);
				default: return super.emit(ev, data);
			}
		}
	};
	var ReadStreamSync = class extends ReadStream {
		[_open]() {
			let threw = true;
			try {
				this[_onopen](null, fs__default["default"].openSync(this[_path], "r"));
				threw = false;
			} finally {
				if (threw) this[_close]();
			}
		}
		[_read]() {
			let threw = true;
			try {
				if (!this[_reading]) {
					this[_reading] = true;
					do {
						const buf = this[_makeBuf]();
						const br = buf.length === 0 ? 0 : fs__default["default"].readSync(this[_fd], buf, 0, buf.length, null);
						if (!this[_handleChunk](br, buf)) break;
					} while (true);
					this[_reading] = false;
				}
				threw = false;
			} finally {
				if (threw) this[_close]();
			}
		}
		[_close]() {
			if (this[_autoClose] && typeof this[_fd] === "number") {
				const fd = this[_fd];
				this[_fd] = null;
				fs__default["default"].closeSync(fd);
				this.emit("close");
			}
		}
	};
	var WriteStream = class extends EE$1 {
		constructor(path$3, opt) {
			opt = opt || {};
			super(opt);
			this.readable = false;
			this.writable = true;
			this[_errored] = false;
			this[_writing] = false;
			this[_ended] = false;
			this[_needDrain] = false;
			this[_queue] = [];
			this[_path] = path$3;
			this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
			this[_mode] = opt.mode === undefined ? 438 : opt.mode;
			this[_pos] = typeof opt.start === "number" ? opt.start : null;
			this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
			const defaultFlag = this[_pos] !== null ? "r+" : "w";
			this[_defaultFlag] = opt.flags === undefined;
			this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
			if (this[_fd] === null) this[_open]();
		}
		emit(ev, data) {
			if (ev === "error") {
				if (this[_errored]) return;
				this[_errored] = true;
			}
			return super.emit(ev, data);
		}
		get fd() {
			return this[_fd];
		}
		get path() {
			return this[_path];
		}
		[_onerror](er) {
			this[_close]();
			this[_writing] = true;
			this.emit("error", er);
		}
		[_open]() {
			fs__default["default"].open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
		}
		[_onopen](er, fd) {
			if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
				this[_flags] = "w";
				this[_open]();
			} else if (er) this[_onerror](er);
else {
				this[_fd] = fd;
				this.emit("open", fd);
				this[_flush]();
			}
		}
		end(buf, enc) {
			if (buf) this.write(buf, enc);
			this[_ended] = true;
			if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number") this[_onwrite](null, 0);
			return this;
		}
		write(buf, enc) {
			if (typeof buf === "string") buf = Buffer.from(buf, enc);
			if (this[_ended]) {
				this.emit("error", new Error("write() after end()"));
				return false;
			}
			if (this[_fd] === null || this[_writing] || this[_queue].length) {
				this[_queue].push(buf);
				this[_needDrain] = true;
				return false;
			}
			this[_writing] = true;
			this[_write](buf);
			return true;
		}
		[_write](buf) {
			fs__default["default"].write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
		}
		[_onwrite](er, bw) {
			if (er) this[_onerror](er);
else {
				if (this[_pos] !== null) this[_pos] += bw;
				if (this[_queue].length) this[_flush]();
else {
					this[_writing] = false;
					if (this[_ended] && !this[_finished]) {
						this[_finished] = true;
						this[_close]();
						this.emit("finish");
					} else if (this[_needDrain]) {
						this[_needDrain] = false;
						this.emit("drain");
					}
				}
			}
		}
		[_flush]() {
			if (this[_queue].length === 0) {
				if (this[_ended]) this[_onwrite](null, 0);
			} else if (this[_queue].length === 1) this[_write](this[_queue].pop());
else {
				const iovec = this[_queue];
				this[_queue] = [];
				writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
			}
		}
		[_close]() {
			if (this[_autoClose] && typeof this[_fd] === "number") {
				const fd = this[_fd];
				this[_fd] = null;
				fs__default["default"].close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
			}
		}
	};
	var WriteStreamSync = class extends WriteStream {
		[_open]() {
			let fd;
			if (this[_defaultFlag] && this[_flags] === "r+") try {
				fd = fs__default["default"].openSync(this[_path], this[_flags], this[_mode]);
			} catch (er) {
				if (er.code === "ENOENT") {
					this[_flags] = "w";
					return this[_open]();
				} else throw er;
			}
else fd = fs__default["default"].openSync(this[_path], this[_flags], this[_mode]);
			this[_onopen](null, fd);
		}
		[_close]() {
			if (this[_autoClose] && typeof this[_fd] === "number") {
				const fd = this[_fd];
				this[_fd] = null;
				fs__default["default"].closeSync(fd);
				this.emit("close");
			}
		}
		[_write](buf) {
			let threw = true;
			try {
				this[_onwrite](null, fs__default["default"].writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
				threw = false;
			} finally {
				if (threw) try {
					this[_close]();
				} catch (_) {}
			}
		}
	};
	var ReadStream_1 = ReadStream;
	var ReadStreamSync_1 = ReadStreamSync;
	var WriteStream_1 = WriteStream;
	var WriteStreamSync_1 = WriteStreamSync;
	var fsMinipass = {
		ReadStream: ReadStream_1,
		ReadStreamSync: ReadStreamSync_1,
		WriteStream: WriteStream_1,
		WriteStreamSync: WriteStreamSync_1
	};
	const maxMetaEntrySize = 1048576;
	const gzipHeader = Buffer.from([31, 139]);
	const STATE = Symbol("state");
	const WRITEENTRY = Symbol("writeEntry");
	const READENTRY = Symbol("readEntry");
	const NEXTENTRY = Symbol("nextEntry");
	const PROCESSENTRY = Symbol("processEntry");
	const EX = Symbol("extendedHeader");
	const GEX = Symbol("globalExtendedHeader");
	const META = Symbol("meta");
	const EMITMETA = Symbol("emitMeta");
	const BUFFER = Symbol("buffer");
	const QUEUE = Symbol("queue");
	const ENDED$1 = Symbol("ended");
	const EMITTEDEND = Symbol("emittedEnd");
	const EMIT = Symbol("emit");
	const UNZIP = Symbol("unzip");
	const CONSUMECHUNK = Symbol("consumeChunk");
	const CONSUMECHUNKSUB = Symbol("consumeChunkSub");
	const CONSUMEBODY = Symbol("consumeBody");
	const CONSUMEMETA = Symbol("consumeMeta");
	const CONSUMEHEADER = Symbol("consumeHeader");
	const CONSUMING = Symbol("consuming");
	const BUFFERCONCAT = Symbol("bufferConcat");
	const MAYBEEND = Symbol("maybeEnd");
	const WRITING = Symbol("writing");
	const ABORTED = Symbol("aborted");
	const DONE = Symbol("onDone");
	const SAW_VALID_ENTRY = Symbol("sawValidEntry");
	const SAW_NULL_BLOCK = Symbol("sawNullBlock");
	const SAW_EOF = Symbol("sawEOF");
	const noop = (_) => true;
	var parse$4 = warnMixin(class Parser extends Events__default["default"] {
		constructor(opt) {
			opt = opt || {};
			super(opt);
			this.file = opt.file || "";
			this[SAW_VALID_ENTRY] = null;
			this.on(DONE, (_) => {
				if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
			});
			if (opt.ondone) this.on(DONE, opt.ondone);
else this.on(DONE, (_) => {
				this.emit("prefinish");
				this.emit("finish");
				this.emit("end");
				this.emit("close");
			});
			this.strict = !!opt.strict;
			this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
			this.filter = typeof opt.filter === "function" ? opt.filter : noop;
			this.writable = true;
			this.readable = false;
			this[QUEUE] = new yallist();
			this[BUFFER] = null;
			this[READENTRY] = null;
			this[WRITEENTRY] = null;
			this[STATE] = "begin";
			this[META] = "";
			this[EX] = null;
			this[GEX] = null;
			this[ENDED$1] = false;
			this[UNZIP] = null;
			this[ABORTED] = false;
			this[SAW_NULL_BLOCK] = false;
			this[SAW_EOF] = false;
			if (typeof opt.onwarn === "function") this.on("warn", opt.onwarn);
			if (typeof opt.onentry === "function") this.on("entry", opt.onentry);
		}
		[CONSUMEHEADER](chunk, position) {
			if (this[SAW_VALID_ENTRY] === null) this[SAW_VALID_ENTRY] = false;
			let header$1;
			try {
				header$1 = new header(chunk, position, this[EX], this[GEX]);
			} catch (er) {
				return this.warn("TAR_ENTRY_INVALID", er);
			}
			if (header$1.nullBlock) if (this[SAW_NULL_BLOCK]) {
				this[SAW_EOF] = true;
				if (this[STATE] === "begin") this[STATE] = "header";
				this[EMIT]("eof");
			} else {
				this[SAW_NULL_BLOCK] = true;
				this[EMIT]("nullBlock");
			}
else {
				this[SAW_NULL_BLOCK] = false;
				if (!header$1.cksumValid) this.warn("TAR_ENTRY_INVALID", "checksum failure", { header: header$1 });
else if (!header$1.path) this.warn("TAR_ENTRY_INVALID", "path is required", { header: header$1 });
else {
					const type = header$1.type;
					if (/^(Symbolic)?Link$/.test(type) && !header$1.linkpath) this.warn("TAR_ENTRY_INVALID", "linkpath required", { header: header$1 });
else if (!/^(Symbolic)?Link$/.test(type) && header$1.linkpath) this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header: header$1 });
else {
						const entry = this[WRITEENTRY] = new readEntry(header$1, this[EX], this[GEX]);
						if (!this[SAW_VALID_ENTRY]) if (entry.remain) {
							const onend = () => {
								if (!entry.invalid) this[SAW_VALID_ENTRY] = true;
							};
							entry.on("end", onend);
						} else this[SAW_VALID_ENTRY] = true;
						if (entry.meta) {
							if (entry.size > this.maxMetaEntrySize) {
								entry.ignore = true;
								this[EMIT]("ignoredEntry", entry);
								this[STATE] = "ignore";
								entry.resume();
							} else if (entry.size > 0) {
								this[META] = "";
								entry.on("data", (c) => this[META] += c);
								this[STATE] = "meta";
							}
						} else {
							this[EX] = null;
							entry.ignore = entry.ignore || !this.filter(entry.path, entry);
							if (entry.ignore) {
								this[EMIT]("ignoredEntry", entry);
								this[STATE] = entry.remain ? "ignore" : "header";
								entry.resume();
							} else {
								if (entry.remain) this[STATE] = "body";
else {
									this[STATE] = "header";
									entry.end();
								}
								if (!this[READENTRY]) {
									this[QUEUE].push(entry);
									this[NEXTENTRY]();
								} else this[QUEUE].push(entry);
							}
						}
					}
				}
			}
		}
		[PROCESSENTRY](entry) {
			let go = true;
			if (!entry) {
				this[READENTRY] = null;
				go = false;
			} else if (Array.isArray(entry)) this.emit.apply(this, entry);
else {
				this[READENTRY] = entry;
				this.emit("entry", entry);
				if (!entry.emittedEnd) {
					entry.on("end", (_) => this[NEXTENTRY]());
					go = false;
				}
			}
			return go;
		}
		[NEXTENTRY]() {
			do {} while (this[PROCESSENTRY](this[QUEUE].shift()));
			if (!this[QUEUE].length) {
				const re = this[READENTRY];
				const drainNow = !re || re.flowing || re.size === re.remain;
				if (drainNow) {
					if (!this[WRITING]) this.emit("drain");
				} else re.once("drain", (_) => this.emit("drain"));
			}
		}
		[CONSUMEBODY](chunk, position) {
			const entry = this[WRITEENTRY];
			const br = entry.blockRemain;
			const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
			entry.write(c);
			if (!entry.blockRemain) {
				this[STATE] = "header";
				this[WRITEENTRY] = null;
				entry.end();
			}
			return c.length;
		}
		[CONSUMEMETA](chunk, position) {
			const entry = this[WRITEENTRY];
			const ret = this[CONSUMEBODY](chunk, position);
			if (!this[WRITEENTRY]) this[EMITMETA](entry);
			return ret;
		}
		[EMIT](ev, data, extra) {
			if (!this[QUEUE].length && !this[READENTRY]) this.emit(ev, data, extra);
else this[QUEUE].push([
				ev,
				data,
				extra
			]);
		}
		[EMITMETA](entry) {
			this[EMIT]("meta", this[META]);
			switch (entry.type) {
				case "ExtendedHeader":
				case "OldExtendedHeader":
					this[EX] = pax.parse(this[META], this[EX], false);
					break;
				case "GlobalExtendedHeader":
					this[GEX] = pax.parse(this[META], this[GEX], true);
					break;
				case "NextFileHasLongPath":
				case "OldGnuLongPath":
					this[EX] = this[EX] || Object.create(null);
					this[EX].path = this[META].replace(/\0.*/, "");
					break;
				case "NextFileHasLongLinkpath":
					this[EX] = this[EX] || Object.create(null);
					this[EX].linkpath = this[META].replace(/\0.*/, "");
					break;
				default: throw new Error("unknown meta: " + entry.type);
			}
		}
		abort(error) {
			this[ABORTED] = true;
			this.emit("abort", error);
			this.warn("TAR_ABORT", error, { recoverable: false });
		}
		write(chunk) {
			if (this[ABORTED]) return;
			if (this[UNZIP] === null && chunk) {
				if (this[BUFFER]) {
					chunk = Buffer.concat([this[BUFFER], chunk]);
					this[BUFFER] = null;
				}
				if (chunk.length < gzipHeader.length) {
					this[BUFFER] = chunk;
					return true;
				}
				for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) if (chunk[i] !== gzipHeader[i]) this[UNZIP] = false;
				if (this[UNZIP] === null) {
					const ended = this[ENDED$1];
					this[ENDED$1] = false;
					this[UNZIP] = new minizlib.Unzip();
					this[UNZIP].on("data", (chunk$1) => this[CONSUMECHUNK](chunk$1));
					this[UNZIP].on("error", (er) => this.abort(er));
					this[UNZIP].on("end", (_) => {
						this[ENDED$1] = true;
						this[CONSUMECHUNK]();
					});
					this[WRITING] = true;
					const ret$1 = this[UNZIP][ended ? "end" : "write"](chunk);
					this[WRITING] = false;
					return ret$1;
				}
			}
			this[WRITING] = true;
			if (this[UNZIP]) this[UNZIP].write(chunk);
else this[CONSUMECHUNK](chunk);
			this[WRITING] = false;
			const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
			if (!ret && !this[QUEUE].length) this[READENTRY].once("drain", (_) => this.emit("drain"));
			return ret;
		}
		[BUFFERCONCAT](c) {
			if (c && !this[ABORTED]) this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
		}
		[MAYBEEND]() {
			if (this[ENDED$1] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
				this[EMITTEDEND] = true;
				const entry = this[WRITEENTRY];
				if (entry && entry.blockRemain) {
					const have = this[BUFFER] ? this[BUFFER].length : 0;
					this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
					if (this[BUFFER]) entry.write(this[BUFFER]);
					entry.end();
				}
				this[EMIT](DONE);
			}
		}
		[CONSUMECHUNK](chunk) {
			if (this[CONSUMING]) this[BUFFERCONCAT](chunk);
else if (!chunk && !this[BUFFER]) this[MAYBEEND]();
else {
				this[CONSUMING] = true;
				if (this[BUFFER]) {
					this[BUFFERCONCAT](chunk);
					const c = this[BUFFER];
					this[BUFFER] = null;
					this[CONSUMECHUNKSUB](c);
				} else this[CONSUMECHUNKSUB](chunk);
				while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
					const c = this[BUFFER];
					this[BUFFER] = null;
					this[CONSUMECHUNKSUB](c);
				}
				this[CONSUMING] = false;
			}
			if (!this[BUFFER] || this[ENDED$1]) this[MAYBEEND]();
		}
		[CONSUMECHUNKSUB](chunk) {
			let position = 0;
			const length = chunk.length;
			while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) switch (this[STATE]) {
				case "begin":
				case "header":
					this[CONSUMEHEADER](chunk, position);
					position += 512;
					break;
				case "ignore":
				case "body":
					position += this[CONSUMEBODY](chunk, position);
					break;
				case "meta":
					position += this[CONSUMEMETA](chunk, position);
					break;
				default: throw new Error("invalid state: " + this[STATE]);
			}
			if (position < length) if (this[BUFFER]) this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
else this[BUFFER] = chunk.slice(position);
		}
		end(chunk) {
			if (!this[ABORTED]) if (this[UNZIP]) this[UNZIP].end(chunk);
else {
				this[ENDED$1] = true;
				this.write(chunk);
			}
		}
	});
	var list_1 = (opt_, files, cb) => {
		if (typeof opt_ === "function") cb = opt_, files = null, opt_ = {};
else if (Array.isArray(opt_)) files = opt_, opt_ = {};
		if (typeof files === "function") cb = files, files = null;
		if (!files) files = [];
else files = Array.from(files);
		const opt = highLevelOpt(opt_);
		if (opt.sync && typeof cb === "function") throw new TypeError("callback not supported for sync tar functions");
		if (!opt.file && typeof cb === "function") throw new TypeError("callback only supported with file option");
		if (files.length) filesFilter$1(opt, files);
		if (!opt.noResume) onentryFunction(opt);
		return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
	};
	const onentryFunction = (opt) => {
		const onentry = opt.onentry;
		opt.onentry = onentry ? (e) => {
			onentry(e);
			e.resume();
		} : (e) => e.resume();
	};
	const filesFilter$1 = (opt, files) => {
		const map$1 = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
		const filter$1 = opt.filter;
		const mapHas = (file, r) => {
			const root = r || path__default["default"].parse(file).root || ".";
			const ret = file === root ? false : map$1.has(file) ? map$1.get(file) : mapHas(path__default["default"].dirname(file), root);
			map$1.set(file, ret);
			return ret;
		};
		opt.filter = filter$1 ? (file, entry) => filter$1(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
	};
	const listFileSync = (opt) => {
		const p = list(opt);
		const file = opt.file;
		let threw = true;
		let fd;
		try {
			const stat = fs__default["default"].statSync(file);
			const readSize = opt.maxReadSize || 16777216;
			if (stat.size < readSize) p.end(fs__default["default"].readFileSync(file));
else {
				let pos$1 = 0;
				const buf = Buffer.allocUnsafe(readSize);
				fd = fs__default["default"].openSync(file, "r");
				while (pos$1 < stat.size) {
					const bytesRead = fs__default["default"].readSync(fd, buf, 0, readSize, pos$1);
					pos$1 += bytesRead;
					p.write(buf.slice(0, bytesRead));
				}
				p.end();
			}
			threw = false;
		} finally {
			if (threw && fd) try {
				fs__default["default"].closeSync(fd);
			} catch (er) {}
		}
	};
	const listFile = (opt, cb) => {
		const parse$6 = new parse$4(opt);
		const readSize = opt.maxReadSize || 16777216;
		const file = opt.file;
		const p = new Promise((resolve$2, reject) => {
			parse$6.on("error", reject);
			parse$6.on("end", resolve$2);
			fs__default["default"].stat(file, (er, stat) => {
				if (er) reject(er);
else {
					const stream = new fsMinipass.ReadStream(file, {
						readSize,
						size: stat.size
					});
					stream.on("error", reject);
					stream.pipe(parse$6);
				}
			});
		});
		return cb ? p.then(cb, cb) : p;
	};
	const list = (opt) => new parse$4(opt);
	var create_1 = (opt_, files, cb) => {
		if (typeof files === "function") cb = files;
		if (Array.isArray(opt_)) files = opt_, opt_ = {};
		if (!files || !Array.isArray(files) || !files.length) throw new TypeError("no files or directories specified");
		files = Array.from(files);
		const opt = highLevelOpt(opt_);
		if (opt.sync && typeof cb === "function") throw new TypeError("callback not supported for sync tar functions");
		if (!opt.file && typeof cb === "function") throw new TypeError("callback only supported with file option");
		return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create$1(opt, files);
	};
	const createFileSync = (opt, files) => {
		const p = new pack.Sync(opt);
		const stream = new fsMinipass.WriteStreamSync(opt.file, { mode: opt.mode || 438 });
		p.pipe(stream);
		addFilesSync$1(p, files);
	};
	const createFile = (opt, files, cb) => {
		const p = new pack(opt);
		const stream = new fsMinipass.WriteStream(opt.file, { mode: opt.mode || 438 });
		p.pipe(stream);
		const promise = new Promise((res, rej) => {
			stream.on("error", rej);
			stream.on("close", res);
			p.on("error", rej);
		});
		addFilesAsync$1(p, files);
		return cb ? promise.then(cb, cb) : promise;
	};
	const addFilesSync$1 = (p, files) => {
		files.forEach((file) => {
			if (file.charAt(0) === "@") list_1({
				file: path__default["default"].resolve(p.cwd, file.substr(1)),
				sync: true,
				noResume: true,
				onentry: (entry) => p.add(entry)
			});
else p.add(file);
		});
		p.end();
	};
	const addFilesAsync$1 = (p, files) => {
		while (files.length) {
			const file = files.shift();
			if (file.charAt(0) === "@") return list_1({
				file: path__default["default"].resolve(p.cwd, file.substr(1)),
				noResume: true,
				onentry: (entry) => p.add(entry)
			}).then((_) => addFilesAsync$1(p, files));
else p.add(file);
		}
		p.end();
	};
	const createSync = (opt, files) => {
		const p = new pack.Sync(opt);
		addFilesSync$1(p, files);
		return p;
	};
	const create$1 = (opt, files) => {
		const p = new pack(opt);
		addFilesAsync$1(p, files);
		return p;
	};
	var replace_1 = (opt_, files, cb) => {
		const opt = highLevelOpt(opt_);
		if (!opt.file) throw new TypeError("file is required");
		if (opt.gzip) throw new TypeError("cannot append to compressed archives");
		if (!files || !Array.isArray(files) || !files.length) throw new TypeError("no files or directories specified");
		files = Array.from(files);
		return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
	};
	const replaceSync = (opt, files) => {
		const p = new pack.Sync(opt);
		let threw = true;
		let fd;
		let position;
		try {
			try {
				fd = fs__default["default"].openSync(opt.file, "r+");
			} catch (er) {
				if (er.code === "ENOENT") fd = fs__default["default"].openSync(opt.file, "w+");
else throw er;
			}
			const st = fs__default["default"].fstatSync(fd);
			const headBuf = Buffer.alloc(512);
			POSITION: for (position = 0; position < st.size; position += 512) {
				for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
					bytes = fs__default["default"].readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
					if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) throw new Error("cannot append to compressed archives");
					if (!bytes) break POSITION;
				}
				const h$1 = new header(headBuf);
				if (!h$1.cksumValid) break;
				const entryBlockSize = 512 * Math.ceil(h$1.size / 512);
				if (position + entryBlockSize + 512 > st.size) break;
				position += entryBlockSize;
				if (opt.mtimeCache) opt.mtimeCache.set(h$1.path, h$1.mtime);
			}
			threw = false;
			streamSync(opt, p, position, fd, files);
		} finally {
			if (threw) try {
				fs__default["default"].closeSync(fd);
			} catch (er) {}
		}
	};
	const streamSync = (opt, p, position, fd, files) => {
		const stream = new fsMinipass.WriteStreamSync(opt.file, {
			fd,
			start: position
		});
		p.pipe(stream);
		addFilesSync(p, files);
	};
	const replace = (opt, files, cb) => {
		files = Array.from(files);
		const p = new pack(opt);
		const getPos = (fd, size, cb_) => {
			const cb$1 = (er, pos$1) => {
				if (er) fs__default["default"].close(fd, (_) => cb_(er));
else cb_(null, pos$1);
			};
			let position = 0;
			if (size === 0) return cb$1(null, 0);
			let bufPos = 0;
			const headBuf = Buffer.alloc(512);
			const onread = (er, bytes) => {
				if (er) return cb$1(er);
				bufPos += bytes;
				if (bufPos < 512 && bytes) return fs__default["default"].read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
				if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) return cb$1(new Error("cannot append to compressed archives"));
				if (bufPos < 512) return cb$1(null, position);
				const h$1 = new header(headBuf);
				if (!h$1.cksumValid) return cb$1(null, position);
				const entryBlockSize = 512 * Math.ceil(h$1.size / 512);
				if (position + entryBlockSize + 512 > size) return cb$1(null, position);
				position += entryBlockSize + 512;
				if (position >= size) return cb$1(null, position);
				if (opt.mtimeCache) opt.mtimeCache.set(h$1.path, h$1.mtime);
				bufPos = 0;
				fs__default["default"].read(fd, headBuf, 0, 512, position, onread);
			};
			fs__default["default"].read(fd, headBuf, 0, 512, position, onread);
		};
		const promise = new Promise((resolve$2, reject) => {
			p.on("error", reject);
			let flag = "r+";
			const onopen = (er, fd) => {
				if (er && er.code === "ENOENT" && flag === "r+") {
					flag = "w+";
					return fs__default["default"].open(opt.file, flag, onopen);
				}
				if (er) return reject(er);
				fs__default["default"].fstat(fd, (er$1, st) => {
					if (er$1) return reject(er$1);
					getPos(fd, st.size, (er$2, position) => {
						if (er$2) return reject(er$2);
						const stream = new fsMinipass.WriteStream(opt.file, {
							fd,
							start: position
						});
						p.pipe(stream);
						stream.on("error", reject);
						stream.on("close", resolve$2);
						addFilesAsync(p, files);
					});
				});
			};
			fs__default["default"].open(opt.file, flag, onopen);
		});
		return cb ? promise.then(cb, cb) : promise;
	};
	const addFilesSync = (p, files) => {
		files.forEach((file) => {
			if (file.charAt(0) === "@") list_1({
				file: path__default["default"].resolve(p.cwd, file.substr(1)),
				sync: true,
				noResume: true,
				onentry: (entry) => p.add(entry)
			});
else p.add(file);
		});
		p.end();
	};
	const addFilesAsync = (p, files) => {
		while (files.length) {
			const file = files.shift();
			if (file.charAt(0) === "@") return list_1({
				file: path__default["default"].resolve(p.cwd, file.substr(1)),
				noResume: true,
				onentry: (entry) => p.add(entry)
			}).then((_) => addFilesAsync(p, files));
else p.add(file);
		}
		p.end();
	};
	var update = (opt_, files, cb) => {
		const opt = highLevelOpt(opt_);
		if (!opt.file) throw new TypeError("file is required");
		if (opt.gzip) throw new TypeError("cannot append to compressed archives");
		if (!files || !Array.isArray(files) || !files.length) throw new TypeError("no files or directories specified");
		files = Array.from(files);
		mtimeFilter(opt);
		return replace_1(opt, files, cb);
	};
	const mtimeFilter = (opt) => {
		const filter$1 = opt.filter;
		if (!opt.mtimeCache) opt.mtimeCache = new Map();
		opt.filter = filter$1 ? (path$3, stat) => filter$1(path$3, stat) && !(opt.mtimeCache.get(path$3) > stat.mtime) : (path$3, stat) => !(opt.mtimeCache.get(path$3) > stat.mtime);
	};
	const { promisify: promisify$1 } = util__default["default"];
	const optsArg = (opts) => {
		if (!opts) opts = {
			mode: 511,
			fs: fs__default["default"]
		};
else if (typeof opts === "object") opts = {
			mode: 511,
			fs: fs__default["default"],
			...opts
		};
else if (typeof opts === "number") opts = {
			mode: opts,
			fs: fs__default["default"]
		};
else if (typeof opts === "string") opts = {
			mode: parseInt(opts, 8),
			fs: fs__default["default"]
		};
else throw new TypeError("invalid options argument");
		opts.mkdir = opts.mkdir || opts.fs.mkdir || fs__default["default"].mkdir;
		opts.mkdirAsync = promisify$1(opts.mkdir);
		opts.stat = opts.stat || opts.fs.stat || fs__default["default"].stat;
		opts.statAsync = promisify$1(opts.stat);
		opts.statSync = opts.statSync || opts.fs.statSync || fs__default["default"].statSync;
		opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs__default["default"].mkdirSync;
		return opts;
	};
	var optsArg_1 = optsArg;
	const platform$2 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
	const { resolve: resolve$1, parse: parse$3 } = path__default["default"];
	const pathArg = (path$3) => {
		if (/\0/.test(path$3)) throw Object.assign(new TypeError("path must be a string without null bytes"), {
			path: path$3,
			code: "ERR_INVALID_ARG_VALUE"
		});
		path$3 = resolve$1(path$3);
		if (platform$2 === "win32") {
			const badWinChars = /[*|"<>?:]/;
			const { root } = parse$3(path$3);
			if (badWinChars.test(path$3.substr(root.length))) throw Object.assign(new Error("Illegal characters in path."), {
				path: path$3,
				code: "EINVAL"
			});
		}
		return path$3;
	};
	var pathArg_1 = pathArg;
	const { dirname: dirname$2 } = path__default["default"];
	const findMade$1 = (opts, parent, path$3 = undefined) => {
		if (path$3 === parent) return Promise.resolve();
		return opts.statAsync(parent).then((st) => st.isDirectory() ? path$3 : undefined, (er) => er.code === "ENOENT" ? findMade$1(opts, dirname$2(parent), parent) : undefined);
	};
	const findMadeSync$1 = (opts, parent, path$3 = undefined) => {
		if (path$3 === parent) return undefined;
		try {
			return opts.statSync(parent).isDirectory() ? path$3 : undefined;
		} catch (er) {
			return er.code === "ENOENT" ? findMadeSync$1(opts, dirname$2(parent), parent) : undefined;
		}
	};
	var findMade_1 = {
		findMade: findMade$1,
		findMadeSync: findMadeSync$1
	};
	const { dirname: dirname$1 } = path__default["default"];
	const mkdirpManual$2 = (path$3, opts, made) => {
		opts.recursive = false;
		const parent = dirname$1(path$3);
		if (parent === path$3) return opts.mkdirAsync(path$3, opts).catch((er) => {
			if (er.code !== "EISDIR") throw er;
		});
		return opts.mkdirAsync(path$3, opts).then(() => made || path$3, (er) => {
			if (er.code === "ENOENT") return mkdirpManual$2(parent, opts).then((made$1) => mkdirpManual$2(path$3, opts, made$1));
			if (er.code !== "EEXIST" && er.code !== "EROFS") throw er;
			return opts.statAsync(path$3).then((st) => {
				if (st.isDirectory()) return made;
else throw er;
			}, () => {
				throw er;
			});
		});
	};
	const mkdirpManualSync$2 = (path$3, opts, made) => {
		const parent = dirname$1(path$3);
		opts.recursive = false;
		if (parent === path$3) try {
			return opts.mkdirSync(path$3, opts);
		} catch (er) {
			if (er.code !== "EISDIR") throw er;
else return;
		}
		try {
			opts.mkdirSync(path$3, opts);
			return made || path$3;
		} catch (er) {
			if (er.code === "ENOENT") return mkdirpManualSync$2(path$3, opts, mkdirpManualSync$2(parent, opts, made));
			if (er.code !== "EEXIST" && er.code !== "EROFS") throw er;
			try {
				if (!opts.statSync(path$3).isDirectory()) throw er;
			} catch (_) {
				throw er;
			}
		}
	};
	var mkdirpManual_1 = {
		mkdirpManual: mkdirpManual$2,
		mkdirpManualSync: mkdirpManualSync$2
	};
	const { dirname: dirname$3 } = path__default["default"];
	const { findMade, findMadeSync } = findMade_1;
	const { mkdirpManual: mkdirpManual$1, mkdirpManualSync: mkdirpManualSync$1 } = mkdirpManual_1;
	const mkdirpNative$1 = (path$3, opts) => {
		opts.recursive = true;
		const parent = dirname$3(path$3);
		if (parent === path$3) return opts.mkdirAsync(path$3, opts);
		return findMade(opts, path$3).then((made) => opts.mkdirAsync(path$3, opts).then(() => made).catch((er) => {
			if (er.code === "ENOENT") return mkdirpManual$1(path$3, opts);
else throw er;
		}));
	};
	const mkdirpNativeSync$1 = (path$3, opts) => {
		opts.recursive = true;
		const parent = dirname$3(path$3);
		if (parent === path$3) return opts.mkdirSync(path$3, opts);
		const made = findMadeSync(opts, path$3);
		try {
			opts.mkdirSync(path$3, opts);
			return made;
		} catch (er) {
			if (er.code === "ENOENT") return mkdirpManualSync$1(path$3, opts);
else throw er;
		}
	};
	var mkdirpNative_1 = {
		mkdirpNative: mkdirpNative$1,
		mkdirpNativeSync: mkdirpNativeSync$1
	};
	const version$1 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
	const versArr = version$1.replace(/^v/, "").split(".");
	const hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
	const useNative$1 = !hasNative ? () => false : (opts) => opts.mkdir === fs__default["default"].mkdir;
	const useNativeSync$1 = !hasNative ? () => false : (opts) => opts.mkdirSync === fs__default["default"].mkdirSync;
	var useNative_1 = {
		useNative: useNative$1,
		useNativeSync: useNativeSync$1
	};
	const { mkdirpNative, mkdirpNativeSync } = mkdirpNative_1;
	const { mkdirpManual, mkdirpManualSync } = mkdirpManual_1;
	const { useNative, useNativeSync } = useNative_1;
	const mkdirp$3 = (path$3, opts) => {
		path$3 = pathArg_1(path$3);
		opts = optsArg_1(opts);
		return useNative(opts) ? mkdirpNative(path$3, opts) : mkdirpManual(path$3, opts);
	};
	const mkdirpSync = (path$3, opts) => {
		path$3 = pathArg_1(path$3);
		opts = optsArg_1(opts);
		return useNativeSync(opts) ? mkdirpNativeSync(path$3, opts) : mkdirpManualSync(path$3, opts);
	};
	mkdirp$3.sync = mkdirpSync;
	mkdirp$3.native = (path$3, opts) => mkdirpNative(pathArg_1(path$3), optsArg_1(opts));
	mkdirp$3.manual = (path$3, opts) => mkdirpManual(pathArg_1(path$3), optsArg_1(opts));
	mkdirp$3.nativeSync = (path$3, opts) => mkdirpNativeSync(pathArg_1(path$3), optsArg_1(opts));
	mkdirp$3.manualSync = (path$3, opts) => mkdirpManualSync(pathArg_1(path$3), optsArg_1(opts));
	var mkdirp_1 = mkdirp$3;
	const LCHOWN = fs__default["default"].lchown ? "lchown" : "chown";
	const LCHOWNSYNC = fs__default["default"].lchownSync ? "lchownSync" : "chownSync";
	const needEISDIRHandled = fs__default["default"].lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
	const lchownSync = (path$3, uid, gid) => {
		try {
			return fs__default["default"][LCHOWNSYNC](path$3, uid, gid);
		} catch (er) {
			if (er.code !== "ENOENT") throw er;
		}
	};
	const chownSync = (path$3, uid, gid) => {
		try {
			return fs__default["default"].chownSync(path$3, uid, gid);
		} catch (er) {
			if (er.code !== "ENOENT") throw er;
		}
	};
	const handleEISDIR = needEISDIRHandled ? (path$3, uid, gid, cb) => (er) => {
		if (!er || er.code !== "EISDIR") cb(er);
else fs__default["default"].chown(path$3, uid, gid, cb);
	} : (_, __, ___, cb) => cb;
	const handleEISDirSync = needEISDIRHandled ? (path$3, uid, gid) => {
		try {
			return lchownSync(path$3, uid, gid);
		} catch (er) {
			if (er.code !== "EISDIR") throw er;
			chownSync(path$3, uid, gid);
		}
	} : (path$3, uid, gid) => lchownSync(path$3, uid, gid);
	const nodeVersion = process.version;
	let readdir = (path$3, options, cb) => fs__default["default"].readdir(path$3, options, cb);
	let readdirSync = (path$3, options) => fs__default["default"].readdirSync(path$3, options);
	if (/^v4\./.test(nodeVersion)) readdir = (path$3, options, cb) => fs__default["default"].readdir(path$3, cb);
	const chown = (cpath, uid, gid, cb) => {
		fs__default["default"][LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
			cb(er && er.code !== "ENOENT" ? er : null);
		}));
	};
	const chownrKid = (p, child, uid, gid, cb) => {
		if (typeof child === "string") return fs__default["default"].lstat(path__default["default"].resolve(p, child), (er, stats) => {
			if (er) return cb(er.code !== "ENOENT" ? er : null);
			stats.name = child;
			chownrKid(p, stats, uid, gid, cb);
		});
		if (child.isDirectory()) chownr(path__default["default"].resolve(p, child.name), uid, gid, (er) => {
			if (er) return cb(er);
			const cpath = path__default["default"].resolve(p, child.name);
			chown(cpath, uid, gid, cb);
		});
else {
			const cpath = path__default["default"].resolve(p, child.name);
			chown(cpath, uid, gid, cb);
		}
	};
	const chownr = (p, uid, gid, cb) => {
		readdir(p, { withFileTypes: true }, (er, children) => {
			if (er) {
				if (er.code === "ENOENT") return cb();
else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP") return cb(er);
			}
			if (er || !children.length) return chown(p, uid, gid, cb);
			let len = children.length;
			let errState = null;
			const then = (er$1) => {
				if (errState) return;
				if (er$1) return cb(errState = er$1);
				if (--len === 0) return chown(p, uid, gid, cb);
			};
			children.forEach((child) => chownrKid(p, child, uid, gid, then));
		});
	};
	const chownrKidSync = (p, child, uid, gid) => {
		if (typeof child === "string") try {
			const stats = fs__default["default"].lstatSync(path__default["default"].resolve(p, child));
			stats.name = child;
			child = stats;
		} catch (er) {
			if (er.code === "ENOENT") return;
else throw er;
		}
		if (child.isDirectory()) chownrSync(path__default["default"].resolve(p, child.name), uid, gid);
		handleEISDirSync(path__default["default"].resolve(p, child.name), uid, gid);
	};
	const chownrSync = (p, uid, gid) => {
		let children;
		try {
			children = readdirSync(p, { withFileTypes: true });
		} catch (er) {
			if (er.code === "ENOENT") return;
else if (er.code === "ENOTDIR" || er.code === "ENOTSUP") return handleEISDirSync(p, uid, gid);
else throw er;
		}
		if (children && children.length) children.forEach((child) => chownrKidSync(p, child, uid, gid));
		return handleEISDirSync(p, uid, gid);
	};
	var chownr_1 = chownr;
	chownr.sync = chownrSync;
	var SymlinkError = class extends Error {
		constructor(symlink, path$3) {
			super("Cannot extract through symbolic link");
			this.path = path$3;
			this.symlink = symlink;
		}
		get name() {
			return "SylinkError";
		}
	};
	var CwdError = class extends Error {
		constructor(path$3, code) {
			super(code + ": Cannot cd into '" + path$3 + "'");
			this.path = path$3;
			this.code = code;
		}
		get name() {
			return "CwdError";
		}
	};
	var mkdir = (dir, opt, cb) => {
		const umask = opt.umask;
		const mode = opt.mode | 448;
		const needChmod = (mode & umask) !== 0;
		const uid = opt.uid;
		const gid = opt.gid;
		const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
		const preserve = opt.preserve;
		const unlink = opt.unlink;
		const cache = opt.cache;
		const cwd$1 = opt.cwd;
		const done = (er, created) => {
			if (er) cb(er);
else {
				cache.set(dir, true);
				if (created && doChown) chownr_1(created, uid, gid, (er$1) => done(er$1));
else if (needChmod) fs__default["default"].chmod(dir, mode, cb);
else cb();
			}
		};
		if (cache && cache.get(dir) === true) return done();
		if (dir === cwd$1) return fs__default["default"].stat(dir, (er, st) => {
			if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || "ENOTDIR");
			done(er);
		});
		if (preserve) return mkdirp_1(dir, { mode }).then((made) => done(null, made), done);
		const sub = path__default["default"].relative(cwd$1, dir);
		const parts = sub.split(/\/|\\/);
		mkdir_(cwd$1, parts, mode, cache, unlink, cwd$1, null, done);
	};
	const mkdir_ = (base$1, parts, mode, cache, unlink, cwd$1, created, cb) => {
		if (!parts.length) return cb(null, created);
		const p = parts.shift();
		const part = base$1 + "/" + p;
		if (cache.get(part)) return mkdir_(part, parts, mode, cache, unlink, cwd$1, created, cb);
		fs__default["default"].mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd$1, created, cb));
	};
	const onmkdir = (part, parts, mode, cache, unlink, cwd$1, created, cb) => (er) => {
		if (er) {
			if (er.path && path__default["default"].dirname(er.path) === cwd$1 && (er.code === "ENOTDIR" || er.code === "ENOENT")) return cb(new CwdError(cwd$1, er.code));
			fs__default["default"].lstat(part, (statEr, st) => {
				if (statEr) cb(statEr);
else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd$1, created, cb);
else if (unlink) fs__default["default"].unlink(part, (er$1) => {
					if (er$1) return cb(er$1);
					fs__default["default"].mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd$1, created, cb));
				});
else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + "/" + parts.join("/")));
else cb(er);
			});
		} else {
			created = created || part;
			mkdir_(part, parts, mode, cache, unlink, cwd$1, created, cb);
		}
	};
	var sync$1 = (dir, opt) => {
		const umask = opt.umask;
		const mode = opt.mode | 448;
		const needChmod = (mode & umask) !== 0;
		const uid = opt.uid;
		const gid = opt.gid;
		const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
		const preserve = opt.preserve;
		const unlink = opt.unlink;
		const cache = opt.cache;
		const cwd$1 = opt.cwd;
		const done = (created$1) => {
			cache.set(dir, true);
			if (created$1 && doChown) chownr_1.sync(created$1, uid, gid);
			if (needChmod) fs__default["default"].chmodSync(dir, mode);
		};
		if (cache && cache.get(dir) === true) return done();
		if (dir === cwd$1) {
			let ok$1 = false;
			let code = "ENOTDIR";
			try {
				ok$1 = fs__default["default"].statSync(dir).isDirectory();
			} catch (er) {
				code = er.code;
			} finally {
				if (!ok$1) throw new CwdError(dir, code);
			}
			done();
			return;
		}
		if (preserve) return done(mkdirp_1.sync(dir, mode));
		const sub = path__default["default"].relative(cwd$1, dir);
		const parts = sub.split(/\/|\\/);
		let created = null;
		for (let p = parts.shift(), part = cwd$1; p && (part += "/" + p); p = parts.shift()) {
			if (cache.get(part)) continue;
			try {
				fs__default["default"].mkdirSync(part, mode);
				created = created || part;
				cache.set(part, true);
			} catch (er) {
				if (er.path && path__default["default"].dirname(er.path) === cwd$1 && (er.code === "ENOTDIR" || er.code === "ENOENT")) return new CwdError(cwd$1, er.code);
				const st = fs__default["default"].lstatSync(part);
				if (st.isDirectory()) {
					cache.set(part, true);
					continue;
				} else if (unlink) {
					fs__default["default"].unlinkSync(part);
					fs__default["default"].mkdirSync(part, mode);
					created = created || part;
					cache.set(part, true);
					continue;
				} else if (st.isSymbolicLink()) return new SymlinkError(part, part + "/" + parts.join("/"));
			}
		}
		return done(created);
	};
	mkdir.sync = sync$1;
	var pathReservations = () => {
		const queues = new Map();
		const reservations = new Map();
		const { join: join$1 } = path__default["default"];
		const getDirs = (path$3) => join$1(path$3).split(/[\\/]/).slice(0, -1).reduce((set, path$4) => set.length ? set.concat(join$1(set[set.length - 1], path$4)) : [path$4], []);
		const running = new Set();
		const getQueues = (fn) => {
			const res = reservations.get(fn);
			if (!res) throw new Error("function does not have any path reservations");
			return {
				paths: res.paths.map((path$3) => queues.get(path$3)),
				dirs: [...res.dirs].map((path$3) => queues.get(path$3))
			};
		};
		const check = (fn) => {
			const { paths, dirs } = getQueues(fn);
			return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
		};
		const run = (fn) => {
			if (running.has(fn) || !check(fn)) return false;
			running.add(fn);
			fn(() => clear(fn));
			return true;
		};
		const clear = (fn) => {
			if (!running.has(fn)) return false;
			const { paths, dirs } = reservations.get(fn);
			const next = new Set();
			paths.forEach((path$3) => {
				const q = queues.get(path$3);
				assert__default["default"].equal(q[0], fn);
				if (q.length === 1) queues.delete(path$3);
else {
					q.shift();
					if (typeof q[0] === "function") next.add(q[0]);
else q[0].forEach((fn$1) => next.add(fn$1));
				}
			});
			dirs.forEach((dir) => {
				const q = queues.get(dir);
				assert__default["default"](q[0] instanceof Set);
				if (q[0].size === 1 && q.length === 1) queues.delete(dir);
else if (q[0].size === 1) {
					q.shift();
					next.add(q[0]);
				} else q[0].delete(fn);
			});
			running.delete(fn);
			next.forEach((fn$1) => run(fn$1));
			return true;
		};
		const reserve = (paths, fn) => {
			const dirs = new Set(paths.map((path$3) => getDirs(path$3)).reduce((a, b) => a.concat(b)));
			reservations.set(fn, {
				dirs,
				paths
			});
			paths.forEach((path$3) => {
				const q = queues.get(path$3);
				if (!q) queues.set(path$3, [fn]);
else q.push(fn);
			});
			dirs.forEach((dir) => {
				const q = queues.get(dir);
				if (!q) queues.set(dir, [new Set([fn])]);
else if (q[q.length - 1] instanceof Set) q[q.length - 1].add(fn);
else q.push(new Set([fn]));
			});
			return run(fn);
		};
		return {
			check,
			reserve
		};
	};
	const platform$1 = process.env.__FAKE_PLATFORM__ || process.platform;
	const isWindows$2 = platform$1 === "win32";
	const fs$2 = commonjsGlobal.__FAKE_TESTING_FS__ || fs__default["default"];
	const { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs$2.constants;
	const fMapEnabled = isWindows$2 && !!UV_FS_O_FILEMAP;
	const fMapLimit = 524288;
	const fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
	var getWriteFlag = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
	const ONENTRY = Symbol("onEntry");
	const CHECKFS = Symbol("checkFs");
	const CHECKFS2 = Symbol("checkFs2");
	const ISREUSABLE = Symbol("isReusable");
	const MAKEFS = Symbol("makeFs");
	const FILE = Symbol("file");
	const DIRECTORY = Symbol("directory");
	const LINK = Symbol("link");
	const SYMLINK = Symbol("symlink");
	const HARDLINK = Symbol("hardlink");
	const UNSUPPORTED = Symbol("unsupported");
	const CHECKPATH = Symbol("checkPath");
	const MKDIR = Symbol("mkdir");
	const ONERROR = Symbol("onError");
	const PENDING = Symbol("pending");
	const PEND = Symbol("pend");
	const UNPEND = Symbol("unpend");
	const ENDED = Symbol("ended");
	const MAYBECLOSE = Symbol("maybeClose");
	const SKIP = Symbol("skip");
	const DOCHOWN = Symbol("doChown");
	const UID = Symbol("uid");
	const GID = Symbol("gid");
	const neverCalled = () => {
		throw new Error("sync function called cb somehow?!?");
	};
	const unlinkFile = (path$3, cb) => {
		if (process.platform !== "win32") return fs__default["default"].unlink(path$3, cb);
		const name = path$3 + ".DELETE." + crypto__default["default"].randomBytes(16).toString("hex");
		fs__default["default"].rename(path$3, name, (er) => {
			if (er) return cb(er);
			fs__default["default"].unlink(name, cb);
		});
	};
	const unlinkFileSync = (path$3) => {
		if (process.platform !== "win32") return fs__default["default"].unlinkSync(path$3);
		const name = path$3 + ".DELETE." + crypto__default["default"].randomBytes(16).toString("hex");
		fs__default["default"].renameSync(path$3, name);
		fs__default["default"].unlinkSync(name);
	};
	const uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
	var Unpack = class extends parse$4 {
		constructor(opt) {
			if (!opt) opt = {};
			opt.ondone = (_) => {
				this[ENDED] = true;
				this[MAYBECLOSE]();
			};
			super(opt);
			this.reservations = pathReservations();
			this.transform = typeof opt.transform === "function" ? opt.transform : null;
			this.writable = true;
			this.readable = false;
			this[PENDING] = 0;
			this[ENDED] = false;
			this.dirCache = opt.dirCache || new Map();
			if (typeof opt.uid === "number" || typeof opt.gid === "number") {
				if (typeof opt.uid !== "number" || typeof opt.gid !== "number") throw new TypeError("cannot set owner without number uid and gid");
				if (opt.preserveOwner) throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
				this.uid = opt.uid;
				this.gid = opt.gid;
				this.setOwner = true;
			} else {
				this.uid = null;
				this.gid = null;
				this.setOwner = false;
			}
			if (opt.preserveOwner === undefined && typeof opt.uid !== "number") this.preserveOwner = process.getuid && process.getuid() === 0;
else this.preserveOwner = !!opt.preserveOwner;
			this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
			this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
			this.forceChown = opt.forceChown === true;
			this.win32 = !!opt.win32 || process.platform === "win32";
			this.newer = !!opt.newer;
			this.keep = !!opt.keep;
			this.noMtime = !!opt.noMtime;
			this.preservePaths = !!opt.preservePaths;
			this.unlink = !!opt.unlink;
			this.cwd = path__default["default"].resolve(opt.cwd || process.cwd());
			this.strip = +opt.strip || 0;
			this.processUmask = opt.noChmod ? 0 : process.umask();
			this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
			this.dmode = opt.dmode || 511 & ~this.umask;
			this.fmode = opt.fmode || 438 & ~this.umask;
			this.on("entry", (entry) => this[ONENTRY](entry));
		}
		warn(code, msg, data = {}) {
			if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") data.recoverable = false;
			return super.warn(code, msg, data);
		}
		[MAYBECLOSE]() {
			if (this[ENDED] && this[PENDING] === 0) {
				this.emit("prefinish");
				this.emit("finish");
				this.emit("end");
				this.emit("close");
			}
		}
		[CHECKPATH](entry) {
			if (this.strip) {
				const parts = entry.path.split(/\/|\\/);
				if (parts.length < this.strip) return false;
				entry.path = parts.slice(this.strip).join("/");
				if (entry.type === "Link") {
					const linkparts = entry.linkpath.split(/\/|\\/);
					if (linkparts.length >= this.strip) entry.linkpath = linkparts.slice(this.strip).join("/");
				}
			}
			if (!this.preservePaths) {
				const p = entry.path;
				if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
					this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
						entry,
						path: p
					});
					return false;
				}
				if (path__default["default"].win32.isAbsolute(p)) {
					const parsed = path__default["default"].win32.parse(p);
					entry.path = p.substr(parsed.root.length);
					const r = parsed.root;
					this.warn("TAR_ENTRY_INFO", `stripping ${r} from absolute path`, {
						entry,
						path: p
					});
				}
			}
			if (this.win32) {
				const parsed = path__default["default"].win32.parse(entry.path);
				entry.path = parsed.root === "" ? winchars.encode(entry.path) : parsed.root + winchars.encode(entry.path.substr(parsed.root.length));
			}
			if (path__default["default"].isAbsolute(entry.path)) entry.absolute = entry.path;
else entry.absolute = path__default["default"].resolve(this.cwd, entry.path);
			return true;
		}
		[ONENTRY](entry) {
			if (!this[CHECKPATH](entry)) return entry.resume();
			assert__default["default"].equal(typeof entry.absolute, "string");
			switch (entry.type) {
				case "Directory":
				case "GNUDumpDir": if (entry.mode) entry.mode = entry.mode | 448;
				case "File":
				case "OldFile":
				case "ContiguousFile":
				case "Link":
				case "SymbolicLink": return this[CHECKFS](entry);
				case "CharacterDevice":
				case "BlockDevice":
				case "FIFO":
				default: return this[UNSUPPORTED](entry);
			}
		}
		[ONERROR](er, entry) {
			if (er.name === "CwdError") this.emit("error", er);
else {
				this.warn("TAR_ENTRY_ERROR", er, { entry });
				this[UNPEND]();
				entry.resume();
			}
		}
		[MKDIR](dir, mode, cb) {
			mkdir(dir, {
				uid: this.uid,
				gid: this.gid,
				processUid: this.processUid,
				processGid: this.processGid,
				umask: this.processUmask,
				preserve: this.preservePaths,
				unlink: this.unlink,
				cache: this.dirCache,
				cwd: this.cwd,
				mode,
				noChmod: this.noChmod
			}, cb);
		}
		[DOCHOWN](entry) {
			return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid;
		}
		[UID](entry) {
			return uint32(this.uid, entry.uid, this.processUid);
		}
		[GID](entry) {
			return uint32(this.gid, entry.gid, this.processGid);
		}
		[FILE](entry, fullyDone) {
			const mode = entry.mode & 4095 || this.fmode;
			const stream = new fsMinipass.WriteStream(entry.absolute, {
				flags: getWriteFlag(entry.size),
				mode,
				autoClose: false
			});
			stream.on("error", (er) => this[ONERROR](er, entry));
			let actions = 1;
			const done = (er) => {
				if (er) return this[ONERROR](er, entry);
				if (--actions === 0) fs__default["default"].close(stream.fd, (er$1) => {
					fullyDone();
					er$1 ? this[ONERROR](er$1, entry) : this[UNPEND]();
				});
			};
			stream.on("finish", (_) => {
				const abs = entry.absolute;
				const fd = stream.fd;
				if (entry.mtime && !this.noMtime) {
					actions++;
					const atime = entry.atime || new Date();
					const mtime = entry.mtime;
					fs__default["default"].futimes(fd, atime, mtime, (er) => er ? fs__default["default"].utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
				}
				if (this[DOCHOWN](entry)) {
					actions++;
					const uid = this[UID](entry);
					const gid = this[GID](entry);
					fs__default["default"].fchown(fd, uid, gid, (er) => er ? fs__default["default"].chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
				}
				done();
			});
			const tx = this.transform ? this.transform(entry) || entry : entry;
			if (tx !== entry) {
				tx.on("error", (er) => this[ONERROR](er, entry));
				entry.pipe(tx);
			}
			tx.pipe(stream);
		}
		[DIRECTORY](entry, fullyDone) {
			const mode = entry.mode & 4095 || this.dmode;
			this[MKDIR](entry.absolute, mode, (er) => {
				if (er) {
					fullyDone();
					return this[ONERROR](er, entry);
				}
				let actions = 1;
				const done = (_) => {
					if (--actions === 0) {
						fullyDone();
						this[UNPEND]();
						entry.resume();
					}
				};
				if (entry.mtime && !this.noMtime) {
					actions++;
					fs__default["default"].utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
				}
				if (this[DOCHOWN](entry)) {
					actions++;
					fs__default["default"].chown(entry.absolute, this[UID](entry), this[GID](entry), done);
				}
				done();
			});
		}
		[UNSUPPORTED](entry) {
			entry.unsupported = true;
			this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
			entry.resume();
		}
		[SYMLINK](entry, done) {
			this[LINK](entry, entry.linkpath, "symlink", done);
		}
		[HARDLINK](entry, done) {
			this[LINK](entry, path__default["default"].resolve(this.cwd, entry.linkpath), "link", done);
		}
		[PEND]() {
			this[PENDING]++;
		}
		[UNPEND]() {
			this[PENDING]--;
			this[MAYBECLOSE]();
		}
		[SKIP](entry) {
			this[UNPEND]();
			entry.resume();
		}
		[ISREUSABLE](entry, st) {
			return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== "win32";
		}
		[CHECKFS](entry) {
			this[PEND]();
			const paths = [entry.path];
			if (entry.linkpath) paths.push(entry.linkpath);
			this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
		}
		[CHECKFS2](entry, done) {
			this[MKDIR](path__default["default"].dirname(entry.absolute), this.dmode, (er) => {
				if (er) {
					done();
					return this[ONERROR](er, entry);
				}
				fs__default["default"].lstat(entry.absolute, (er$1, st) => {
					if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
						this[SKIP](entry);
						done();
					} else if (er$1 || this[ISREUSABLE](entry, st)) this[MAKEFS](null, entry, done);
else if (st.isDirectory()) if (entry.type === "Directory") if (!this.noChmod && (!entry.mode || (st.mode & 4095) === entry.mode)) this[MAKEFS](null, entry, done);
else fs__default["default"].chmod(entry.absolute, entry.mode, (er$2) => this[MAKEFS](er$2, entry, done));
else fs__default["default"].rmdir(entry.absolute, (er$2) => this[MAKEFS](er$2, entry, done));
else unlinkFile(entry.absolute, (er$2) => this[MAKEFS](er$2, entry, done));
				});
			});
		}
		[MAKEFS](er, entry, done) {
			if (er) return this[ONERROR](er, entry);
			switch (entry.type) {
				case "File":
				case "OldFile":
				case "ContiguousFile": return this[FILE](entry, done);
				case "Link": return this[HARDLINK](entry, done);
				case "SymbolicLink": return this[SYMLINK](entry, done);
				case "Directory":
				case "GNUDumpDir": return this[DIRECTORY](entry, done);
			}
		}
		[LINK](entry, linkpath, link$1, done) {
			fs__default["default"][link$1](linkpath, entry.absolute, (er) => {
				if (er) return this[ONERROR](er, entry);
				done();
				this[UNPEND]();
				entry.resume();
			});
		}
	};
	var UnpackSync = class extends Unpack {
		[CHECKFS](entry) {
			const er = this[MKDIR](path__default["default"].dirname(entry.absolute), this.dmode, neverCalled);
			if (er) return this[ONERROR](er, entry);
			try {
				const st = fs__default["default"].lstatSync(entry.absolute);
				if (this.keep || this.newer && st.mtime > entry.mtime) return this[SKIP](entry);
else if (this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry, neverCalled);
else try {
					if (st.isDirectory()) if (entry.type === "Directory") {
						if (!this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode) fs__default["default"].chmodSync(entry.absolute, entry.mode);
					} else fs__default["default"].rmdirSync(entry.absolute);
else unlinkFileSync(entry.absolute);
					return this[MAKEFS](null, entry, neverCalled);
				} catch (er$1) {
					return this[ONERROR](er$1, entry);
				}
			} catch (er$1) {
				return this[MAKEFS](null, entry, neverCalled);
			}
		}
		[FILE](entry, _) {
			const mode = entry.mode & 4095 || this.fmode;
			const oner = (er) => {
				let closeError;
				try {
					fs__default["default"].closeSync(fd);
				} catch (e) {
					closeError = e;
				}
				if (er || closeError) this[ONERROR](er || closeError, entry);
			};
			let fd;
			try {
				fd = fs__default["default"].openSync(entry.absolute, getWriteFlag(entry.size), mode);
			} catch (er) {
				return oner(er);
			}
			const tx = this.transform ? this.transform(entry) || entry : entry;
			if (tx !== entry) {
				tx.on("error", (er) => this[ONERROR](er, entry));
				entry.pipe(tx);
			}
			tx.on("data", (chunk) => {
				try {
					fs__default["default"].writeSync(fd, chunk, 0, chunk.length);
				} catch (er) {
					oner(er);
				}
			});
			tx.on("end", (_$1) => {
				let er = null;
				if (entry.mtime && !this.noMtime) {
					const atime = entry.atime || new Date();
					const mtime = entry.mtime;
					try {
						fs__default["default"].futimesSync(fd, atime, mtime);
					} catch (futimeser) {
						try {
							fs__default["default"].utimesSync(entry.absolute, atime, mtime);
						} catch (utimeser) {
							er = futimeser;
						}
					}
				}
				if (this[DOCHOWN](entry)) {
					const uid = this[UID](entry);
					const gid = this[GID](entry);
					try {
						fs__default["default"].fchownSync(fd, uid, gid);
					} catch (fchowner) {
						try {
							fs__default["default"].chownSync(entry.absolute, uid, gid);
						} catch (chowner) {
							er = er || fchowner;
						}
					}
				}
				oner(er);
			});
		}
		[DIRECTORY](entry, _) {
			const mode = entry.mode & 4095 || this.dmode;
			const er = this[MKDIR](entry.absolute, mode);
			if (er) return this[ONERROR](er, entry);
			if (entry.mtime && !this.noMtime) try {
				fs__default["default"].utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
			} catch (er$1) {}
			if (this[DOCHOWN](entry)) try {
				fs__default["default"].chownSync(entry.absolute, this[UID](entry), this[GID](entry));
			} catch (er$1) {}
			entry.resume();
		}
		[MKDIR](dir, mode) {
			try {
				return mkdir.sync(dir, {
					uid: this.uid,
					gid: this.gid,
					processUid: this.processUid,
					processGid: this.processGid,
					umask: this.processUmask,
					preserve: this.preservePaths,
					unlink: this.unlink,
					cache: this.dirCache,
					cwd: this.cwd,
					mode
				});
			} catch (er) {
				return er;
			}
		}
		[LINK](entry, linkpath, link$1, _) {
			try {
				fs__default["default"][link$1 + "Sync"](linkpath, entry.absolute);
				entry.resume();
			} catch (er) {
				return this[ONERROR](er, entry);
			}
		}
	};
	Unpack.Sync = UnpackSync;
	var unpack = Unpack;
	var extract_1 = (opt_, files, cb) => {
		if (typeof opt_ === "function") cb = opt_, files = null, opt_ = {};
else if (Array.isArray(opt_)) files = opt_, opt_ = {};
		if (typeof files === "function") cb = files, files = null;
		if (!files) files = [];
else files = Array.from(files);
		const opt = highLevelOpt(opt_);
		if (opt.sync && typeof cb === "function") throw new TypeError("callback not supported for sync tar functions");
		if (!opt.file && typeof cb === "function") throw new TypeError("callback only supported with file option");
		if (files.length) filesFilter(opt, files);
		return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
	};
	const filesFilter = (opt, files) => {
		const map$1 = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
		const filter$1 = opt.filter;
		const mapHas = (file, r) => {
			const root = r || path__default["default"].parse(file).root || ".";
			const ret = file === root ? false : map$1.has(file) ? map$1.get(file) : mapHas(path__default["default"].dirname(file), root);
			map$1.set(file, ret);
			return ret;
		};
		opt.filter = filter$1 ? (file, entry) => filter$1(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
	};
	const extractFileSync = (opt) => {
		const u = new unpack.Sync(opt);
		const file = opt.file;
		const stat = fs__default["default"].statSync(file);
		const readSize = opt.maxReadSize || 16777216;
		const stream = new fsMinipass.ReadStreamSync(file, {
			readSize,
			size: stat.size
		});
		stream.pipe(u);
	};
	const extractFile = (opt, cb) => {
		const u = new unpack(opt);
		const readSize = opt.maxReadSize || 16777216;
		const file = opt.file;
		const p = new Promise((resolve$2, reject) => {
			u.on("error", reject);
			u.on("close", resolve$2);
			fs__default["default"].stat(file, (er, stat) => {
				if (er) reject(er);
else {
					const stream = new fsMinipass.ReadStream(file, {
						readSize,
						size: stat.size
					});
					stream.on("error", reject);
					stream.pipe(u);
				}
			});
		});
		return cb ? p.then(cb, cb) : p;
	};
	const extractSync = (opt) => new unpack.Sync(opt);
	const extract = (opt) => new unpack(opt);
	var tar = createCommonjsModule(function(module$1, exports$1) {
		exports$1.c = exports$1.create = create_1;
		exports$1.r = exports$1.replace = replace_1;
		exports$1.t = exports$1.list = list_1;
		exports$1.u = exports$1.update = update;
		exports$1.x = exports$1.extract = extract_1;
		exports$1.Pack = pack;
		exports$1.Unpack = unpack;
		exports$1.Parse = parse$4;
		exports$1.ReadEntry = readEntry;
		exports$1.WriteEntry = writeEntry;
		exports$1.Header = header;
		exports$1.Pax = pax;
		exports$1.types = types;
	});
	var colorName = {
		"aliceblue": [
			240,
			248,
			255
		],
		"antiquewhite": [
			250,
			235,
			215
		],
		"aqua": [
			0,
			255,
			255
		],
		"aquamarine": [
			127,
			255,
			212
		],
		"azure": [
			240,
			255,
			255
		],
		"beige": [
			245,
			245,
			220
		],
		"bisque": [
			255,
			228,
			196
		],
		"black": [
			0,
			0,
			0
		],
		"blanchedalmond": [
			255,
			235,
			205
		],
		"blue": [
			0,
			0,
			255
		],
		"blueviolet": [
			138,
			43,
			226
		],
		"brown": [
			165,
			42,
			42
		],
		"burlywood": [
			222,
			184,
			135
		],
		"cadetblue": [
			95,
			158,
			160
		],
		"chartreuse": [
			127,
			255,
			0
		],
		"chocolate": [
			210,
			105,
			30
		],
		"coral": [
			255,
			127,
			80
		],
		"cornflowerblue": [
			100,
			149,
			237
		],
		"cornsilk": [
			255,
			248,
			220
		],
		"crimson": [
			220,
			20,
			60
		],
		"cyan": [
			0,
			255,
			255
		],
		"darkblue": [
			0,
			0,
			139
		],
		"darkcyan": [
			0,
			139,
			139
		],
		"darkgoldenrod": [
			184,
			134,
			11
		],
		"darkgray": [
			169,
			169,
			169
		],
		"darkgreen": [
			0,
			100,
			0
		],
		"darkgrey": [
			169,
			169,
			169
		],
		"darkkhaki": [
			189,
			183,
			107
		],
		"darkmagenta": [
			139,
			0,
			139
		],
		"darkolivegreen": [
			85,
			107,
			47
		],
		"darkorange": [
			255,
			140,
			0
		],
		"darkorchid": [
			153,
			50,
			204
		],
		"darkred": [
			139,
			0,
			0
		],
		"darksalmon": [
			233,
			150,
			122
		],
		"darkseagreen": [
			143,
			188,
			143
		],
		"darkslateblue": [
			72,
			61,
			139
		],
		"darkslategray": [
			47,
			79,
			79
		],
		"darkslategrey": [
			47,
			79,
			79
		],
		"darkturquoise": [
			0,
			206,
			209
		],
		"darkviolet": [
			148,
			0,
			211
		],
		"deeppink": [
			255,
			20,
			147
		],
		"deepskyblue": [
			0,
			191,
			255
		],
		"dimgray": [
			105,
			105,
			105
		],
		"dimgrey": [
			105,
			105,
			105
		],
		"dodgerblue": [
			30,
			144,
			255
		],
		"firebrick": [
			178,
			34,
			34
		],
		"floralwhite": [
			255,
			250,
			240
		],
		"forestgreen": [
			34,
			139,
			34
		],
		"fuchsia": [
			255,
			0,
			255
		],
		"gainsboro": [
			220,
			220,
			220
		],
		"ghostwhite": [
			248,
			248,
			255
		],
		"gold": [
			255,
			215,
			0
		],
		"goldenrod": [
			218,
			165,
			32
		],
		"gray": [
			128,
			128,
			128
		],
		"green": [
			0,
			128,
			0
		],
		"greenyellow": [
			173,
			255,
			47
		],
		"grey": [
			128,
			128,
			128
		],
		"honeydew": [
			240,
			255,
			240
		],
		"hotpink": [
			255,
			105,
			180
		],
		"indianred": [
			205,
			92,
			92
		],
		"indigo": [
			75,
			0,
			130
		],
		"ivory": [
			255,
			255,
			240
		],
		"khaki": [
			240,
			230,
			140
		],
		"lavender": [
			230,
			230,
			250
		],
		"lavenderblush": [
			255,
			240,
			245
		],
		"lawngreen": [
			124,
			252,
			0
		],
		"lemonchiffon": [
			255,
			250,
			205
		],
		"lightblue": [
			173,
			216,
			230
		],
		"lightcoral": [
			240,
			128,
			128
		],
		"lightcyan": [
			224,
			255,
			255
		],
		"lightgoldenrodyellow": [
			250,
			250,
			210
		],
		"lightgray": [
			211,
			211,
			211
		],
		"lightgreen": [
			144,
			238,
			144
		],
		"lightgrey": [
			211,
			211,
			211
		],
		"lightpink": [
			255,
			182,
			193
		],
		"lightsalmon": [
			255,
			160,
			122
		],
		"lightseagreen": [
			32,
			178,
			170
		],
		"lightskyblue": [
			135,
			206,
			250
		],
		"lightslategray": [
			119,
			136,
			153
		],
		"lightslategrey": [
			119,
			136,
			153
		],
		"lightsteelblue": [
			176,
			196,
			222
		],
		"lightyellow": [
			255,
			255,
			224
		],
		"lime": [
			0,
			255,
			0
		],
		"limegreen": [
			50,
			205,
			50
		],
		"linen": [
			250,
			240,
			230
		],
		"magenta": [
			255,
			0,
			255
		],
		"maroon": [
			128,
			0,
			0
		],
		"mediumaquamarine": [
			102,
			205,
			170
		],
		"mediumblue": [
			0,
			0,
			205
		],
		"mediumorchid": [
			186,
			85,
			211
		],
		"mediumpurple": [
			147,
			112,
			219
		],
		"mediumseagreen": [
			60,
			179,
			113
		],
		"mediumslateblue": [
			123,
			104,
			238
		],
		"mediumspringgreen": [
			0,
			250,
			154
		],
		"mediumturquoise": [
			72,
			209,
			204
		],
		"mediumvioletred": [
			199,
			21,
			133
		],
		"midnightblue": [
			25,
			25,
			112
		],
		"mintcream": [
			245,
			255,
			250
		],
		"mistyrose": [
			255,
			228,
			225
		],
		"moccasin": [
			255,
			228,
			181
		],
		"navajowhite": [
			255,
			222,
			173
		],
		"navy": [
			0,
			0,
			128
		],
		"oldlace": [
			253,
			245,
			230
		],
		"olive": [
			128,
			128,
			0
		],
		"olivedrab": [
			107,
			142,
			35
		],
		"orange": [
			255,
			165,
			0
		],
		"orangered": [
			255,
			69,
			0
		],
		"orchid": [
			218,
			112,
			214
		],
		"palegoldenrod": [
			238,
			232,
			170
		],
		"palegreen": [
			152,
			251,
			152
		],
		"paleturquoise": [
			175,
			238,
			238
		],
		"palevioletred": [
			219,
			112,
			147
		],
		"papayawhip": [
			255,
			239,
			213
		],
		"peachpuff": [
			255,
			218,
			185
		],
		"peru": [
			205,
			133,
			63
		],
		"pink": [
			255,
			192,
			203
		],
		"plum": [
			221,
			160,
			221
		],
		"powderblue": [
			176,
			224,
			230
		],
		"purple": [
			128,
			0,
			128
		],
		"rebeccapurple": [
			102,
			51,
			153
		],
		"red": [
			255,
			0,
			0
		],
		"rosybrown": [
			188,
			143,
			143
		],
		"royalblue": [
			65,
			105,
			225
		],
		"saddlebrown": [
			139,
			69,
			19
		],
		"salmon": [
			250,
			128,
			114
		],
		"sandybrown": [
			244,
			164,
			96
		],
		"seagreen": [
			46,
			139,
			87
		],
		"seashell": [
			255,
			245,
			238
		],
		"sienna": [
			160,
			82,
			45
		],
		"silver": [
			192,
			192,
			192
		],
		"skyblue": [
			135,
			206,
			235
		],
		"slateblue": [
			106,
			90,
			205
		],
		"slategray": [
			112,
			128,
			144
		],
		"slategrey": [
			112,
			128,
			144
		],
		"snow": [
			255,
			250,
			250
		],
		"springgreen": [
			0,
			255,
			127
		],
		"steelblue": [
			70,
			130,
			180
		],
		"tan": [
			210,
			180,
			140
		],
		"teal": [
			0,
			128,
			128
		],
		"thistle": [
			216,
			191,
			216
		],
		"tomato": [
			255,
			99,
			71
		],
		"turquoise": [
			64,
			224,
			208
		],
		"violet": [
			238,
			130,
			238
		],
		"wheat": [
			245,
			222,
			179
		],
		"white": [
			255,
			255,
			255
		],
		"whitesmoke": [
			245,
			245,
			245
		],
		"yellow": [
			255,
			255,
			0
		],
		"yellowgreen": [
			154,
			205,
			50
		]
	};
	const reverseKeywords = {};
	for (const key of Object.keys(colorName)) reverseKeywords[colorName[key]] = key;
	const convert$1 = {
		rgb: {
			channels: 3,
			labels: "rgb"
		},
		hsl: {
			channels: 3,
			labels: "hsl"
		},
		hsv: {
			channels: 3,
			labels: "hsv"
		},
		hwb: {
			channels: 3,
			labels: "hwb"
		},
		cmyk: {
			channels: 4,
			labels: "cmyk"
		},
		xyz: {
			channels: 3,
			labels: "xyz"
		},
		lab: {
			channels: 3,
			labels: "lab"
		},
		lch: {
			channels: 3,
			labels: "lch"
		},
		hex: {
			channels: 1,
			labels: ["hex"]
		},
		keyword: {
			channels: 1,
			labels: ["keyword"]
		},
		ansi16: {
			channels: 1,
			labels: ["ansi16"]
		},
		ansi256: {
			channels: 1,
			labels: ["ansi256"]
		},
		hcg: {
			channels: 3,
			labels: [
				"h",
				"c",
				"g"
			]
		},
		apple: {
			channels: 3,
			labels: [
				"r16",
				"g16",
				"b16"
			]
		},
		gray: {
			channels: 1,
			labels: ["gray"]
		}
	};
	var conversions = convert$1;
	for (const model of Object.keys(convert$1)) {
		if (!("channels" in convert$1[model])) throw new Error("missing channels property: " + model);
		if (!("labels" in convert$1[model])) throw new Error("missing channel labels property: " + model);
		if (convert$1[model].labels.length !== convert$1[model].channels) throw new Error("channel and label counts mismatch: " + model);
		const { channels, labels } = convert$1[model];
		delete convert$1[model].channels;
		delete convert$1[model].labels;
		Object.defineProperty(convert$1[model], "channels", { value: channels });
		Object.defineProperty(convert$1[model], "labels", { value: labels });
	}
	convert$1.rgb.hsl = function(rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const min = Math.min(r, g, b);
		const max = Math.max(r, g, b);
		const delta = max - min;
		let h$1;
		let s$1;
		if (max === min) h$1 = 0;
else if (r === max) h$1 = (g - b) / delta;
else if (g === max) h$1 = 2 + (b - r) / delta;
else if (b === max) h$1 = 4 + (r - g) / delta;
		h$1 = Math.min(h$1 * 60, 360);
		if (h$1 < 0) h$1 += 360;
		const l = (min + max) / 2;
		if (max === min) s$1 = 0;
else if (l <= .5) s$1 = delta / (max + min);
else s$1 = delta / (2 - max - min);
		return [
			h$1,
			s$1 * 100,
			l * 100
		];
	};
	convert$1.rgb.hsv = function(rgb) {
		let rdif;
		let gdif;
		let bdif;
		let h$1;
		let s$1;
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const v = Math.max(r, g, b);
		const diff = v - Math.min(r, g, b);
		const diffc = function(c) {
			return (v - c) / 6 / diff + .5;
		};
		if (diff === 0) {
			h$1 = 0;
			s$1 = 0;
		} else {
			s$1 = diff / v;
			rdif = diffc(r);
			gdif = diffc(g);
			bdif = diffc(b);
			if (r === v) h$1 = bdif - gdif;
else if (g === v) h$1 = .3333333333333333 + rdif - bdif;
else if (b === v) h$1 = .6666666666666666 + gdif - rdif;
			if (h$1 < 0) h$1 += 1;
else if (h$1 > 1) h$1 -= 1;
		}
		return [
			h$1 * 360,
			s$1 * 100,
			v * 100
		];
	};
	convert$1.rgb.hwb = function(rgb) {
		const r = rgb[0];
		const g = rgb[1];
		let b = rgb[2];
		const h$1 = convert$1.rgb.hsl(rgb)[0];
		const w$1 = .00392156862745098 * Math.min(r, Math.min(g, b));
		b = 1 - .00392156862745098 * Math.max(r, Math.max(g, b));
		return [
			h$1,
			w$1 * 100,
			b * 100
		];
	};
	convert$1.rgb.cmyk = function(rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const k = Math.min(1 - r, 1 - g, 1 - b);
		const c = (1 - r - k) / (1 - k) || 0;
		const m$1 = (1 - g - k) / (1 - k) || 0;
		const y$1 = (1 - b - k) / (1 - k) || 0;
		return [
			c * 100,
			m$1 * 100,
			y$1 * 100,
			k * 100
		];
	};
	function comparativeDistance(x, y$1) {
		return (x[0] - y$1[0]) ** 2 + (x[1] - y$1[1]) ** 2 + (x[2] - y$1[2]) ** 2;
	}
	convert$1.rgb.keyword = function(rgb) {
		const reversed = reverseKeywords[rgb];
		if (reversed) return reversed;
		let currentClosestDistance = Infinity;
		let currentClosestKeyword;
		for (const keyword of Object.keys(colorName)) {
			const value = colorName[keyword];
			const distance = comparativeDistance(rgb, value);
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
		return currentClosestKeyword;
	};
	convert$1.keyword.rgb = function(keyword) {
		return colorName[keyword];
	};
	convert$1.rgb.xyz = function(rgb) {
		let r = rgb[0] / 255;
		let g = rgb[1] / 255;
		let b = rgb[2] / 255;
		r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92;
		g = g > .04045 ? ((g + .055) / 1.055) ** 2.4 : g / 12.92;
		b = b > .04045 ? ((b + .055) / 1.055) ** 2.4 : b / 12.92;
		const x = r * .4124 + g * .3576 + b * .1805;
		const y$1 = r * .2126 + g * .7152 + b * .0722;
		const z = r * .0193 + g * .1192 + b * .9505;
		return [
			x * 100,
			y$1 * 100,
			z * 100
		];
	};
	convert$1.rgb.lab = function(rgb) {
		const xyz = convert$1.rgb.xyz(rgb);
		let x = xyz[0];
		let y$1 = xyz[1];
		let z = xyz[2];
		x /= 95.047;
		y$1 /= 100;
		z /= 108.883;
		x = x > .008856 ? x ** .3333333333333333 : 7.787 * x + .13793103448275862;
		y$1 = y$1 > .008856 ? y$1 ** .3333333333333333 : 7.787 * y$1 + .13793103448275862;
		z = z > .008856 ? z ** .3333333333333333 : 7.787 * z + .13793103448275862;
		const l = 116 * y$1 - 16;
		const a = 500 * (x - y$1);
		const b = 200 * (y$1 - z);
		return [
			l,
			a,
			b
		];
	};
	convert$1.hsl.rgb = function(hsl) {
		const h$1 = hsl[0] / 360;
		const s$1 = hsl[1] / 100;
		const l = hsl[2] / 100;
		let t2;
		let t3;
		let val;
		if (s$1 === 0) {
			val = l * 255;
			return [
				val,
				val,
				val
			];
		}
		if (l < .5) t2 = l * (1 + s$1);
else t2 = l + s$1 - l * s$1;
		const t1 = 2 * l - t2;
		const rgb = [
			0,
			0,
			0
		];
		for (let i = 0; i < 3; i++) {
			t3 = h$1 + .3333333333333333 * -(i - 1);
			if (t3 < 0) t3++;
			if (t3 > 1) t3--;
			if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;
else if (2 * t3 < 1) val = t2;
else if (3 * t3 < 2) val = t1 + (t2 - t1) * (.6666666666666666 - t3) * 6;
else val = t1;
			rgb[i] = val * 255;
		}
		return rgb;
	};
	convert$1.hsl.hsv = function(hsl) {
		const h$1 = hsl[0];
		let s$1 = hsl[1] / 100;
		let l = hsl[2] / 100;
		let smin = s$1;
		const lmin = Math.max(l, .01);
		l *= 2;
		s$1 *= l <= 1 ? l : 2 - l;
		smin *= lmin <= 1 ? lmin : 2 - lmin;
		const v = (l + s$1) / 2;
		const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s$1 / (l + s$1);
		return [
			h$1,
			sv * 100,
			v * 100
		];
	};
	convert$1.hsv.rgb = function(hsv) {
		const h$1 = hsv[0] / 60;
		const s$1 = hsv[1] / 100;
		let v = hsv[2] / 100;
		const hi = Math.floor(h$1) % 6;
		const f = h$1 - Math.floor(h$1);
		const p = 255 * v * (1 - s$1);
		const q = 255 * v * (1 - s$1 * f);
		const t = 255 * v * (1 - s$1 * (1 - f));
		v *= 255;
		switch (hi) {
			case 0: return [
				v,
				t,
				p
			];
			case 1: return [
				q,
				v,
				p
			];
			case 2: return [
				p,
				v,
				t
			];
			case 3: return [
				p,
				q,
				v
			];
			case 4: return [
				t,
				p,
				v
			];
			case 5: return [
				v,
				p,
				q
			];
		}
	};
	convert$1.hsv.hsl = function(hsv) {
		const h$1 = hsv[0];
		const s$1 = hsv[1] / 100;
		const v = hsv[2] / 100;
		const vmin = Math.max(v, .01);
		let sl;
		let l;
		l = (2 - s$1) * v;
		const lmin = (2 - s$1) * vmin;
		sl = s$1 * vmin;
		sl /= lmin <= 1 ? lmin : 2 - lmin;
		sl = sl || 0;
		l /= 2;
		return [
			h$1,
			sl * 100,
			l * 100
		];
	};
	convert$1.hwb.rgb = function(hwb) {
		const h$1 = hwb[0] / 360;
		let wh = hwb[1] / 100;
		let bl = hwb[2] / 100;
		const ratio = wh + bl;
		let f;
		if (ratio > 1) {
			wh /= ratio;
			bl /= ratio;
		}
		const i = Math.floor(6 * h$1);
		const v = 1 - bl;
		f = 6 * h$1 - i;
		if ((i & 1) !== 0) f = 1 - f;
		const n = wh + f * (v - wh);
		let r;
		let g;
		let b;
		switch (i) {
			default:
			case 6:
			case 0:
				r = v;
				g = n;
				b = wh;
				break;
			case 1:
				r = n;
				g = v;
				b = wh;
				break;
			case 2:
				r = wh;
				g = v;
				b = n;
				break;
			case 3:
				r = wh;
				g = n;
				b = v;
				break;
			case 4:
				r = n;
				g = wh;
				b = v;
				break;
			case 5:
				r = v;
				g = wh;
				b = n;
				break;
		}
		return [
			r * 255,
			g * 255,
			b * 255
		];
	};
	convert$1.cmyk.rgb = function(cmyk) {
		const c = cmyk[0] / 100;
		const m$1 = cmyk[1] / 100;
		const y$1 = cmyk[2] / 100;
		const k = cmyk[3] / 100;
		const r = 1 - Math.min(1, c * (1 - k) + k);
		const g = 1 - Math.min(1, m$1 * (1 - k) + k);
		const b = 1 - Math.min(1, y$1 * (1 - k) + k);
		return [
			r * 255,
			g * 255,
			b * 255
		];
	};
	convert$1.xyz.rgb = function(xyz) {
		const x = xyz[0] / 100;
		const y$1 = xyz[1] / 100;
		const z = xyz[2] / 100;
		let r;
		let g;
		let b;
		r = x * 3.2406 + y$1 * -1.5372 + z * -.4986;
		g = x * -.9689 + y$1 * 1.8758 + z * .0415;
		b = x * .0557 + y$1 * -.204 + z * 1.057;
		r = r > .0031308 ? 1.055 * r ** .4166666666666667 - .055 : r * 12.92;
		g = g > .0031308 ? 1.055 * g ** .4166666666666667 - .055 : g * 12.92;
		b = b > .0031308 ? 1.055 * b ** .4166666666666667 - .055 : b * 12.92;
		r = Math.min(Math.max(0, r), 1);
		g = Math.min(Math.max(0, g), 1);
		b = Math.min(Math.max(0, b), 1);
		return [
			r * 255,
			g * 255,
			b * 255
		];
	};
	convert$1.xyz.lab = function(xyz) {
		let x = xyz[0];
		let y$1 = xyz[1];
		let z = xyz[2];
		x /= 95.047;
		y$1 /= 100;
		z /= 108.883;
		x = x > .008856 ? x ** .3333333333333333 : 7.787 * x + .13793103448275862;
		y$1 = y$1 > .008856 ? y$1 ** .3333333333333333 : 7.787 * y$1 + .13793103448275862;
		z = z > .008856 ? z ** .3333333333333333 : 7.787 * z + .13793103448275862;
		const l = 116 * y$1 - 16;
		const a = 500 * (x - y$1);
		const b = 200 * (y$1 - z);
		return [
			l,
			a,
			b
		];
	};
	convert$1.lab.xyz = function(lab) {
		const l = lab[0];
		const a = lab[1];
		const b = lab[2];
		let x;
		let y$1;
		let z;
		y$1 = (l + 16) / 116;
		x = a / 500 + y$1;
		z = y$1 - b / 200;
		const y2 = y$1 ** 3;
		const x2 = x ** 3;
		const z2 = z ** 3;
		y$1 = y2 > .008856 ? y2 : (y$1 - .13793103448275862) / 7.787;
		x = x2 > .008856 ? x2 : (x - .13793103448275862) / 7.787;
		z = z2 > .008856 ? z2 : (z - .13793103448275862) / 7.787;
		x *= 95.047;
		y$1 *= 100;
		z *= 108.883;
		return [
			x,
			y$1,
			z
		];
	};
	convert$1.lab.lch = function(lab) {
		const l = lab[0];
		const a = lab[1];
		const b = lab[2];
		let h$1;
		const hr = Math.atan2(b, a);
		h$1 = hr * 360 / 2 / Math.PI;
		if (h$1 < 0) h$1 += 360;
		const c = Math.sqrt(a * a + b * b);
		return [
			l,
			c,
			h$1
		];
	};
	convert$1.lch.lab = function(lch) {
		const l = lch[0];
		const c = lch[1];
		const h$1 = lch[2];
		const hr = h$1 / 360 * 2 * Math.PI;
		const a = c * Math.cos(hr);
		const b = c * Math.sin(hr);
		return [
			l,
			a,
			b
		];
	};
	convert$1.rgb.ansi16 = function(args, saturation = null) {
		const [r, g, b] = args;
		let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
		value = Math.round(value / 50);
		if (value === 0) return 30;
		let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
		if (value === 2) ansi += 60;
		return ansi;
	};
	convert$1.hsv.ansi16 = function(args) {
		return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
	};
	convert$1.rgb.ansi256 = function(args) {
		const r = args[0];
		const g = args[1];
		const b = args[2];
		if (r === g && g === b) {
			if (r < 8) return 16;
			if (r > 248) return 231;
			return Math.round((r - 8) / 247 * 24) + 232;
		}
		const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
		return ansi;
	};
	convert$1.ansi16.rgb = function(args) {
		let color = args % 10;
		if (color === 0 || color === 7) {
			if (args > 50) color += 3.5;
			color = color / 10.5 * 255;
			return [
				color,
				color,
				color
			];
		}
		const mult = (~~(args > 50) + 1) * .5;
		const r = (color & 1) * mult * 255;
		const g = (color >> 1 & 1) * mult * 255;
		const b = (color >> 2 & 1) * mult * 255;
		return [
			r,
			g,
			b
		];
	};
	convert$1.ansi256.rgb = function(args) {
		if (args >= 232) {
			const c = (args - 232) * 10 + 8;
			return [
				c,
				c,
				c
			];
		}
		args -= 16;
		let rem;
		const r = Math.floor(args / 36) / 5 * 255;
		const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
		const b = rem % 6 / 5 * 255;
		return [
			r,
			g,
			b
		];
	};
	convert$1.rgb.hex = function(args) {
		const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
		const string = integer.toString(16).toUpperCase();
		return "000000".substring(string.length) + string;
	};
	convert$1.hex.rgb = function(args) {
		const match$1 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
		if (!match$1) return [
			0,
			0,
			0
		];
		let colorString = match$1[0];
		if (match$1[0].length === 3) colorString = colorString.split("").map((char) => {
			return char + char;
		}).join("");
		const integer = parseInt(colorString, 16);
		const r = integer >> 16 & 255;
		const g = integer >> 8 & 255;
		const b = integer & 255;
		return [
			r,
			g,
			b
		];
	};
	convert$1.rgb.hcg = function(rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const max = Math.max(Math.max(r, g), b);
		const min = Math.min(Math.min(r, g), b);
		const chroma = max - min;
		let grayscale;
		let hue;
		if (chroma < 1) grayscale = min / (1 - chroma);
else grayscale = 0;
		if (chroma <= 0) hue = 0;
else if (max === r) hue = (g - b) / chroma % 6;
else if (max === g) hue = 2 + (b - r) / chroma;
else hue = 4 + (r - g) / chroma;
		hue /= 6;
		hue %= 1;
		return [
			hue * 360,
			chroma * 100,
			grayscale * 100
		];
	};
	convert$1.hsl.hcg = function(hsl) {
		const s$1 = hsl[1] / 100;
		const l = hsl[2] / 100;
		const c = l < .5 ? 2 * s$1 * l : 2 * s$1 * (1 - l);
		let f = 0;
		if (c < 1) f = (l - .5 * c) / (1 - c);
		return [
			hsl[0],
			c * 100,
			f * 100
		];
	};
	convert$1.hsv.hcg = function(hsv) {
		const s$1 = hsv[1] / 100;
		const v = hsv[2] / 100;
		const c = s$1 * v;
		let f = 0;
		if (c < 1) f = (v - c) / (1 - c);
		return [
			hsv[0],
			c * 100,
			f * 100
		];
	};
	convert$1.hcg.rgb = function(hcg) {
		const h$1 = hcg[0] / 360;
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;
		if (c === 0) return [
			g * 255,
			g * 255,
			g * 255
		];
		const pure = [
			0,
			0,
			0
		];
		const hi = h$1 % 1 * 6;
		const v = hi % 1;
		const w$1 = 1 - v;
		let mg = 0;
		switch (Math.floor(hi)) {
			case 0:
				pure[0] = 1;
				pure[1] = v;
				pure[2] = 0;
				break;
			case 1:
				pure[0] = w$1;
				pure[1] = 1;
				pure[2] = 0;
				break;
			case 2:
				pure[0] = 0;
				pure[1] = 1;
				pure[2] = v;
				break;
			case 3:
				pure[0] = 0;
				pure[1] = w$1;
				pure[2] = 1;
				break;
			case 4:
				pure[0] = v;
				pure[1] = 0;
				pure[2] = 1;
				break;
			default:
				pure[0] = 1;
				pure[1] = 0;
				pure[2] = w$1;
		}
		mg = (1 - c) * g;
		return [
			(c * pure[0] + mg) * 255,
			(c * pure[1] + mg) * 255,
			(c * pure[2] + mg) * 255
		];
	};
	convert$1.hcg.hsv = function(hcg) {
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;
		const v = c + g * (1 - c);
		let f = 0;
		if (v > 0) f = c / v;
		return [
			hcg[0],
			f * 100,
			v * 100
		];
	};
	convert$1.hcg.hsl = function(hcg) {
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;
		const l = g * (1 - c) + .5 * c;
		let s$1 = 0;
		if (l > 0 && l < .5) s$1 = c / (2 * l);
else if (l >= .5 && l < 1) s$1 = c / (2 * (1 - l));
		return [
			hcg[0],
			s$1 * 100,
			l * 100
		];
	};
	convert$1.hcg.hwb = function(hcg) {
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;
		const v = c + g * (1 - c);
		return [
			hcg[0],
			(v - c) * 100,
			(1 - v) * 100
		];
	};
	convert$1.hwb.hcg = function(hwb) {
		const w$1 = hwb[1] / 100;
		const b = hwb[2] / 100;
		const v = 1 - b;
		const c = v - w$1;
		let g = 0;
		if (c < 1) g = (v - c) / (1 - c);
		return [
			hwb[0],
			c * 100,
			g * 100
		];
	};
	convert$1.apple.rgb = function(apple) {
		return [
			apple[0] / 65535 * 255,
			apple[1] / 65535 * 255,
			apple[2] / 65535 * 255
		];
	};
	convert$1.rgb.apple = function(rgb) {
		return [
			rgb[0] / 255 * 65535,
			rgb[1] / 255 * 65535,
			rgb[2] / 255 * 65535
		];
	};
	convert$1.gray.rgb = function(args) {
		return [
			args[0] / 100 * 255,
			args[0] / 100 * 255,
			args[0] / 100 * 255
		];
	};
	convert$1.gray.hsl = function(args) {
		return [
			0,
			0,
			args[0]
		];
	};
	convert$1.gray.hsv = convert$1.gray.hsl;
	convert$1.gray.hwb = function(gray) {
		return [
			0,
			100,
			gray[0]
		];
	};
	convert$1.gray.cmyk = function(gray) {
		return [
			0,
			0,
			0,
			gray[0]
		];
	};
	convert$1.gray.lab = function(gray) {
		return [
			gray[0],
			0,
			0
		];
	};
	convert$1.gray.hex = function(gray) {
		const val = Math.round(gray[0] / 100 * 255) & 255;
		const integer = (val << 16) + (val << 8) + val;
		const string = integer.toString(16).toUpperCase();
		return "000000".substring(string.length) + string;
	};
	convert$1.rgb.gray = function(rgb) {
		const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
		return [val / 255 * 100];
	};
	function buildGraph() {
		const graph = {};
		const models$1 = Object.keys(conversions);
		for (let len = models$1.length, i = 0; i < len; i++) graph[models$1[i]] = {
			distance: -1,
			parent: null
		};
		return graph;
	}
	function deriveBFS(fromModel) {
		const graph = buildGraph();
		const queue = [fromModel];
		graph[fromModel].distance = 0;
		while (queue.length) {
			const current = queue.pop();
			const adjacents = Object.keys(conversions[current]);
			for (let len = adjacents.length, i = 0; i < len; i++) {
				const adjacent = adjacents[i];
				const node$1 = graph[adjacent];
				if (node$1.distance === -1) {
					node$1.distance = graph[current].distance + 1;
					node$1.parent = current;
					queue.unshift(adjacent);
				}
			}
		}
		return graph;
	}
	function link(from$1, to) {
		return function(args) {
			return to(from$1(args));
		};
	}
	function wrapConversion(toModel, graph) {
		const path$3 = [graph[toModel].parent, toModel];
		let fn = conversions[graph[toModel].parent][toModel];
		let cur = graph[toModel].parent;
		while (graph[cur].parent) {
			path$3.unshift(graph[cur].parent);
			fn = link(conversions[graph[cur].parent][cur], fn);
			cur = graph[cur].parent;
		}
		fn.conversion = path$3;
		return fn;
	}
	var route = function(fromModel) {
		const graph = deriveBFS(fromModel);
		const conversion = {};
		const models$1 = Object.keys(graph);
		for (let len = models$1.length, i = 0; i < len; i++) {
			const toModel = models$1[i];
			const node$1 = graph[toModel];
			if (node$1.parent === null) continue;
			conversion[toModel] = wrapConversion(toModel, graph);
		}
		return conversion;
	};
	const convert = {};
	const models = Object.keys(conversions);
	function wrapRaw(fn) {
		const wrappedFn = function(...args) {
			const arg0 = args[0];
			if (arg0 === undefined || arg0 === null) return arg0;
			if (arg0.length > 1) args = arg0;
			return fn(args);
		};
		if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
		return wrappedFn;
	}
	function wrapRounded(fn) {
		const wrappedFn = function(...args) {
			const arg0 = args[0];
			if (arg0 === undefined || arg0 === null) return arg0;
			if (arg0.length > 1) args = arg0;
			const result = fn(args);
			if (typeof result === "object") for (let len = result.length, i = 0; i < len; i++) result[i] = Math.round(result[i]);
			return result;
		};
		if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
		return wrappedFn;
	}
	models.forEach((fromModel) => {
		convert[fromModel] = {};
		Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
		Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
		const routes = route(fromModel);
		const routeModels = Object.keys(routes);
		routeModels.forEach((toModel) => {
			const fn = routes[toModel];
			convert[fromModel][toModel] = wrapRounded(fn);
			convert[fromModel][toModel].raw = wrapRaw(fn);
		});
	});
	var colorConvert = convert;
	var ansiStyles = createCommonjsModule(function(module$1) {
		const wrapAnsi16 = (fn, offset) => (...args) => {
			const code = fn(...args);
			return `\u001B[${code + offset}m`;
		};
		const wrapAnsi256 = (fn, offset) => (...args) => {
			const code = fn(...args);
			return `\u001B[${38 + offset};5;${code}m`;
		};
		const wrapAnsi16m = (fn, offset) => (...args) => {
			const rgb = fn(...args);
			return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
		};
		const ansi2ansi = (n) => n;
		const rgb2rgb = (r, g, b) => [
			r,
			g,
			b
		];
		const setLazyProperty = (object, property, get) => {
			Object.defineProperty(object, property, {
				get: () => {
					const value = get();
					Object.defineProperty(object, property, {
						value,
						enumerable: true,
						configurable: true
					});
					return value;
				},
				enumerable: true,
				configurable: true
			});
		};
		/** @type {typeof import('color-convert')} */
		let colorConvert$1;
		const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
			if (colorConvert$1 === undefined) colorConvert$1 = colorConvert;
			const offset = isBackground ? 10 : 0;
			const styles$1 = {};
			for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
				const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
				if (sourceSpace === targetSpace) styles$1[name] = wrap(identity, offset);
else if (typeof suite === "object") styles$1[name] = wrap(suite[targetSpace], offset);
			}
			return styles$1;
		};
		function assembleStyles() {
			const codes = new Map();
			const styles$1 = {
				modifier: {
					reset: [0, 0],
					bold: [1, 22],
					dim: [2, 22],
					italic: [3, 23],
					underline: [4, 24],
					inverse: [7, 27],
					hidden: [8, 28],
					strikethrough: [9, 29]
				},
				color: {
					black: [30, 39],
					red: [31, 39],
					green: [32, 39],
					yellow: [33, 39],
					blue: [34, 39],
					magenta: [35, 39],
					cyan: [36, 39],
					white: [37, 39],
					blackBright: [90, 39],
					redBright: [91, 39],
					greenBright: [92, 39],
					yellowBright: [93, 39],
					blueBright: [94, 39],
					magentaBright: [95, 39],
					cyanBright: [96, 39],
					whiteBright: [97, 39]
				},
				bgColor: {
					bgBlack: [40, 49],
					bgRed: [41, 49],
					bgGreen: [42, 49],
					bgYellow: [43, 49],
					bgBlue: [44, 49],
					bgMagenta: [45, 49],
					bgCyan: [46, 49],
					bgWhite: [47, 49],
					bgBlackBright: [100, 49],
					bgRedBright: [101, 49],
					bgGreenBright: [102, 49],
					bgYellowBright: [103, 49],
					bgBlueBright: [104, 49],
					bgMagentaBright: [105, 49],
					bgCyanBright: [106, 49],
					bgWhiteBright: [107, 49]
				}
			};
			styles$1.color.gray = styles$1.color.blackBright;
			styles$1.bgColor.bgGray = styles$1.bgColor.bgBlackBright;
			styles$1.color.grey = styles$1.color.blackBright;
			styles$1.bgColor.bgGrey = styles$1.bgColor.bgBlackBright;
			for (const [groupName, group] of Object.entries(styles$1)) {
				for (const [styleName, style] of Object.entries(group)) {
					styles$1[styleName] = {
						open: `\u001B[${style[0]}m`,
						close: `\u001B[${style[1]}m`
					};
					group[styleName] = styles$1[styleName];
					codes.set(style[0], style[1]);
				}
				Object.defineProperty(styles$1, groupName, {
					value: group,
					enumerable: false
				});
			}
			Object.defineProperty(styles$1, "codes", {
				value: codes,
				enumerable: false
			});
			styles$1.color.close = "\x1B[39m";
			styles$1.bgColor.close = "\x1B[49m";
			setLazyProperty(styles$1.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
			setLazyProperty(styles$1.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
			setLazyProperty(styles$1.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
			setLazyProperty(styles$1.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
			setLazyProperty(styles$1.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
			setLazyProperty(styles$1.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
			return styles$1;
		}
		Object.defineProperty(module$1, "exports", {
			enumerable: true,
			get: assembleStyles
		});
	});
	var hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	const { env: env$1 } = process;
	let forceColor;
	if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) forceColor = 0;
else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) forceColor = 1;
	if ("FORCE_COLOR" in env$1) if (env$1.FORCE_COLOR === "true") forceColor = 1;
else if (env$1.FORCE_COLOR === "false") forceColor = 0;
else forceColor = env$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$1.FORCE_COLOR, 10), 3);
	function translateLevel(level) {
		if (level === 0) return false;
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) return 0;
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
		if (haveStream && !streamIsTTY && forceColor === undefined) return 0;
		const min = forceColor || 0;
		if (env$1.TERM === "dumb") return min;
		if (process.platform === "win32") {
			const osRelease = os__default["default"].release().split(".");
			if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
			return 1;
		}
		if ("CI" in env$1) {
			if ([
				"TRAVIS",
				"CIRCLECI",
				"APPVEYOR",
				"GITLAB_CI",
				"GITHUB_ACTIONS",
				"BUILDKITE"
			].some((sign) => sign in env$1) || env$1.CI_NAME === "codeship") return 1;
			return min;
		}
		if ("TEAMCITY_VERSION" in env$1) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
		if (env$1.COLORTERM === "truecolor") return 3;
		if ("TERM_PROGRAM" in env$1) {
			const version$2 = parseInt((env$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env$1.TERM_PROGRAM) {
				case "iTerm.app": return version$2 >= 3 ? 3 : 2;
				case "Apple_Terminal": return 2;
			}
		}
		if (/-256(color)?$/i.test(env$1.TERM)) return 2;
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) return 1;
		if ("COLORTERM" in env$1) return 1;
		return min;
	}
	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}
	var supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty__default["default"].isatty(1))),
		stderr: translateLevel(supportsColor(true, tty__default["default"].isatty(2)))
	};
	const stringReplaceAll$1 = (string, substring, replacer) => {
		let index$1 = string.indexOf(substring);
		if (index$1 === -1) return string;
		const substringLength = substring.length;
		let endIndex = 0;
		let returnValue = "";
		do {
			returnValue += string.substr(endIndex, index$1 - endIndex) + substring + replacer;
			endIndex = index$1 + substringLength;
			index$1 = string.indexOf(substring, endIndex);
		} while (index$1 !== -1);
		returnValue += string.substr(endIndex);
		return returnValue;
	};
	const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index$1) => {
		let endIndex = 0;
		let returnValue = "";
		do {
			const gotCR = string[index$1 - 1] === "\r";
			returnValue += string.substr(endIndex, (gotCR ? index$1 - 1 : index$1) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
			endIndex = index$1 + 1;
			index$1 = string.indexOf("\n", endIndex);
		} while (index$1 !== -1);
		returnValue += string.substr(endIndex);
		return returnValue;
	};
	var util = {
		stringReplaceAll: stringReplaceAll$1,
		stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
	};
	const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
	const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
	const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
	const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
	const ESCAPES = new Map([
		["n", "\n"],
		["r", "\r"],
		["t", "	"],
		["b", "\b"],
		["f", "\f"],
		["v", "\v"],
		["0", "\0"],
		["\\", "\\"],
		["e", "\x1B"],
		["a", "\x07"]
	]);
	function unescape(c) {
		const u = c[0] === "u";
		const bracket = c[1] === "{";
		if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) return String.fromCharCode(parseInt(c.slice(1), 16));
		if (u && bracket) return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
		return ESCAPES.get(c) || c;
	}
	function parseArguments(name, arguments_) {
		const results = [];
		const chunks = arguments_.trim().split(/\s*,\s*/g);
		let matches;
		for (const chunk of chunks) {
			const number = Number(chunk);
			if (!Number.isNaN(number)) results.push(number);
else if (matches = chunk.match(STRING_REGEX)) results.push(matches[2].replace(ESCAPE_REGEX, (m$1, escape, character) => escape ? unescape(escape) : character));
else throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
		return results;
	}
	function parseStyle(style) {
		STYLE_REGEX.lastIndex = 0;
		const results = [];
		let matches;
		while ((matches = STYLE_REGEX.exec(style)) !== null) {
			const name = matches[1];
			if (matches[2]) {
				const args = parseArguments(name, matches[2]);
				results.push([name].concat(args));
			} else results.push([name]);
		}
		return results;
	}
	function buildStyle(chalk$1, styles$1) {
		const enabled = {};
		for (const layer of styles$1) for (const style of layer.styles) enabled[style[0]] = layer.inverse ? null : style.slice(1);
		let current = chalk$1;
		for (const [styleName, styles$2] of Object.entries(enabled)) {
			if (!Array.isArray(styles$2)) continue;
			if (!(styleName in current)) throw new Error(`Unknown Chalk style: ${styleName}`);
			current = styles$2.length > 0 ? current[styleName](...styles$2) : current[styleName];
		}
		return current;
	}
	var templates = (chalk$1, temporary) => {
		const styles$1 = [];
		const chunks = [];
		let chunk = [];
		temporary.replace(TEMPLATE_REGEX, (m$1, escapeCharacter, inverse, style, close, character) => {
			if (escapeCharacter) chunk.push(unescape(escapeCharacter));
else if (style) {
				const string = chunk.join("");
				chunk = [];
				chunks.push(styles$1.length === 0 ? string : buildStyle(chalk$1, styles$1)(string));
				styles$1.push({
					inverse,
					styles: parseStyle(style)
				});
			} else if (close) {
				if (styles$1.length === 0) throw new Error("Found extraneous } in Chalk template literal");
				chunks.push(buildStyle(chalk$1, styles$1)(chunk.join("")));
				chunk = [];
				styles$1.pop();
			} else chunk.push(character);
		});
		chunks.push(chunk.join(""));
		if (styles$1.length > 0) {
			const errMessage = `Chalk template literal is missing ${styles$1.length} closing bracket${styles$1.length === 1 ? "" : "s"} (\`}\`)`;
			throw new Error(errMessage);
		}
		return chunks.join("");
	};
	const { stdout: stdoutColor, stderr: stderrColor } = supportsColor_1;
	const { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = util;
	const { isArray: isArray$1 } = Array;
	const levelMapping = [
		"ansi",
		"ansi",
		"ansi256",
		"ansi16m"
	];
	const styles = Object.create(null);
	const applyOptions = (object, options = {}) => {
		if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
		const colorLevel = stdoutColor ? stdoutColor.level : 0;
		object.level = options.level === undefined ? colorLevel : options.level;
	};
	var ChalkClass = class {
		constructor(options) {
			return chalkFactory(options);
		}
	};
	const chalkFactory = (options) => {
		const chalk$1 = {};
		applyOptions(chalk$1, options);
		chalk$1.template = (...arguments_) => chalkTag(chalk$1.template, ...arguments_);
		Object.setPrototypeOf(chalk$1, Chalk.prototype);
		Object.setPrototypeOf(chalk$1.template, chalk$1);
		chalk$1.template.constructor = () => {
			throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
		};
		chalk$1.template.Instance = ChalkClass;
		return chalk$1.template;
	};
	function Chalk(options) {
		return chalkFactory(options);
	}
	for (const [styleName, style] of Object.entries(ansiStyles)) styles[styleName] = { get() {
		const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
		Object.defineProperty(this, styleName, { value: builder });
		return builder;
	} };
	styles.visible = { get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, "visible", { value: builder });
		return builder;
	} };
	const usedModels = [
		"rgb",
		"hex",
		"keyword",
		"hsl",
		"hsv",
		"hwb",
		"ansi",
		"ansi256"
	];
	for (const model of usedModels) styles[model] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
			return createBuilder(this, styler, this._isEmpty);
		};
	} };
	for (const model of usedModels) {
		const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
		styles[bgModel] = { get() {
			const { level } = this;
			return function(...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		} };
	}
	const proto = Object.defineProperties(() => {}, {
		...styles,
		level: {
			enumerable: true,
			get() {
				return this._generator.level;
			},
			set(level) {
				this._generator.level = level;
			}
		}
	});
	const createStyler = (open, close, parent) => {
		let openAll;
		let closeAll;
		if (parent === undefined) {
			openAll = open;
			closeAll = close;
		} else {
			openAll = parent.openAll + open;
			closeAll = close + parent.closeAll;
		}
		return {
			open,
			close,
			openAll,
			closeAll,
			parent
		};
	};
	const createBuilder = (self$1, _styler, _isEmpty) => {
		const builder = (...arguments_) => {
			if (isArray$1(arguments_[0]) && isArray$1(arguments_[0].raw)) return applyStyle(builder, chalkTag(builder, ...arguments_));
			return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
		};
		Object.setPrototypeOf(builder, proto);
		builder._generator = self$1;
		builder._styler = _styler;
		builder._isEmpty = _isEmpty;
		return builder;
	};
	const applyStyle = (self$1, string) => {
		if (self$1.level <= 0 || !string) return self$1._isEmpty ? "" : string;
		let styler = self$1._styler;
		if (styler === undefined) return string;
		const { openAll, closeAll } = styler;
		if (string.indexOf("\x1B") !== -1) while (styler !== undefined) {
			string = stringReplaceAll(string, styler.close, styler.open);
			styler = styler.parent;
		}
		const lfIndex = string.indexOf("\n");
		if (lfIndex !== -1) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
		return openAll + string + closeAll;
	};
	let template;
	const chalkTag = (chalk$1, ...strings) => {
		const [firstString] = strings;
		if (!isArray$1(firstString) || !isArray$1(firstString.raw)) return strings.join(" ");
		const arguments_ = strings.slice(1);
		const parts = [firstString.raw[0]];
		for (let i = 1; i < firstString.length; i++) parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
		if (template === undefined) template = templates;
		return template(chalk$1, parts.join(""));
	};
	Object.defineProperties(Chalk.prototype, styles);
	const chalk = Chalk();
	chalk.supportsColor = stdoutColor;
	chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
	chalk.stderr.supportsColor = stderrColor;
	var source = chalk;
	var fs_1 = clone(fs__default["default"]);
	function clone(obj) {
		if (obj === null || typeof obj !== "object") return obj;
		if (obj instanceof Object) var copy = { __proto__: obj.__proto__ };
else var copy = Object.create(null);
		Object.getOwnPropertyNames(obj).forEach(function(key) {
			Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
		});
		return copy;
	}
	var origCwd = process.cwd;
	var cwd = null;
	var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
	process.cwd = function() {
		if (!cwd) cwd = origCwd.call(process);
		return cwd;
	};
	try {
		process.cwd();
	} catch (er) {}
	var chdir = process.chdir;
	process.chdir = function(d$1) {
		cwd = null;
		chdir.call(process, d$1);
	};
	var polyfills = patch;
	function patch(fs$3) {
		if (constants__default["default"].hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) patchLchmod(fs$3);
		if (!fs$3.lutimes) patchLutimes(fs$3);
		fs$3.chown = chownFix(fs$3.chown);
		fs$3.fchown = chownFix(fs$3.fchown);
		fs$3.lchown = chownFix(fs$3.lchown);
		fs$3.chmod = chmodFix(fs$3.chmod);
		fs$3.fchmod = chmodFix(fs$3.fchmod);
		fs$3.lchmod = chmodFix(fs$3.lchmod);
		fs$3.chownSync = chownFixSync(fs$3.chownSync);
		fs$3.fchownSync = chownFixSync(fs$3.fchownSync);
		fs$3.lchownSync = chownFixSync(fs$3.lchownSync);
		fs$3.chmodSync = chmodFixSync(fs$3.chmodSync);
		fs$3.fchmodSync = chmodFixSync(fs$3.fchmodSync);
		fs$3.lchmodSync = chmodFixSync(fs$3.lchmodSync);
		fs$3.stat = statFix(fs$3.stat);
		fs$3.fstat = statFix(fs$3.fstat);
		fs$3.lstat = statFix(fs$3.lstat);
		fs$3.statSync = statFixSync(fs$3.statSync);
		fs$3.fstatSync = statFixSync(fs$3.fstatSync);
		fs$3.lstatSync = statFixSync(fs$3.lstatSync);
		if (!fs$3.lchmod) {
			fs$3.lchmod = function(path$3, mode, cb) {
				if (cb) process.nextTick(cb);
			};
			fs$3.lchmodSync = function() {};
		}
		if (!fs$3.lchown) {
			fs$3.lchown = function(path$3, uid, gid, cb) {
				if (cb) process.nextTick(cb);
			};
			fs$3.lchownSync = function() {};
		}
		if (platform === "win32") fs$3.rename = function(fs$rename) {
			return function(from$1, to, cb) {
				var start = Date.now();
				var backoff = 0;
				fs$rename(from$1, to, function CB(er) {
					if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
						setTimeout(function() {
							fs$3.stat(to, function(stater, st) {
								if (stater && stater.code === "ENOENT") fs$rename(from$1, to, CB);
else cb(er);
							});
						}, backoff);
						if (backoff < 100) backoff += 10;
						return;
					}
					if (cb) cb(er);
				});
			};
		}(fs$3.rename);
		fs$3.read = function(fs$read) {
			return function(fd, buffer, offset, length, position, callback_) {
				var callback;
				if (callback_ && typeof callback_ === "function") {
					var eagCounter = 0;
					callback = function(er, _, __) {
						if (er && er.code === "EAGAIN" && eagCounter < 10) {
							eagCounter++;
							return fs$read.call(fs$3, fd, buffer, offset, length, position, callback);
						}
						callback_.apply(this, arguments);
					};
				}
				return fs$read.call(fs$3, fd, buffer, offset, length, position, callback);
			};
		}(fs$3.read);
		fs$3.readSync = function(fs$readSync) {
			return function(fd, buffer, offset, length, position) {
				var eagCounter = 0;
				while (true) try {
					return fs$readSync.call(fs$3, fd, buffer, offset, length, position);
				} catch (er) {
					if (er.code === "EAGAIN" && eagCounter < 10) {
						eagCounter++;
						continue;
					}
					throw er;
				}
			};
		}(fs$3.readSync);
	}
	function patchLchmod(fs$3) {
		fs$3.lchmod = function(path$3, mode, callback) {
			fs$3.open(path$3, constants__default["default"].O_WRONLY | constants__default["default"].O_SYMLINK, mode, function(err, fd) {
				if (err) {
					if (callback) callback(err);
					return;
				}
				fs$3.fchmod(fd, mode, function(err$1) {
					fs$3.close(fd, function(err2) {
						if (callback) callback(err$1 || err2);
					});
				});
			});
		};
		fs$3.lchmodSync = function(path$3, mode) {
			var fd = fs$3.openSync(path$3, constants__default["default"].O_WRONLY | constants__default["default"].O_SYMLINK, mode);
			var threw = true;
			var ret;
			try {
				ret = fs$3.fchmodSync(fd, mode);
				threw = false;
			} finally {
				if (threw) try {
					fs$3.closeSync(fd);
				} catch (er) {}
else fs$3.closeSync(fd);
			}
			return ret;
		};
	}
	function patchLutimes(fs$3) {
		if (constants__default["default"].hasOwnProperty("O_SYMLINK")) {
			fs$3.lutimes = function(path$3, at, mt, cb) {
				fs$3.open(path$3, constants__default["default"].O_SYMLINK, function(er, fd) {
					if (er) {
						if (cb) cb(er);
						return;
					}
					fs$3.futimes(fd, at, mt, function(er$1) {
						fs$3.close(fd, function(er2) {
							if (cb) cb(er$1 || er2);
						});
					});
				});
			};
			fs$3.lutimesSync = function(path$3, at, mt) {
				var fd = fs$3.openSync(path$3, constants__default["default"].O_SYMLINK);
				var ret;
				var threw = true;
				try {
					ret = fs$3.futimesSync(fd, at, mt);
					threw = false;
				} finally {
					if (threw) try {
						fs$3.closeSync(fd);
					} catch (er) {}
else fs$3.closeSync(fd);
				}
				return ret;
			};
		} else {
			fs$3.lutimes = function(_a, _b, _c, cb) {
				if (cb) process.nextTick(cb);
			};
			fs$3.lutimesSync = function() {};
		}
	}
	function chmodFix(orig) {
		if (!orig) return orig;
		return function(target, mode, cb) {
			return orig.call(fs_1, target, mode, function(er) {
				if (chownErOk(er)) er = null;
				if (cb) cb.apply(this, arguments);
			});
		};
	}
	function chmodFixSync(orig) {
		if (!orig) return orig;
		return function(target, mode) {
			try {
				return orig.call(fs_1, target, mode);
			} catch (er) {
				if (!chownErOk(er)) throw er;
			}
		};
	}
	function chownFix(orig) {
		if (!orig) return orig;
		return function(target, uid, gid, cb) {
			return orig.call(fs_1, target, uid, gid, function(er) {
				if (chownErOk(er)) er = null;
				if (cb) cb.apply(this, arguments);
			});
		};
	}
	function chownFixSync(orig) {
		if (!orig) return orig;
		return function(target, uid, gid) {
			try {
				return orig.call(fs_1, target, uid, gid);
			} catch (er) {
				if (!chownErOk(er)) throw er;
			}
		};
	}
	function statFix(orig) {
		if (!orig) return orig;
		return function(target, cb) {
			return orig.call(fs_1, target, function(er, stats) {
				if (!stats) return cb.apply(this, arguments);
				if (stats.uid < 0) stats.uid += 4294967296;
				if (stats.gid < 0) stats.gid += 4294967296;
				if (cb) cb.apply(this, arguments);
			});
		};
	}
	function statFixSync(orig) {
		if (!orig) return orig;
		return function(target) {
			var stats = orig.call(fs_1, target);
			if (stats.uid < 0) stats.uid += 4294967296;
			if (stats.gid < 0) stats.gid += 4294967296;
			return stats;
		};
	}
	function chownErOk(er) {
		if (!er) return true;
		if (er.code === "ENOSYS") return true;
		var nonroot = !process.getuid || process.getuid() !== 0;
		if (nonroot) {
			if (er.code === "EINVAL" || er.code === "EPERM") return true;
		}
		return false;
	}
	var Stream$5 = Stream__default["default"].Stream;
	var legacyStreams = legacy;
	function legacy(fs$3) {
		return {
			ReadStream: ReadStream$1,
			WriteStream: WriteStream$1
		};
		function ReadStream$1(path$3, options) {
			if (!(this instanceof ReadStream$1)) return new ReadStream$1(path$3, options);
			Stream$5.call(this);
			var self$1 = this;
			this.path = path$3;
			this.fd = null;
			this.readable = true;
			this.paused = false;
			this.flags = "r";
			this.mode = 438;
			this.bufferSize = 65536;
			options = options || {};
			var keys = Object.keys(options);
			for (var index$1 = 0, length = keys.length; index$1 < length; index$1++) {
				var key = keys[index$1];
				this[key] = options[key];
			}
			if (this.encoding) this.setEncoding(this.encoding);
			if (this.start !== undefined) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.end === undefined) this.end = Infinity;
else if ("number" !== typeof this.end) throw TypeError("end must be a Number");
				if (this.start > this.end) throw new Error("start must be <= end");
				this.pos = this.start;
			}
			if (this.fd !== null) {
				process.nextTick(function() {
					self$1._read();
				});
				return;
			}
			fs$3.open(this.path, this.flags, this.mode, function(err, fd) {
				if (err) {
					self$1.emit("error", err);
					self$1.readable = false;
					return;
				}
				self$1.fd = fd;
				self$1.emit("open", fd);
				self$1._read();
			});
		}
		function WriteStream$1(path$3, options) {
			if (!(this instanceof WriteStream$1)) return new WriteStream$1(path$3, options);
			Stream$5.call(this);
			this.path = path$3;
			this.fd = null;
			this.writable = true;
			this.flags = "w";
			this.encoding = "binary";
			this.mode = 438;
			this.bytesWritten = 0;
			options = options || {};
			var keys = Object.keys(options);
			for (var index$1 = 0, length = keys.length; index$1 < length; index$1++) {
				var key = keys[index$1];
				this[key] = options[key];
			}
			if (this.start !== undefined) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.start < 0) throw new Error("start must be >= zero");
				this.pos = this.start;
			}
			this.busy = false;
			this._queue = [];
			if (this.fd === null) {
				this._open = fs$3.open;
				this._queue.push([
					this._open,
					this.path,
					this.flags,
					this.mode,
					undefined
				]);
				this.flush();
			}
		}
	}
	var gracefulFs = createCommonjsModule(function(module$1) {
		var queue = [];
		function noop$1() {}
		var debug$3 = noop$1;
		if (util__default["default"].debuglog) debug$3 = util__default["default"].debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) debug$3 = function() {
			var m$1 = util__default["default"].format.apply(util__default["default"], arguments);
			m$1 = "GFS4: " + m$1.split(/\n/).join("\nGFS4: ");
			console.error(m$1);
		};
		if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) process.on("exit", function() {
			debug$3(queue);
			assert__default["default"].equal(queue.length, 0);
		});
		module$1.exports = patch$1(fs_1);
		if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) module$1.exports = patch$1(fs__default["default"]);
		module$1.exports.close = fs__default["default"].close = function(fs$close) {
			return function(fd, cb) {
				return fs$close.call(fs__default["default"], fd, function(err) {
					if (!err) retry();
					if (typeof cb === "function") cb.apply(this, arguments);
				});
			};
		}(fs__default["default"].close);
		module$1.exports.closeSync = fs__default["default"].closeSync = function(fs$closeSync) {
			return function(fd) {
				var rval = fs$closeSync.apply(fs__default["default"], arguments);
				retry();
				return rval;
			};
		}(fs__default["default"].closeSync);
		function patch$1(fs$3) {
			polyfills(fs$3);
			fs$3.gracefulify = patch$1;
			fs$3.FileReadStream = ReadStream$1;
			fs$3.FileWriteStream = WriteStream$1;
			fs$3.createReadStream = createReadStream;
			fs$3.createWriteStream = createWriteStream;
			var fs$readFile = fs$3.readFile;
			fs$3.readFile = readFile;
			function readFile(path$3, options, cb) {
				if (typeof options === "function") cb = options, options = null;
				return go$readFile(path$3, options, cb);
				function go$readFile(path$4, options$1, cb$1) {
					return fs$readFile(path$4, options$1, function(err) {
						if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([go$readFile, [
							path$4,
							options$1,
							cb$1
						]]);
else {
							if (typeof cb$1 === "function") cb$1.apply(this, arguments);
							retry();
						}
					});
				}
			}
			var fs$writeFile = fs$3.writeFile;
			fs$3.writeFile = writeFile;
			function writeFile(path$3, data, options, cb) {
				if (typeof options === "function") cb = options, options = null;
				return go$writeFile(path$3, data, options, cb);
				function go$writeFile(path$4, data$1, options$1, cb$1) {
					return fs$writeFile(path$4, data$1, options$1, function(err) {
						if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([go$writeFile, [
							path$4,
							data$1,
							options$1,
							cb$1
						]]);
else {
							if (typeof cb$1 === "function") cb$1.apply(this, arguments);
							retry();
						}
					});
				}
			}
			var fs$appendFile = fs$3.appendFile;
			if (fs$appendFile) fs$3.appendFile = appendFile;
			function appendFile(path$3, data, options, cb) {
				if (typeof options === "function") cb = options, options = null;
				return go$appendFile(path$3, data, options, cb);
				function go$appendFile(path$4, data$1, options$1, cb$1) {
					return fs$appendFile(path$4, data$1, options$1, function(err) {
						if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([go$appendFile, [
							path$4,
							data$1,
							options$1,
							cb$1
						]]);
else {
							if (typeof cb$1 === "function") cb$1.apply(this, arguments);
							retry();
						}
					});
				}
			}
			var fs$readdir = fs$3.readdir;
			fs$3.readdir = readdir$1;
			function readdir$1(path$3, options, cb) {
				var args = [path$3];
				if (typeof options !== "function") args.push(options);
else cb = options;
				args.push(go$readdir$cb);
				return go$readdir(args);
				function go$readdir$cb(err, files) {
					if (files && files.sort) files.sort();
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([go$readdir, [args]]);
else {
						if (typeof cb === "function") cb.apply(this, arguments);
						retry();
					}
				}
			}
			function go$readdir(args) {
				return fs$readdir.apply(fs$3, args);
			}
			if (process.version.substr(0, 4) === "v0.8") {
				var legStreams = legacyStreams(fs$3);
				ReadStream$1 = legStreams.ReadStream;
				WriteStream$1 = legStreams.WriteStream;
			}
			var fs$ReadStream = fs$3.ReadStream;
			ReadStream$1.prototype = Object.create(fs$ReadStream.prototype);
			ReadStream$1.prototype.open = ReadStream$open;
			var fs$WriteStream = fs$3.WriteStream;
			WriteStream$1.prototype = Object.create(fs$WriteStream.prototype);
			WriteStream$1.prototype.open = WriteStream$open;
			fs$3.ReadStream = ReadStream$1;
			fs$3.WriteStream = WriteStream$1;
			function ReadStream$1(path$3, options) {
				if (this instanceof ReadStream$1) return fs$ReadStream.apply(this, arguments), this;
else return ReadStream$1.apply(Object.create(ReadStream$1.prototype), arguments);
			}
			function ReadStream$open() {
				var that = this;
				open(that.path, that.flags, that.mode, function(err, fd) {
					if (err) {
						if (that.autoClose) that.destroy();
						that.emit("error", err);
					} else {
						that.fd = fd;
						that.emit("open", fd);
						that.read();
					}
				});
			}
			function WriteStream$1(path$3, options) {
				if (this instanceof WriteStream$1) return fs$WriteStream.apply(this, arguments), this;
else return WriteStream$1.apply(Object.create(WriteStream$1.prototype), arguments);
			}
			function WriteStream$open() {
				var that = this;
				open(that.path, that.flags, that.mode, function(err, fd) {
					if (err) {
						that.destroy();
						that.emit("error", err);
					} else {
						that.fd = fd;
						that.emit("open", fd);
					}
				});
			}
			function createReadStream(path$3, options) {
				return new ReadStream$1(path$3, options);
			}
			function createWriteStream(path$3, options) {
				return new WriteStream$1(path$3, options);
			}
			var fs$open = fs$3.open;
			fs$3.open = open;
			function open(path$3, flags, mode, cb) {
				if (typeof mode === "function") cb = mode, mode = null;
				return go$open(path$3, flags, mode, cb);
				function go$open(path$4, flags$1, mode$1, cb$1) {
					return fs$open(path$4, flags$1, mode$1, function(err, fd) {
						if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([go$open, [
							path$4,
							flags$1,
							mode$1,
							cb$1
						]]);
else {
							if (typeof cb$1 === "function") cb$1.apply(this, arguments);
							retry();
						}
					});
				}
			}
			return fs$3;
		}
		function enqueue(elem) {
			debug$3("ENQUEUE", elem[0].name, elem[1]);
			queue.push(elem);
		}
		function retry() {
			var elem = queue.shift();
			if (elem) {
				debug$3("RETRY", elem[0].name, elem[1]);
				elem[0].apply(null, elem[1]);
			}
		}
	});
	var _0777 = parseInt("0777", 8);
	var mkdirp$2 = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
	function mkdirP(p, opts, f, made) {
		if (typeof opts === "function") {
			f = opts;
			opts = {};
		} else if (!opts || typeof opts !== "object") opts = { mode: opts };
		var mode = opts.mode;
		var xfs = opts.fs || fs__default["default"];
		if (mode === undefined) mode = _0777 & ~process.umask();
		if (!made) made = null;
		var cb = f || function() {};
		p = path__default["default"].resolve(p);
		xfs.mkdir(p, mode, function(er) {
			if (!er) {
				made = made || p;
				return cb(null, made);
			}
			switch (er.code) {
				case "ENOENT":
					mkdirP(path__default["default"].dirname(p), opts, function(er$1, made$1) {
						if (er$1) cb(er$1, made$1);
else mkdirP(p, opts, cb, made$1);
					});
					break;
				default:
					xfs.stat(p, function(er2, stat) {
						if (er2 || !stat.isDirectory()) cb(er, made);
else cb(null, made);
					});
					break;
			}
		});
	}
	mkdirP.sync = function sync$2(p, opts, made) {
		if (!opts || typeof opts !== "object") opts = { mode: opts };
		var mode = opts.mode;
		var xfs = opts.fs || fs__default["default"];
		if (mode === undefined) mode = _0777 & ~process.umask();
		if (!made) made = null;
		p = path__default["default"].resolve(p);
		try {
			xfs.mkdirSync(p, mode);
			made = made || p;
		} catch (err0) {
			switch (err0.code) {
				case "ENOENT":
					made = sync$2(path__default["default"].dirname(p), opts, made);
					sync$2(p, opts, made);
					break;
				default:
					var stat;
					try {
						stat = xfs.statSync(p);
					} catch (err1) {
						throw err0;
					}
					if (!stat.isDirectory()) throw err0;
					break;
			}
		}
		return made;
	};
	var isWindows$1 = process.platform === "win32";
	var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
	function rethrow() {
		var callback;
		if (DEBUG) {
			var backtrace = new Error();
			callback = debugCallback;
		} else callback = missingCallback;
		return callback;
		function debugCallback(err) {
			if (err) {
				backtrace.message = err.message;
				err = backtrace;
				missingCallback(err);
			}
		}
		function missingCallback(err) {
			if (err) {
				if (process.throwDeprecation) throw err;
else if (!process.noDeprecation) {
					var msg = "fs: missing callback " + (err.stack || err.message);
					if (process.traceDeprecation) console.trace(msg);
else console.error(msg);
				}
			}
		}
	}
	function maybeCallback(cb) {
		return typeof cb === "function" ? cb : rethrow();
	}
	path__default["default"].normalize;
	if (isWindows$1) {
		var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
	} else {
		var nextPartRe = /(.*?)(?:[\/]+|$)/g;
	}
	if (isWindows$1) {
		var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
	} else {
		var splitRootRe = /^[\/]*/;
	}
	var realpathSync$1 = function realpathSync$2(p, cache) {
		p = path__default["default"].resolve(p);
		if (cache && Object.prototype.hasOwnProperty.call(cache, p)) return cache[p];
		var original = p, seenLinks = {}, knownHard = {};
		var pos$1;
		var current;
		var base$1;
		var previous;
		start();
		function start() {
			var m$1 = splitRootRe.exec(p);
			pos$1 = m$1[0].length;
			current = m$1[0];
			base$1 = m$1[0];
			previous = "";
			if (isWindows$1 && !knownHard[base$1]) {
				fs__default["default"].lstatSync(base$1);
				knownHard[base$1] = true;
			}
		}
		while (pos$1 < p.length) {
			nextPartRe.lastIndex = pos$1;
			var result = nextPartRe.exec(p);
			previous = current;
			current += result[0];
			base$1 = previous + result[1];
			pos$1 = nextPartRe.lastIndex;
			if (knownHard[base$1] || cache && cache[base$1] === base$1) continue;
			var resolvedLink;
			if (cache && Object.prototype.hasOwnProperty.call(cache, base$1)) resolvedLink = cache[base$1];
else {
				var stat = fs__default["default"].lstatSync(base$1);
				if (!stat.isSymbolicLink()) {
					knownHard[base$1] = true;
					if (cache) cache[base$1] = base$1;
					continue;
				}
				var linkTarget = null;
				if (!isWindows$1) {
					var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
					if (seenLinks.hasOwnProperty(id)) linkTarget = seenLinks[id];
				}
				if (linkTarget === null) {
					fs__default["default"].statSync(base$1);
					linkTarget = fs__default["default"].readlinkSync(base$1);
				}
				resolvedLink = path__default["default"].resolve(previous, linkTarget);
				if (cache) cache[base$1] = resolvedLink;
				if (!isWindows$1) seenLinks[id] = linkTarget;
			}
			p = path__default["default"].resolve(resolvedLink, p.slice(pos$1));
			start();
		}
		if (cache) cache[original] = p;
		return p;
	};
	var realpath$1 = function realpath$2(p, cache, cb) {
		if (typeof cb !== "function") {
			cb = maybeCallback(cache);
			cache = null;
		}
		p = path__default["default"].resolve(p);
		if (cache && Object.prototype.hasOwnProperty.call(cache, p)) return process.nextTick(cb.bind(null, null, cache[p]));
		var original = p, seenLinks = {}, knownHard = {};
		var pos$1;
		var current;
		var base$1;
		var previous;
		start();
		function start() {
			var m$1 = splitRootRe.exec(p);
			pos$1 = m$1[0].length;
			current = m$1[0];
			base$1 = m$1[0];
			previous = "";
			if (isWindows$1 && !knownHard[base$1]) fs__default["default"].lstat(base$1, function(err) {
				if (err) return cb(err);
				knownHard[base$1] = true;
				LOOP();
			});
else process.nextTick(LOOP);
		}
		function LOOP() {
			if (pos$1 >= p.length) {
				if (cache) cache[original] = p;
				return cb(null, p);
			}
			nextPartRe.lastIndex = pos$1;
			var result = nextPartRe.exec(p);
			previous = current;
			current += result[0];
			base$1 = previous + result[1];
			pos$1 = nextPartRe.lastIndex;
			if (knownHard[base$1] || cache && cache[base$1] === base$1) return process.nextTick(LOOP);
			if (cache && Object.prototype.hasOwnProperty.call(cache, base$1)) return gotResolvedLink(cache[base$1]);
			return fs__default["default"].lstat(base$1, gotStat);
		}
		function gotStat(err, stat) {
			if (err) return cb(err);
			if (!stat.isSymbolicLink()) {
				knownHard[base$1] = true;
				if (cache) cache[base$1] = base$1;
				return process.nextTick(LOOP);
			}
			if (!isWindows$1) {
				var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
				if (seenLinks.hasOwnProperty(id)) return gotTarget(null, seenLinks[id], base$1);
			}
			fs__default["default"].stat(base$1, function(err$1) {
				if (err$1) return cb(err$1);
				fs__default["default"].readlink(base$1, function(err$2, target) {
					if (!isWindows$1) seenLinks[id] = target;
					gotTarget(err$2, target);
				});
			});
		}
		function gotTarget(err, target, base$2) {
			if (err) return cb(err);
			var resolvedLink = path__default["default"].resolve(previous, target);
			if (cache) cache[base$2] = resolvedLink;
			gotResolvedLink(resolvedLink);
		}
		function gotResolvedLink(resolvedLink) {
			p = path__default["default"].resolve(resolvedLink, p.slice(pos$1));
			start();
		}
	};
	var old = {
		realpathSync: realpathSync$1,
		realpath: realpath$1
	};
	var fs_realpath = realpath;
	realpath.realpath = realpath;
	realpath.sync = realpathSync;
	realpath.realpathSync = realpathSync;
	realpath.monkeypatch = monkeypatch;
	realpath.unmonkeypatch = unmonkeypatch;
	var origRealpath = fs__default["default"].realpath;
	var origRealpathSync = fs__default["default"].realpathSync;
	var version = process.version;
	var ok = /^v[0-5]\./.test(version);
	function newError(er) {
		return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
	}
	function realpath(p, cache, cb) {
		if (ok) return origRealpath(p, cache, cb);
		if (typeof cache === "function") {
			cb = cache;
			cache = null;
		}
		origRealpath(p, cache, function(er, result) {
			if (newError(er)) old.realpath(p, cache, cb);
else cb(er, result);
		});
	}
	function realpathSync(p, cache) {
		if (ok) return origRealpathSync(p, cache);
		try {
			return origRealpathSync(p, cache);
		} catch (er) {
			if (newError(er)) return old.realpathSync(p, cache);
else throw er;
		}
	}
	function monkeypatch() {
		fs__default["default"].realpath = realpath;
		fs__default["default"].realpathSync = realpathSync;
	}
	function unmonkeypatch() {
		fs__default["default"].realpath = origRealpath;
		fs__default["default"].realpathSync = origRealpathSync;
	}
	var concatMap = function(xs, fn) {
		var res = [];
		for (var i = 0; i < xs.length; i++) {
			var x = fn(xs[i], i);
			if (isArray(x)) res.push.apply(res, x);
else res.push(x);
		}
		return res;
	};
	var isArray = Array.isArray || function(xs) {
		return Object.prototype.toString.call(xs) === "[object Array]";
	};
	var balancedMatch = balanced;
	function balanced(a, b, str) {
		if (a instanceof RegExp) a = maybeMatch(a, str);
		if (b instanceof RegExp) b = maybeMatch(b, str);
		var r = range(a, b, str);
		return r && {
			start: r[0],
			end: r[1],
			pre: str.slice(0, r[0]),
			body: str.slice(r[0] + a.length, r[1]),
			post: str.slice(r[1] + b.length)
		};
	}
	function maybeMatch(reg, str) {
		var m$1 = str.match(reg);
		return m$1 ? m$1[0] : null;
	}
	balanced.range = range;
	function range(a, b, str) {
		var begs, beg, left, right, result;
		var ai = str.indexOf(a);
		var bi = str.indexOf(b, ai + 1);
		var i = ai;
		if (ai >= 0 && bi > 0) {
			begs = [];
			left = str.length;
			while (i >= 0 && !result) {
				if (i == ai) {
					begs.push(i);
					ai = str.indexOf(a, i + 1);
				} else if (begs.length == 1) result = [begs.pop(), bi];
else {
					beg = begs.pop();
					if (beg < left) {
						left = beg;
						right = bi;
					}
					bi = str.indexOf(b, i + 1);
				}
				i = ai < bi && ai >= 0 ? ai : bi;
			}
			if (begs.length) result = [left, right];
		}
		return result;
	}
	var braceExpansion = expandTop;
	var escSlash = "\0SLASH" + Math.random() + "\0";
	var escOpen = "\0OPEN" + Math.random() + "\0";
	var escClose = "\0CLOSE" + Math.random() + "\0";
	var escComma = "\0COMMA" + Math.random() + "\0";
	var escPeriod = "\0PERIOD" + Math.random() + "\0";
	function numeric(str) {
		return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
	}
	function escapeBraces(str) {
		return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
	}
	function unescapeBraces(str) {
		return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
	}
	function parseCommaParts(str) {
		if (!str) return [""];
		var parts = [];
		var m$1 = balancedMatch("{", "}", str);
		if (!m$1) return str.split(",");
		var pre = m$1.pre;
		var body = m$1.body;
		var post = m$1.post;
		var p = pre.split(",");
		p[p.length - 1] += "{" + body + "}";
		var postParts = parseCommaParts(post);
		if (post.length) {
			p[p.length - 1] += postParts.shift();
			p.push.apply(p, postParts);
		}
		parts.push.apply(parts, p);
		return parts;
	}
	function expandTop(str) {
		if (!str) return [];
		if (str.substr(0, 2) === "{}") str = "\\{\\}" + str.substr(2);
		return expand(escapeBraces(str), true).map(unescapeBraces);
	}
	function embrace(str) {
		return "{" + str + "}";
	}
	function isPadded(el) {
		return /^-?0\d/.test(el);
	}
	function lte(i, y$1) {
		return i <= y$1;
	}
	function gte(i, y$1) {
		return i >= y$1;
	}
	function expand(str, isTop) {
		var expansions = [];
		var m$1 = balancedMatch("{", "}", str);
		if (!m$1 || /\$$/.test(m$1.pre)) return [str];
		var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m$1.body);
		var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m$1.body);
		var isSequence = isNumericSequence || isAlphaSequence;
		var isOptions = m$1.body.indexOf(",") >= 0;
		if (!isSequence && !isOptions) {
			if (m$1.post.match(/,.*\}/)) {
				str = m$1.pre + "{" + m$1.body + escClose + m$1.post;
				return expand(str);
			}
			return [str];
		}
		var n;
		if (isSequence) n = m$1.body.split(/\.\./);
else {
			n = parseCommaParts(m$1.body);
			if (n.length === 1) {
				n = expand(n[0], false).map(embrace);
				if (n.length === 1) {
					var post = m$1.post.length ? expand(m$1.post, false) : [""];
					return post.map(function(p) {
						return m$1.pre + n[0] + p;
					});
				}
			}
		}
		var pre = m$1.pre;
		var post = m$1.post.length ? expand(m$1.post, false) : [""];
		var N;
		if (isSequence) {
			var x = numeric(n[0]);
			var y$1 = numeric(n[1]);
			var width = Math.max(n[0].length, n[1].length);
			var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
			var test = lte;
			var reverse = y$1 < x;
			if (reverse) {
				incr *= -1;
				test = gte;
			}
			var pad = n.some(isPadded);
			N = [];
			for (var i = x; test(i, y$1); i += incr) {
				var c;
				if (isAlphaSequence) {
					c = String.fromCharCode(i);
					if (c === "\\") c = "";
				} else {
					c = String(i);
					if (pad) {
						var need = width - c.length;
						if (need > 0) {
							var z = new Array(need + 1).join("0");
							if (i < 0) c = "-" + z + c.slice(1);
else c = z + c;
						}
					}
				}
				N.push(c);
			}
		} else N = concatMap(n, function(el) {
			return expand(el, false);
		});
		for (var j = 0; j < N.length; j++) for (var k = 0; k < post.length; k++) {
			var expansion = pre + N[j] + post[k];
			if (!isTop || isSequence || expansion) expansions.push(expansion);
		}
		return expansions;
	}
	var minimatch_1 = minimatch;
	minimatch.Minimatch = Minimatch$1;
	var path$2 = { sep: "/" };
	try {
		path$2 = path__default["default"];
	} catch (er) {}
	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch$1.GLOBSTAR = {};
	var plTypes = {
		"!": {
			open: "(?:(?!(?:",
			close: "))[^/]*?)"
		},
		"?": {
			open: "(?:",
			close: ")?"
		},
		"+": {
			open: "(?:",
			close: ")+"
		},
		"*": {
			open: "(?:",
			close: ")*"
		},
		"@": {
			open: "(?:",
			close: ")"
		}
	};
	var qmark = "[^/]";
	var star = qmark + "*?";
	var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
	var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
	var reSpecials = charSet("().*{}+?[]^$\\!");
	function charSet(s$1) {
		return s$1.split("").reduce(function(set, c) {
			set[c] = true;
			return set;
		}, {});
	}
	var slashSplit = /\/+/;
	minimatch.filter = filter;
	function filter(pattern, options) {
		options = options || {};
		return function(p, i, list$1) {
			return minimatch(p, pattern, options);
		};
	}
	function ext(a, b) {
		a = a || {};
		b = b || {};
		var t = {};
		Object.keys(b).forEach(function(k) {
			t[k] = b[k];
		});
		Object.keys(a).forEach(function(k) {
			t[k] = a[k];
		});
		return t;
	}
	minimatch.defaults = function(def) {
		if (!def || !Object.keys(def).length) return minimatch;
		var orig = minimatch;
		var m$1 = function minimatch$1(p, pattern, options) {
			return orig.minimatch(p, pattern, ext(def, options));
		};
		m$1.Minimatch = function Minimatch$2(pattern, options) {
			return new orig.Minimatch(pattern, ext(def, options));
		};
		return m$1;
	};
	Minimatch$1.defaults = function(def) {
		if (!def || !Object.keys(def).length) return Minimatch$1;
		return minimatch.defaults(def).Minimatch;
	};
	function minimatch(p, pattern, options) {
		if (typeof pattern !== "string") throw new TypeError("glob pattern string required");
		if (!options) options = {};
		if (!options.nocomment && pattern.charAt(0) === "#") return false;
		if (pattern.trim() === "") return p === "";
		return new Minimatch$1(pattern, options).match(p);
	}
	function Minimatch$1(pattern, options) {
		if (!(this instanceof Minimatch$1)) return new Minimatch$1(pattern, options);
		if (typeof pattern !== "string") throw new TypeError("glob pattern string required");
		if (!options) options = {};
		pattern = pattern.trim();
		if (path$2.sep !== "/") pattern = pattern.split(path$2.sep).join("/");
		this.options = options;
		this.set = [];
		this.pattern = pattern;
		this.regexp = null;
		this.negate = false;
		this.comment = false;
		this.empty = false;
		this.make();
	}
	Minimatch$1.prototype.debug = function() {};
	Minimatch$1.prototype.make = make;
	function make() {
		if (this._made) return;
		var pattern = this.pattern;
		var options = this.options;
		if (!options.nocomment && pattern.charAt(0) === "#") {
			this.comment = true;
			return;
		}
		if (!pattern) {
			this.empty = true;
			return;
		}
		this.parseNegate();
		var set = this.globSet = this.braceExpand();
		if (options.debug) this.debug = console.error;
		this.debug(this.pattern, set);
		set = this.globParts = set.map(function(s$1) {
			return s$1.split(slashSplit);
		});
		this.debug(this.pattern, set);
		set = set.map(function(s$1, si, set$1) {
			return s$1.map(this.parse, this);
		}, this);
		this.debug(this.pattern, set);
		set = set.filter(function(s$1) {
			return s$1.indexOf(false) === -1;
		});
		this.debug(this.pattern, set);
		this.set = set;
	}
	Minimatch$1.prototype.parseNegate = parseNegate;
	function parseNegate() {
		var pattern = this.pattern;
		var negate = false;
		var options = this.options;
		var negateOffset = 0;
		if (options.nonegate) return;
		for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
			negate = !negate;
			negateOffset++;
		}
		if (negateOffset) this.pattern = pattern.substr(negateOffset);
		this.negate = negate;
	}
	minimatch.braceExpand = function(pattern, options) {
		return braceExpand(pattern, options);
	};
	Minimatch$1.prototype.braceExpand = braceExpand;
	function braceExpand(pattern, options) {
		if (!options) if (this instanceof Minimatch$1) options = this.options;
else options = {};
		pattern = typeof pattern === "undefined" ? this.pattern : pattern;
		if (typeof pattern === "undefined") throw new TypeError("undefined pattern");
		if (options.nobrace || !pattern.match(/\{.*\}/)) return [pattern];
		return braceExpansion(pattern);
	}
	Minimatch$1.prototype.parse = parse$2;
	var SUBPARSE = {};
	function parse$2(pattern, isSub) {
		if (pattern.length > 65536) throw new TypeError("pattern is too long");
		var options = this.options;
		if (!options.noglobstar && pattern === "**") return GLOBSTAR;
		if (pattern === "") return "";
		var re = "";
		var hasMagic = !!options.nocase;
		var escaping = false;
		var patternListStack = [];
		var negativeLists = [];
		var stateChar;
		var inClass = false;
		var reClassStart = -1;
		var classStart = -1;
		var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
		var self$1 = this;
		function clearStateChar() {
			if (stateChar) {
				switch (stateChar) {
					case "*":
						re += star;
						hasMagic = true;
						break;
					case "?":
						re += qmark;
						hasMagic = true;
						break;
					default:
						re += "\\" + stateChar;
						break;
				}
				self$1.debug("clearStateChar %j %j", stateChar, re);
				stateChar = false;
			}
		}
		for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
			this.debug("%s	%s %s %j", pattern, i, re, c);
			if (escaping && reSpecials[c]) {
				re += "\\" + c;
				escaping = false;
				continue;
			}
			switch (c) {
				case "/": return false;
				case "\\":
					clearStateChar();
					escaping = true;
					continue;
				case "?":
				case "*":
				case "+":
				case "@":
				case "!":
					this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
					if (inClass) {
						this.debug("  in class");
						if (c === "!" && i === classStart + 1) c = "^";
						re += c;
						continue;
					}
					self$1.debug("call clearStateChar %j", stateChar);
					clearStateChar();
					stateChar = c;
					if (options.noext) clearStateChar();
					continue;
				case "(":
					if (inClass) {
						re += "(";
						continue;
					}
					if (!stateChar) {
						re += "\\(";
						continue;
					}
					patternListStack.push({
						type: stateChar,
						start: i - 1,
						reStart: re.length,
						open: plTypes[stateChar].open,
						close: plTypes[stateChar].close
					});
					re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
					this.debug("plType %j %j", stateChar, re);
					stateChar = false;
					continue;
				case ")":
					if (inClass || !patternListStack.length) {
						re += "\\)";
						continue;
					}
					clearStateChar();
					hasMagic = true;
					var pl = patternListStack.pop();
					re += pl.close;
					if (pl.type === "!") negativeLists.push(pl);
					pl.reEnd = re.length;
					continue;
				case "|":
					if (inClass || !patternListStack.length || escaping) {
						re += "\\|";
						escaping = false;
						continue;
					}
					clearStateChar();
					re += "|";
					continue;
				case "[":
					clearStateChar();
					if (inClass) {
						re += "\\" + c;
						continue;
					}
					inClass = true;
					classStart = i;
					reClassStart = re.length;
					re += c;
					continue;
				case "]":
					if (i === classStart + 1 || !inClass) {
						re += "\\" + c;
						escaping = false;
						continue;
					}
					if (inClass) {
						var cs = pattern.substring(classStart + 1, i);
						try {
							RegExp("[" + cs + "]");
						} catch (er) {
							var sp = this.parse(cs, SUBPARSE);
							re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
							hasMagic = hasMagic || sp[1];
							inClass = false;
							continue;
						}
					}
					hasMagic = true;
					inClass = false;
					re += c;
					continue;
				default:
					clearStateChar();
					if (escaping) escaping = false;
else if (reSpecials[c] && !(c === "^" && inClass)) re += "\\";
					re += c;
			}
		}
		if (inClass) {
			cs = pattern.substr(classStart + 1);
			sp = this.parse(cs, SUBPARSE);
			re = re.substr(0, reClassStart) + "\\[" + sp[0];
			hasMagic = hasMagic || sp[1];
		}
		for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
			var tail = re.slice(pl.reStart + pl.open.length);
			this.debug("setting tail", re, pl);
			tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
				if (!$2) $2 = "\\";
				return $1 + $1 + $2 + "|";
			});
			this.debug("tail=%j\n   %s", tail, tail, pl, re);
			var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
			hasMagic = true;
			re = re.slice(0, pl.reStart) + t + "\\(" + tail;
		}
		clearStateChar();
		if (escaping) re += "\\\\";
		var addPatternStart = false;
		switch (re.charAt(0)) {
			case ".":
			case "[":
			case "(": addPatternStart = true;
		}
		for (var n = negativeLists.length - 1; n > -1; n--) {
			var nl = negativeLists[n];
			var nlBefore = re.slice(0, nl.reStart);
			var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
			var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
			var nlAfter = re.slice(nl.reEnd);
			nlLast += nlAfter;
			var openParensBefore = nlBefore.split("(").length - 1;
			var cleanAfter = nlAfter;
			for (i = 0; i < openParensBefore; i++) cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
			nlAfter = cleanAfter;
			var dollar = "";
			if (nlAfter === "" && isSub !== SUBPARSE) dollar = "$";
			var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
			re = newRe;
		}
		if (re !== "" && hasMagic) re = "(?=.)" + re;
		if (addPatternStart) re = patternStart + re;
		if (isSub === SUBPARSE) return [re, hasMagic];
		if (!hasMagic) return globUnescape(pattern);
		var flags = options.nocase ? "i" : "";
		try {
			var regExp = new RegExp("^" + re + "$", flags);
		} catch (er) {
			return new RegExp("$.");
		}
		regExp._glob = pattern;
		regExp._src = re;
		return regExp;
	}
	minimatch.makeRe = function(pattern, options) {
		return new Minimatch$1(pattern, options || {}).makeRe();
	};
	Minimatch$1.prototype.makeRe = makeRe;
	function makeRe() {
		if (this.regexp || this.regexp === false) return this.regexp;
		var set = this.set;
		if (!set.length) {
			this.regexp = false;
			return this.regexp;
		}
		var options = this.options;
		var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
		var flags = options.nocase ? "i" : "";
		var re = set.map(function(pattern) {
			return pattern.map(function(p) {
				return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
			}).join("\\/");
		}).join("|");
		re = "^(?:" + re + ")$";
		if (this.negate) re = "^(?!" + re + ").*$";
		try {
			this.regexp = new RegExp(re, flags);
		} catch (ex) {
			this.regexp = false;
		}
		return this.regexp;
	}
	minimatch.match = function(list$1, pattern, options) {
		options = options || {};
		var mm = new Minimatch$1(pattern, options);
		list$1 = list$1.filter(function(f) {
			return mm.match(f);
		});
		if (mm.options.nonull && !list$1.length) list$1.push(pattern);
		return list$1;
	};
	Minimatch$1.prototype.match = match;
	function match(f, partial) {
		this.debug("match", f, this.pattern);
		if (this.comment) return false;
		if (this.empty) return f === "";
		if (f === "/" && partial) return true;
		var options = this.options;
		if (path$2.sep !== "/") f = f.split(path$2.sep).join("/");
		f = f.split(slashSplit);
		this.debug(this.pattern, "split", f);
		var set = this.set;
		this.debug(this.pattern, "set", set);
		var filename;
		var i;
		for (i = f.length - 1; i >= 0; i--) {
			filename = f[i];
			if (filename) break;
		}
		for (i = 0; i < set.length; i++) {
			var pattern = set[i];
			var file = f;
			if (options.matchBase && pattern.length === 1) file = [filename];
			var hit = this.matchOne(file, pattern, partial);
			if (hit) {
				if (options.flipNegate) return true;
				return !this.negate;
			}
		}
		if (options.flipNegate) return false;
		return this.negate;
	}
	Minimatch$1.prototype.matchOne = function(file, pattern, partial) {
		var options = this.options;
		this.debug("matchOne", {
			"this": this,
			file,
			pattern
		});
		this.debug("matchOne", file.length, pattern.length);
		for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
			this.debug("matchOne loop");
			var p = pattern[pi];
			var f = file[fi];
			this.debug(pattern, p, f);
			if (p === false) return false;
			if (p === GLOBSTAR) {
				this.debug("GLOBSTAR", [
					pattern,
					p,
					f
				]);
				var fr = fi;
				var pr = pi + 1;
				if (pr === pl) {
					this.debug("** at the end");
					for (; fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
					return true;
				}
				while (fr < fl) {
					var swallowee = file[fr];
					this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
					if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
						this.debug("globstar found match!", fr, fl, swallowee);
						return true;
					} else {
						if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
							this.debug("dot detected!", file, fr, pattern, pr);
							break;
						}
						this.debug("globstar swallow a segment, and continue");
						fr++;
					}
				}
				if (partial) {
					this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
					if (fr === fl) return true;
				}
				return false;
			}
			var hit;
			if (typeof p === "string") {
				if (options.nocase) hit = f.toLowerCase() === p.toLowerCase();
else hit = f === p;
				this.debug("string match", p, f, hit);
			} else {
				hit = f.match(p);
				this.debug("pattern match", p, f, hit);
			}
			if (!hit) return false;
		}
		if (fi === fl && pi === pl) return true;
else if (fi === fl) return partial;
else if (pi === pl) {
			var emptyFileEnd = fi === fl - 1 && file[fi] === "";
			return emptyFileEnd;
		}
		throw new Error("wtf?");
	};
	function globUnescape(s$1) {
		return s$1.replace(/\\(.)/g, "$1");
	}
	function regExpEscape(s$1) {
		return s$1.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	}
	var inherits_browser = createCommonjsModule(function(module$1) {
		if (typeof Object.create === "function") module$1.exports = function inherits$1(ctor, superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		};
else module$1.exports = function inherits$1(ctor, superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		};
	});
	var inherits = createCommonjsModule(function(module$1) {
		try {
			var util$2 = util__default["default"];
			if (typeof util$2.inherits !== "function") throw "";
			module$1.exports = util$2.inherits;
		} catch (e) {
			module$1.exports = inherits_browser;
		}
	});
	function posix(path$3) {
		return path$3.charAt(0) === "/";
	}
	function win32(path$3) {
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path$3);
		var device = result[1] || "";
		var isUnc = Boolean(device && device.charAt(1) !== ":");
		return Boolean(result[2] || isUnc);
	}
	var pathIsAbsolute = process.platform === "win32" ? win32 : posix;
	var posix_1 = posix;
	var win32_1 = win32;
	pathIsAbsolute.posix = posix_1;
	pathIsAbsolute.win32 = win32_1;
	var alphasort_1 = alphasort;
	var alphasorti_1 = alphasorti;
	var setopts_1 = setopts$2;
	var ownProp_1 = ownProp$2;
	var makeAbs_1 = makeAbs;
	var finish_1 = finish;
	var mark_1 = mark;
	var isIgnored_1 = isIgnored$2;
	var childrenIgnored_1 = childrenIgnored$2;
	function ownProp$2(obj, field) {
		return Object.prototype.hasOwnProperty.call(obj, field);
	}
	var Minimatch = minimatch_1.Minimatch;
	function alphasorti(a, b) {
		return a.toLowerCase().localeCompare(b.toLowerCase());
	}
	function alphasort(a, b) {
		return a.localeCompare(b);
	}
	function setupIgnores(self$1, options) {
		self$1.ignore = options.ignore || [];
		if (!Array.isArray(self$1.ignore)) self$1.ignore = [self$1.ignore];
		if (self$1.ignore.length) self$1.ignore = self$1.ignore.map(ignoreMap);
	}
	function ignoreMap(pattern) {
		var gmatcher = null;
		if (pattern.slice(-3) === "/**") {
			var gpattern = pattern.replace(/(\/\*\*)+$/, "");
			gmatcher = new Minimatch(gpattern, { dot: true });
		}
		return {
			matcher: new Minimatch(pattern, { dot: true }),
			gmatcher
		};
	}
	function setopts$2(self$1, pattern, options) {
		if (!options) options = {};
		if (options.matchBase && -1 === pattern.indexOf("/")) {
			if (options.noglobstar) throw new Error("base matching requires globstar");
			pattern = "**/" + pattern;
		}
		self$1.silent = !!options.silent;
		self$1.pattern = pattern;
		self$1.strict = options.strict !== false;
		self$1.realpath = !!options.realpath;
		self$1.realpathCache = options.realpathCache || Object.create(null);
		self$1.follow = !!options.follow;
		self$1.dot = !!options.dot;
		self$1.mark = !!options.mark;
		self$1.nodir = !!options.nodir;
		if (self$1.nodir) self$1.mark = true;
		self$1.sync = !!options.sync;
		self$1.nounique = !!options.nounique;
		self$1.nonull = !!options.nonull;
		self$1.nosort = !!options.nosort;
		self$1.nocase = !!options.nocase;
		self$1.stat = !!options.stat;
		self$1.noprocess = !!options.noprocess;
		self$1.absolute = !!options.absolute;
		self$1.maxLength = options.maxLength || Infinity;
		self$1.cache = options.cache || Object.create(null);
		self$1.statCache = options.statCache || Object.create(null);
		self$1.symlinks = options.symlinks || Object.create(null);
		setupIgnores(self$1, options);
		self$1.changedCwd = false;
		var cwd$1 = process.cwd();
		if (!ownProp$2(options, "cwd")) self$1.cwd = cwd$1;
else {
			self$1.cwd = path__default["default"].resolve(options.cwd);
			self$1.changedCwd = self$1.cwd !== cwd$1;
		}
		self$1.root = options.root || path__default["default"].resolve(self$1.cwd, "/");
		self$1.root = path__default["default"].resolve(self$1.root);
		if (process.platform === "win32") self$1.root = self$1.root.replace(/\\/g, "/");
		self$1.cwdAbs = pathIsAbsolute(self$1.cwd) ? self$1.cwd : makeAbs(self$1, self$1.cwd);
		if (process.platform === "win32") self$1.cwdAbs = self$1.cwdAbs.replace(/\\/g, "/");
		self$1.nomount = !!options.nomount;
		options.nonegate = true;
		options.nocomment = true;
		self$1.minimatch = new Minimatch(pattern, options);
		self$1.options = self$1.minimatch.options;
	}
	function finish(self$1) {
		var nou = self$1.nounique;
		var all = nou ? [] : Object.create(null);
		for (var i = 0, l = self$1.matches.length; i < l; i++) {
			var matches = self$1.matches[i];
			if (!matches || Object.keys(matches).length === 0) {
				if (self$1.nonull) {
					var literal = self$1.minimatch.globSet[i];
					if (nou) all.push(literal);
else all[literal] = true;
				}
			} else {
				var m$1 = Object.keys(matches);
				if (nou) all.push.apply(all, m$1);
else m$1.forEach(function(m$2) {
					all[m$2] = true;
				});
			}
		}
		if (!nou) all = Object.keys(all);
		if (!self$1.nosort) all = all.sort(self$1.nocase ? alphasorti : alphasort);
		if (self$1.mark) {
			for (var i = 0; i < all.length; i++) all[i] = self$1._mark(all[i]);
			if (self$1.nodir) all = all.filter(function(e) {
				var notDir = !/\/$/.test(e);
				var c = self$1.cache[e] || self$1.cache[makeAbs(self$1, e)];
				if (notDir && c) notDir = c !== "DIR" && !Array.isArray(c);
				return notDir;
			});
		}
		if (self$1.ignore.length) all = all.filter(function(m$2) {
			return !isIgnored$2(self$1, m$2);
		});
		self$1.found = all;
	}
	function mark(self$1, p) {
		var abs = makeAbs(self$1, p);
		var c = self$1.cache[abs];
		var m$1 = p;
		if (c) {
			var isDir = c === "DIR" || Array.isArray(c);
			var slash = p.slice(-1) === "/";
			if (isDir && !slash) m$1 += "/";
else if (!isDir && slash) m$1 = m$1.slice(0, -1);
			if (m$1 !== p) {
				var mabs = makeAbs(self$1, m$1);
				self$1.statCache[mabs] = self$1.statCache[abs];
				self$1.cache[mabs] = self$1.cache[abs];
			}
		}
		return m$1;
	}
	function makeAbs(self$1, f) {
		var abs = f;
		if (f.charAt(0) === "/") abs = path__default["default"].join(self$1.root, f);
else if (pathIsAbsolute(f) || f === "") abs = f;
else if (self$1.changedCwd) abs = path__default["default"].resolve(self$1.cwd, f);
else abs = path__default["default"].resolve(f);
		if (process.platform === "win32") abs = abs.replace(/\\/g, "/");
		return abs;
	}
	function isIgnored$2(self$1, path$3) {
		if (!self$1.ignore.length) return false;
		return self$1.ignore.some(function(item) {
			return item.matcher.match(path$3) || !!(item.gmatcher && item.gmatcher.match(path$3));
		});
	}
	function childrenIgnored$2(self$1, path$3) {
		if (!self$1.ignore.length) return false;
		return self$1.ignore.some(function(item) {
			return !!(item.gmatcher && item.gmatcher.match(path$3));
		});
	}
	var common$1 = {
		alphasort: alphasort_1,
		alphasorti: alphasorti_1,
		setopts: setopts_1,
		ownProp: ownProp_1,
		makeAbs: makeAbs_1,
		finish: finish_1,
		mark: mark_1,
		isIgnored: isIgnored_1,
		childrenIgnored: childrenIgnored_1
	};
	var sync = globSync;
	globSync.GlobSync = GlobSync$1;
	var setopts$1 = common$1.setopts;
	var ownProp$1 = common$1.ownProp;
	var childrenIgnored$1 = common$1.childrenIgnored;
	var isIgnored$1 = common$1.isIgnored;
	function globSync(pattern, options) {
		if (typeof options === "function" || arguments.length === 3) throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
		return new GlobSync$1(pattern, options).found;
	}
	function GlobSync$1(pattern, options) {
		if (!pattern) throw new Error("must provide pattern");
		if (typeof options === "function" || arguments.length === 3) throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
		if (!(this instanceof GlobSync$1)) return new GlobSync$1(pattern, options);
		setopts$1(this, pattern, options);
		if (this.noprocess) return this;
		var n = this.minimatch.set.length;
		this.matches = new Array(n);
		for (var i = 0; i < n; i++) this._process(this.minimatch.set[i], i, false);
		this._finish();
	}
	GlobSync$1.prototype._finish = function() {
		assert__default["default"](this instanceof GlobSync$1);
		if (this.realpath) {
			var self$1 = this;
			this.matches.forEach(function(matchset, index$1) {
				var set = self$1.matches[index$1] = Object.create(null);
				for (var p in matchset) try {
					p = self$1._makeAbs(p);
					var real = fs_realpath.realpathSync(p, self$1.realpathCache);
					set[real] = true;
				} catch (er) {
					if (er.syscall === "stat") set[self$1._makeAbs(p)] = true;
else throw er;
				}
			});
		}
		common$1.finish(this);
	};
	GlobSync$1.prototype._process = function(pattern, index$1, inGlobStar) {
		assert__default["default"](this instanceof GlobSync$1);
		var n = 0;
		while (typeof pattern[n] === "string") n++;
		var prefix;
		switch (n) {
			case pattern.length:
				this._processSimple(pattern.join("/"), index$1);
				return;
			case 0:
				prefix = null;
				break;
			default:
				prefix = pattern.slice(0, n).join("/");
				break;
		}
		var remain = pattern.slice(n);
		var read;
		if (prefix === null) read = ".";
else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join("/"))) {
			if (!prefix || !pathIsAbsolute(prefix)) prefix = "/" + prefix;
			read = prefix;
		} else read = prefix;
		var abs = this._makeAbs(read);
		if (childrenIgnored$1(this, read)) return;
		var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
		if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index$1, inGlobStar);
else this._processReaddir(prefix, read, abs, remain, index$1, inGlobStar);
	};
	GlobSync$1.prototype._processReaddir = function(prefix, read, abs, remain, index$1, inGlobStar) {
		var entries = this._readdir(abs, inGlobStar);
		if (!entries) return;
		var pn = remain[0];
		var negate = !!this.minimatch.negate;
		var rawGlob = pn._glob;
		var dotOk = this.dot || rawGlob.charAt(0) === ".";
		var matchedEntries = [];
		for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (e.charAt(0) !== "." || dotOk) {
				var m$1;
				if (negate && !prefix) m$1 = !e.match(pn);
else m$1 = e.match(pn);
				if (m$1) matchedEntries.push(e);
			}
		}
		var len = matchedEntries.length;
		if (len === 0) return;
		if (remain.length === 1 && !this.mark && !this.stat) {
			if (!this.matches[index$1]) this.matches[index$1] = Object.create(null);
			for (var i = 0; i < len; i++) {
				var e = matchedEntries[i];
				if (prefix) if (prefix.slice(-1) !== "/") e = prefix + "/" + e;
else e = prefix + e;
				if (e.charAt(0) === "/" && !this.nomount) e = path__default["default"].join(this.root, e);
				this._emitMatch(index$1, e);
			}
			return;
		}
		remain.shift();
		for (var i = 0; i < len; i++) {
			var e = matchedEntries[i];
			var newPattern;
			if (prefix) newPattern = [prefix, e];
else newPattern = [e];
			this._process(newPattern.concat(remain), index$1, inGlobStar);
		}
	};
	GlobSync$1.prototype._emitMatch = function(index$1, e) {
		if (isIgnored$1(this, e)) return;
		var abs = this._makeAbs(e);
		if (this.mark) e = this._mark(e);
		if (this.absolute) e = abs;
		if (this.matches[index$1][e]) return;
		if (this.nodir) {
			var c = this.cache[abs];
			if (c === "DIR" || Array.isArray(c)) return;
		}
		this.matches[index$1][e] = true;
		if (this.stat) this._stat(e);
	};
	GlobSync$1.prototype._readdirInGlobStar = function(abs) {
		if (this.follow) return this._readdir(abs, false);
		var entries;
		var lstat;
		try {
			lstat = fs__default["default"].lstatSync(abs);
		} catch (er) {
			if (er.code === "ENOENT") return null;
		}
		var isSym = lstat && lstat.isSymbolicLink();
		this.symlinks[abs] = isSym;
		if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = "FILE";
else entries = this._readdir(abs, false);
		return entries;
	};
	GlobSync$1.prototype._readdir = function(abs, inGlobStar) {
		if (inGlobStar && !ownProp$1(this.symlinks, abs)) return this._readdirInGlobStar(abs);
		if (ownProp$1(this.cache, abs)) {
			var c = this.cache[abs];
			if (!c || c === "FILE") return null;
			if (Array.isArray(c)) return c;
		}
		try {
			return this._readdirEntries(abs, fs__default["default"].readdirSync(abs));
		} catch (er) {
			this._readdirError(abs, er);
			return null;
		}
	};
	GlobSync$1.prototype._readdirEntries = function(abs, entries) {
		if (!this.mark && !this.stat) for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (abs === "/") e = abs + e;
else e = abs + "/" + e;
			this.cache[e] = true;
		}
		this.cache[abs] = entries;
		return entries;
	};
	GlobSync$1.prototype._readdirError = function(f, er) {
		switch (er.code) {
			case "ENOTSUP":
			case "ENOTDIR":
				var abs = this._makeAbs(f);
				this.cache[abs] = "FILE";
				if (abs === this.cwdAbs) {
					var error = new Error(er.code + " invalid cwd " + this.cwd);
					error.path = this.cwd;
					error.code = er.code;
					throw error;
				}
				break;
			case "ENOENT":
			case "ELOOP":
			case "ENAMETOOLONG":
			case "UNKNOWN":
				this.cache[this._makeAbs(f)] = false;
				break;
			default:
				this.cache[this._makeAbs(f)] = false;
				if (this.strict) throw er;
				if (!this.silent) console.error("glob error", er);
				break;
		}
	};
	GlobSync$1.prototype._processGlobStar = function(prefix, read, abs, remain, index$1, inGlobStar) {
		var entries = this._readdir(abs, inGlobStar);
		if (!entries) return;
		var remainWithoutGlobStar = remain.slice(1);
		var gspref = prefix ? [prefix] : [];
		var noGlobStar = gspref.concat(remainWithoutGlobStar);
		this._process(noGlobStar, index$1, false);
		var len = entries.length;
		var isSym = this.symlinks[abs];
		if (isSym && inGlobStar) return;
		for (var i = 0; i < len; i++) {
			var e = entries[i];
			if (e.charAt(0) === "." && !this.dot) continue;
			var instead = gspref.concat(entries[i], remainWithoutGlobStar);
			this._process(instead, index$1, true);
			var below = gspref.concat(entries[i], remain);
			this._process(below, index$1, true);
		}
	};
	GlobSync$1.prototype._processSimple = function(prefix, index$1) {
		var exists = this._stat(prefix);
		if (!this.matches[index$1]) this.matches[index$1] = Object.create(null);
		if (!exists) return;
		if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
			var trail = /[\/\\]$/.test(prefix);
			if (prefix.charAt(0) === "/") prefix = path__default["default"].join(this.root, prefix);
else {
				prefix = path__default["default"].resolve(this.root, prefix);
				if (trail) prefix += "/";
			}
		}
		if (process.platform === "win32") prefix = prefix.replace(/\\/g, "/");
		this._emitMatch(index$1, prefix);
	};
	GlobSync$1.prototype._stat = function(f) {
		var abs = this._makeAbs(f);
		var needDir = f.slice(-1) === "/";
		if (f.length > this.maxLength) return false;
		if (!this.stat && ownProp$1(this.cache, abs)) {
			var c = this.cache[abs];
			if (Array.isArray(c)) c = "DIR";
			if (!needDir || c === "DIR") return c;
			if (needDir && c === "FILE") return false;
		}
		var stat = this.statCache[abs];
		if (!stat) {
			var lstat;
			try {
				lstat = fs__default["default"].lstatSync(abs);
			} catch (er) {
				if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
					this.statCache[abs] = false;
					return false;
				}
			}
			if (lstat && lstat.isSymbolicLink()) try {
				stat = fs__default["default"].statSync(abs);
			} catch (er) {
				stat = lstat;
			}
else stat = lstat;
		}
		this.statCache[abs] = stat;
		var c = true;
		if (stat) c = stat.isDirectory() ? "DIR" : "FILE";
		this.cache[abs] = this.cache[abs] || c;
		if (needDir && c === "FILE") return false;
		return c;
	};
	GlobSync$1.prototype._mark = function(p) {
		return common$1.mark(this, p);
	};
	GlobSync$1.prototype._makeAbs = function(f) {
		return common$1.makeAbs(this, f);
	};
	var wrappy_1 = wrappy;
	function wrappy(fn, cb) {
		if (fn && cb) return wrappy(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
	var once_1 = wrappy_1(once);
	var strict = wrappy_1(onceStrict);
	once.proto = once(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		var name = fn.name || "Function wrapped with `once`";
		f.onceError = name + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
	once_1.strict = strict;
	var reqs = Object.create(null);
	var inflight_1 = wrappy_1(inflight);
	function inflight(key, cb) {
		if (reqs[key]) {
			reqs[key].push(cb);
			return null;
		} else {
			reqs[key] = [cb];
			return makeres(key);
		}
	}
	function makeres(key) {
		return once_1(function RES() {
			var cbs = reqs[key];
			var len = cbs.length;
			var args = slice$1(arguments);
			try {
				for (var i = 0; i < len; i++) cbs[i].apply(null, args);
			} finally {
				if (cbs.length > len) {
					cbs.splice(0, len);
					process.nextTick(function() {
						RES.apply(null, args);
					});
				} else delete reqs[key];
			}
		});
	}
	function slice$1(args) {
		var length = args.length;
		var array = [];
		for (var i = 0; i < length; i++) array[i] = args[i];
		return array;
	}
	var glob_1 = glob$1;
	var EE = Events__default["default"].EventEmitter;
	var setopts = common$1.setopts;
	var ownProp = common$1.ownProp;
	var childrenIgnored = common$1.childrenIgnored;
	var isIgnored = common$1.isIgnored;
	function glob$1(pattern, options, cb) {
		if (typeof options === "function") cb = options, options = {};
		if (!options) options = {};
		if (options.sync) {
			if (cb) throw new TypeError("callback provided to sync glob");
			return sync(pattern, options);
		}
		return new Glob(pattern, options, cb);
	}
	glob$1.sync = sync;
	var GlobSync = glob$1.GlobSync = sync.GlobSync;
	glob$1.glob = glob$1;
	function extend(origin, add) {
		if (add === null || typeof add !== "object") return origin;
		var keys = Object.keys(add);
		var i = keys.length;
		while (i--) origin[keys[i]] = add[keys[i]];
		return origin;
	}
	glob$1.hasMagic = function(pattern, options_) {
		var options = extend({}, options_);
		options.noprocess = true;
		var g = new Glob(pattern, options);
		var set = g.minimatch.set;
		if (!pattern) return false;
		if (set.length > 1) return true;
		for (var j = 0; j < set[0].length; j++) if (typeof set[0][j] !== "string") return true;
		return false;
	};
	glob$1.Glob = Glob;
	inherits(Glob, EE);
	function Glob(pattern, options, cb) {
		if (typeof options === "function") {
			cb = options;
			options = null;
		}
		if (options && options.sync) {
			if (cb) throw new TypeError("callback provided to sync glob");
			return new GlobSync(pattern, options);
		}
		if (!(this instanceof Glob)) return new Glob(pattern, options, cb);
		setopts(this, pattern, options);
		this._didRealPath = false;
		var n = this.minimatch.set.length;
		this.matches = new Array(n);
		if (typeof cb === "function") {
			cb = once_1(cb);
			this.on("error", cb);
			this.on("end", function(matches) {
				cb(null, matches);
			});
		}
		var self$1 = this;
		this._processing = 0;
		this._emitQueue = [];
		this._processQueue = [];
		this.paused = false;
		if (this.noprocess) return this;
		if (n === 0) return done();
		var sync$2 = true;
		for (var i = 0; i < n; i++) this._process(this.minimatch.set[i], i, false, done);
		sync$2 = false;
		function done() {
			--self$1._processing;
			if (self$1._processing <= 0) if (sync$2) process.nextTick(function() {
				self$1._finish();
			});
else self$1._finish();
		}
	}
	Glob.prototype._finish = function() {
		assert__default["default"](this instanceof Glob);
		if (this.aborted) return;
		if (this.realpath && !this._didRealpath) return this._realpath();
		common$1.finish(this);
		this.emit("end", this.found);
	};
	Glob.prototype._realpath = function() {
		if (this._didRealpath) return;
		this._didRealpath = true;
		var n = this.matches.length;
		if (n === 0) return this._finish();
		var self$1 = this;
		for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);
		function next() {
			if (--n === 0) self$1._finish();
		}
	};
	Glob.prototype._realpathSet = function(index$1, cb) {
		var matchset = this.matches[index$1];
		if (!matchset) return cb();
		var found = Object.keys(matchset);
		var self$1 = this;
		var n = found.length;
		if (n === 0) return cb();
		var set = this.matches[index$1] = Object.create(null);
		found.forEach(function(p, i) {
			p = self$1._makeAbs(p);
			fs_realpath.realpath(p, self$1.realpathCache, function(er, real) {
				if (!er) set[real] = true;
else if (er.syscall === "stat") set[p] = true;
else self$1.emit("error", er);
				if (--n === 0) {
					self$1.matches[index$1] = set;
					cb();
				}
			});
		});
	};
	Glob.prototype._mark = function(p) {
		return common$1.mark(this, p);
	};
	Glob.prototype._makeAbs = function(f) {
		return common$1.makeAbs(this, f);
	};
	Glob.prototype.abort = function() {
		this.aborted = true;
		this.emit("abort");
	};
	Glob.prototype.pause = function() {
		if (!this.paused) {
			this.paused = true;
			this.emit("pause");
		}
	};
	Glob.prototype.resume = function() {
		if (this.paused) {
			this.emit("resume");
			this.paused = false;
			if (this._emitQueue.length) {
				var eq = this._emitQueue.slice(0);
				this._emitQueue.length = 0;
				for (var i = 0; i < eq.length; i++) {
					var e = eq[i];
					this._emitMatch(e[0], e[1]);
				}
			}
			if (this._processQueue.length) {
				var pq = this._processQueue.slice(0);
				this._processQueue.length = 0;
				for (var i = 0; i < pq.length; i++) {
					var p = pq[i];
					this._processing--;
					this._process(p[0], p[1], p[2], p[3]);
				}
			}
		}
	};
	Glob.prototype._process = function(pattern, index$1, inGlobStar, cb) {
		assert__default["default"](this instanceof Glob);
		assert__default["default"](typeof cb === "function");
		if (this.aborted) return;
		this._processing++;
		if (this.paused) {
			this._processQueue.push([
				pattern,
				index$1,
				inGlobStar,
				cb
			]);
			return;
		}
		var n = 0;
		while (typeof pattern[n] === "string") n++;
		var prefix;
		switch (n) {
			case pattern.length:
				this._processSimple(pattern.join("/"), index$1, cb);
				return;
			case 0:
				prefix = null;
				break;
			default:
				prefix = pattern.slice(0, n).join("/");
				break;
		}
		var remain = pattern.slice(n);
		var read;
		if (prefix === null) read = ".";
else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join("/"))) {
			if (!prefix || !pathIsAbsolute(prefix)) prefix = "/" + prefix;
			read = prefix;
		} else read = prefix;
		var abs = this._makeAbs(read);
		if (childrenIgnored(this, read)) return cb();
		var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
		if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index$1, inGlobStar, cb);
else this._processReaddir(prefix, read, abs, remain, index$1, inGlobStar, cb);
	};
	Glob.prototype._processReaddir = function(prefix, read, abs, remain, index$1, inGlobStar, cb) {
		var self$1 = this;
		this._readdir(abs, inGlobStar, function(er, entries) {
			return self$1._processReaddir2(prefix, read, abs, remain, index$1, inGlobStar, entries, cb);
		});
	};
	Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index$1, inGlobStar, entries, cb) {
		if (!entries) return cb();
		var pn = remain[0];
		var negate = !!this.minimatch.negate;
		var rawGlob = pn._glob;
		var dotOk = this.dot || rawGlob.charAt(0) === ".";
		var matchedEntries = [];
		for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (e.charAt(0) !== "." || dotOk) {
				var m$1;
				if (negate && !prefix) m$1 = !e.match(pn);
else m$1 = e.match(pn);
				if (m$1) matchedEntries.push(e);
			}
		}
		var len = matchedEntries.length;
		if (len === 0) return cb();
		if (remain.length === 1 && !this.mark && !this.stat) {
			if (!this.matches[index$1]) this.matches[index$1] = Object.create(null);
			for (var i = 0; i < len; i++) {
				var e = matchedEntries[i];
				if (prefix) if (prefix !== "/") e = prefix + "/" + e;
else e = prefix + e;
				if (e.charAt(0) === "/" && !this.nomount) e = path__default["default"].join(this.root, e);
				this._emitMatch(index$1, e);
			}
			return cb();
		}
		remain.shift();
		for (var i = 0; i < len; i++) {
			var e = matchedEntries[i];
			if (prefix) if (prefix !== "/") e = prefix + "/" + e;
else e = prefix + e;
			this._process([e].concat(remain), index$1, inGlobStar, cb);
		}
		cb();
	};
	Glob.prototype._emitMatch = function(index$1, e) {
		if (this.aborted) return;
		if (isIgnored(this, e)) return;
		if (this.paused) {
			this._emitQueue.push([index$1, e]);
			return;
		}
		var abs = pathIsAbsolute(e) ? e : this._makeAbs(e);
		if (this.mark) e = this._mark(e);
		if (this.absolute) e = abs;
		if (this.matches[index$1][e]) return;
		if (this.nodir) {
			var c = this.cache[abs];
			if (c === "DIR" || Array.isArray(c)) return;
		}
		this.matches[index$1][e] = true;
		var st = this.statCache[abs];
		if (st) this.emit("stat", e, st);
		this.emit("match", e);
	};
	Glob.prototype._readdirInGlobStar = function(abs, cb) {
		if (this.aborted) return;
		if (this.follow) return this._readdir(abs, false, cb);
		var lstatkey = "lstat\0" + abs;
		var self$1 = this;
		var lstatcb = inflight_1(lstatkey, lstatcb_);
		if (lstatcb) fs__default["default"].lstat(abs, lstatcb);
		function lstatcb_(er, lstat) {
			if (er && er.code === "ENOENT") return cb();
			var isSym = lstat && lstat.isSymbolicLink();
			self$1.symlinks[abs] = isSym;
			if (!isSym && lstat && !lstat.isDirectory()) {
				self$1.cache[abs] = "FILE";
				cb();
			} else self$1._readdir(abs, false, cb);
		}
	};
	Glob.prototype._readdir = function(abs, inGlobStar, cb) {
		if (this.aborted) return;
		cb = inflight_1("readdir\0" + abs + "\0" + inGlobStar, cb);
		if (!cb) return;
		if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);
		if (ownProp(this.cache, abs)) {
			var c = this.cache[abs];
			if (!c || c === "FILE") return cb();
			if (Array.isArray(c)) return cb(null, c);
		}
		fs__default["default"].readdir(abs, readdirCb(this, abs, cb));
	};
	function readdirCb(self$1, abs, cb) {
		return function(er, entries) {
			if (er) self$1._readdirError(abs, er, cb);
else self$1._readdirEntries(abs, entries, cb);
		};
	}
	Glob.prototype._readdirEntries = function(abs, entries, cb) {
		if (this.aborted) return;
		if (!this.mark && !this.stat) for (var i = 0; i < entries.length; i++) {
			var e = entries[i];
			if (abs === "/") e = abs + e;
else e = abs + "/" + e;
			this.cache[e] = true;
		}
		this.cache[abs] = entries;
		return cb(null, entries);
	};
	Glob.prototype._readdirError = function(f, er, cb) {
		if (this.aborted) return;
		switch (er.code) {
			case "ENOTSUP":
			case "ENOTDIR":
				var abs = this._makeAbs(f);
				this.cache[abs] = "FILE";
				if (abs === this.cwdAbs) {
					var error = new Error(er.code + " invalid cwd " + this.cwd);
					error.path = this.cwd;
					error.code = er.code;
					this.emit("error", error);
					this.abort();
				}
				break;
			case "ENOENT":
			case "ELOOP":
			case "ENAMETOOLONG":
			case "UNKNOWN":
				this.cache[this._makeAbs(f)] = false;
				break;
			default:
				this.cache[this._makeAbs(f)] = false;
				if (this.strict) {
					this.emit("error", er);
					this.abort();
				}
				if (!this.silent) console.error("glob error", er);
				break;
		}
		return cb();
	};
	Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index$1, inGlobStar, cb) {
		var self$1 = this;
		this._readdir(abs, inGlobStar, function(er, entries) {
			self$1._processGlobStar2(prefix, read, abs, remain, index$1, inGlobStar, entries, cb);
		});
	};
	Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index$1, inGlobStar, entries, cb) {
		if (!entries) return cb();
		var remainWithoutGlobStar = remain.slice(1);
		var gspref = prefix ? [prefix] : [];
		var noGlobStar = gspref.concat(remainWithoutGlobStar);
		this._process(noGlobStar, index$1, false, cb);
		var isSym = this.symlinks[abs];
		var len = entries.length;
		if (isSym && inGlobStar) return cb();
		for (var i = 0; i < len; i++) {
			var e = entries[i];
			if (e.charAt(0) === "." && !this.dot) continue;
			var instead = gspref.concat(entries[i], remainWithoutGlobStar);
			this._process(instead, index$1, true, cb);
			var below = gspref.concat(entries[i], remain);
			this._process(below, index$1, true, cb);
		}
		cb();
	};
	Glob.prototype._processSimple = function(prefix, index$1, cb) {
		var self$1 = this;
		this._stat(prefix, function(er, exists) {
			self$1._processSimple2(prefix, index$1, er, exists, cb);
		});
	};
	Glob.prototype._processSimple2 = function(prefix, index$1, er, exists, cb) {
		if (!this.matches[index$1]) this.matches[index$1] = Object.create(null);
		if (!exists) return cb();
		if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
			var trail = /[\/\\]$/.test(prefix);
			if (prefix.charAt(0) === "/") prefix = path__default["default"].join(this.root, prefix);
else {
				prefix = path__default["default"].resolve(this.root, prefix);
				if (trail) prefix += "/";
			}
		}
		if (process.platform === "win32") prefix = prefix.replace(/\\/g, "/");
		this._emitMatch(index$1, prefix);
		cb();
	};
	Glob.prototype._stat = function(f, cb) {
		var abs = this._makeAbs(f);
		var needDir = f.slice(-1) === "/";
		if (f.length > this.maxLength) return cb();
		if (!this.stat && ownProp(this.cache, abs)) {
			var c = this.cache[abs];
			if (Array.isArray(c)) c = "DIR";
			if (!needDir || c === "DIR") return cb(null, c);
			if (needDir && c === "FILE") return cb();
		}
		var stat = this.statCache[abs];
		if (stat !== undefined) if (stat === false) return cb(null, stat);
else {
			var type = stat.isDirectory() ? "DIR" : "FILE";
			if (needDir && type === "FILE") return cb();
else return cb(null, type, stat);
		}
		var self$1 = this;
		var statcb = inflight_1("stat\0" + abs, lstatcb_);
		if (statcb) fs__default["default"].lstat(abs, statcb);
		function lstatcb_(er, lstat) {
			if (lstat && lstat.isSymbolicLink()) return fs__default["default"].stat(abs, function(er$1, stat$1) {
				if (er$1) self$1._stat2(f, abs, null, lstat, cb);
else self$1._stat2(f, abs, er$1, stat$1, cb);
			});
else self$1._stat2(f, abs, er, lstat, cb);
		}
	};
	Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
		if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
			this.statCache[abs] = false;
			return cb();
		}
		var needDir = f.slice(-1) === "/";
		this.statCache[abs] = stat;
		if (abs.slice(-1) === "/" && stat && !stat.isDirectory()) return cb(null, false, stat);
		var c = true;
		if (stat) c = stat.isDirectory() ? "DIR" : "FILE";
		this.cache[abs] = this.cache[abs] || c;
		if (needDir && c === "FILE") return cb();
		return cb(null, c, stat);
	};
	var rimraf_1 = rimraf;
	rimraf.sync = rimrafSync$1;
	var glob = undefined;
	try {
		glob = glob_1;
	} catch (_err) {}
	var _0666 = parseInt("666", 8);
	var defaultGlobOpts = {
		nosort: true,
		silent: true
	};
	var timeout = 0;
	var isWindows = process.platform === "win32";
	function defaults(options) {
		var methods = [
			"unlink",
			"chmod",
			"stat",
			"lstat",
			"rmdir",
			"readdir"
		];
		methods.forEach(function(m$1) {
			options[m$1] = options[m$1] || fs__default["default"][m$1];
			m$1 = m$1 + "Sync";
			options[m$1] = options[m$1] || fs__default["default"][m$1];
		});
		options.maxBusyTries = options.maxBusyTries || 3;
		options.emfileWait = options.emfileWait || 1e3;
		if (options.glob === false) options.disableGlob = true;
		if (options.disableGlob !== true && glob === undefined) throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
		options.disableGlob = options.disableGlob || false;
		options.glob = options.glob || defaultGlobOpts;
	}
	function rimraf(p, options, cb) {
		if (typeof options === "function") {
			cb = options;
			options = {};
		}
		assert__default["default"](p, "rimraf: missing path");
		assert__default["default"].equal(typeof p, "string", "rimraf: path should be a string");
		assert__default["default"].equal(typeof cb, "function", "rimraf: callback function required");
		assert__default["default"](options, "rimraf: invalid options argument provided");
		assert__default["default"].equal(typeof options, "object", "rimraf: options should be object");
		defaults(options);
		var busyTries = 0;
		var errState = null;
		var n = 0;
		if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [p]);
		options.lstat(p, function(er, stat) {
			if (!er) return afterGlob(null, [p]);
			glob(p, options.glob, afterGlob);
		});
		function next(er) {
			errState = errState || er;
			if (--n === 0) cb(errState);
		}
		function afterGlob(er, results) {
			if (er) return cb(er);
			n = results.length;
			if (n === 0) return cb();
			results.forEach(function(p$1) {
				rimraf_(p$1, options, function CB(er$1) {
					if (er$1) {
						if ((er$1.code === "EBUSY" || er$1.code === "ENOTEMPTY" || er$1.code === "EPERM") && busyTries < options.maxBusyTries) {
							busyTries++;
							var time = busyTries * 100;
							return setTimeout(function() {
								rimraf_(p$1, options, CB);
							}, time);
						}
						if (er$1.code === "EMFILE" && timeout < options.emfileWait) return setTimeout(function() {
							rimraf_(p$1, options, CB);
						}, timeout++);
						if (er$1.code === "ENOENT") er$1 = null;
					}
					timeout = 0;
					next(er$1);
				});
			});
		}
	}
	function rimraf_(p, options, cb) {
		assert__default["default"](p);
		assert__default["default"](options);
		assert__default["default"](typeof cb === "function");
		options.lstat(p, function(er, st) {
			if (er && er.code === "ENOENT") return cb(null);
			if (er && er.code === "EPERM" && isWindows) fixWinEPERM(p, options, er, cb);
			if (st && st.isDirectory()) return rmdir(p, options, er, cb);
			options.unlink(p, function(er$1) {
				if (er$1) {
					if (er$1.code === "ENOENT") return cb(null);
					if (er$1.code === "EPERM") return isWindows ? fixWinEPERM(p, options, er$1, cb) : rmdir(p, options, er$1, cb);
					if (er$1.code === "EISDIR") return rmdir(p, options, er$1, cb);
				}
				return cb(er$1);
			});
		});
	}
	function fixWinEPERM(p, options, er, cb) {
		assert__default["default"](p);
		assert__default["default"](options);
		assert__default["default"](typeof cb === "function");
		if (er) assert__default["default"](er instanceof Error);
		options.chmod(p, _0666, function(er2) {
			if (er2) cb(er2.code === "ENOENT" ? null : er);
else options.stat(p, function(er3, stats) {
				if (er3) cb(er3.code === "ENOENT" ? null : er);
else if (stats.isDirectory()) rmdir(p, options, er, cb);
else options.unlink(p, cb);
			});
		});
	}
	function fixWinEPERMSync(p, options, er) {
		assert__default["default"](p);
		assert__default["default"](options);
		if (er) assert__default["default"](er instanceof Error);
		try {
			options.chmodSync(p, _0666);
		} catch (er2) {
			if (er2.code === "ENOENT") return;
else throw er;
		}
		try {
			var stats = options.statSync(p);
		} catch (er3) {
			if (er3.code === "ENOENT") return;
else throw er;
		}
		if (stats.isDirectory()) rmdirSync(p, options, er);
else options.unlinkSync(p);
	}
	function rmdir(p, options, originalEr, cb) {
		assert__default["default"](p);
		assert__default["default"](options);
		if (originalEr) assert__default["default"](originalEr instanceof Error);
		assert__default["default"](typeof cb === "function");
		options.rmdir(p, function(er) {
			if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) rmkids(p, options, cb);
else if (er && er.code === "ENOTDIR") cb(originalEr);
else cb(er);
		});
	}
	function rmkids(p, options, cb) {
		assert__default["default"](p);
		assert__default["default"](options);
		assert__default["default"](typeof cb === "function");
		options.readdir(p, function(er, files) {
			if (er) return cb(er);
			var n = files.length;
			if (n === 0) return options.rmdir(p, cb);
			var errState;
			files.forEach(function(f) {
				rimraf(path__default["default"].join(p, f), options, function(er$1) {
					if (errState) return;
					if (er$1) return cb(errState = er$1);
					if (--n === 0) options.rmdir(p, cb);
				});
			});
		});
	}
	function rimrafSync$1(p, options) {
		options = options || {};
		defaults(options);
		assert__default["default"](p, "rimraf: missing path");
		assert__default["default"].equal(typeof p, "string", "rimraf: path should be a string");
		assert__default["default"](options, "rimraf: missing options");
		assert__default["default"].equal(typeof options, "object", "rimraf: options should be object");
		var results;
		if (options.disableGlob || !glob.hasMagic(p)) results = [p];
else try {
			options.lstatSync(p);
			results = [p];
		} catch (er) {
			results = glob.sync(p, options.glob);
		}
		if (!results.length) return;
		for (var i = 0; i < results.length; i++) {
			var p = results[i];
			try {
				var st = options.lstatSync(p);
			} catch (er) {
				if (er.code === "ENOENT") return;
				if (er.code === "EPERM" && isWindows) fixWinEPERMSync(p, options, er);
			}
			try {
				if (st && st.isDirectory()) rmdirSync(p, options, null);
else options.unlinkSync(p);
			} catch (er) {
				if (er.code === "ENOENT") return;
				if (er.code === "EPERM") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
				if (er.code !== "EISDIR") throw er;
				rmdirSync(p, options, er);
			}
		}
	}
	function rmdirSync(p, options, originalEr) {
		assert__default["default"](p);
		assert__default["default"](options);
		if (originalEr) assert__default["default"](originalEr instanceof Error);
		try {
			options.rmdirSync(p);
		} catch (er) {
			if (er.code === "ENOENT") return;
			if (er.code === "ENOTDIR") throw originalEr;
			if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") rmkidsSync(p, options);
		}
	}
	function rmkidsSync(p, options) {
		assert__default["default"](p);
		assert__default["default"](options);
		options.readdirSync(p).forEach(function(f) {
			rimrafSync$1(path__default["default"].join(p, f), options);
		});
		var retries = isWindows ? 100 : 1;
		var i = 0;
		do {
			var threw = true;
			try {
				var ret = options.rmdirSync(p, options);
				threw = false;
				return ret;
			} finally {
				if (++i < retries && threw) continue;
			}
		} while (true);
	}
	function _interopDefault$1(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var mkdirp$1 = _interopDefault$1(mkdirp$2);
	var _rimraf = _interopDefault$1(rimraf_1);
	function resolvePath(args) {
		return path__default["default"].resolve.apply(null, args);
	}
	function resolvePathAndOptions(args) {
		var options;
		var pathargs;
		if (typeof args[args.length - 1] === "object") {
			options = args[args.length - 1];
			var i = args.length - 1;
			pathargs = new Array(i);
			while (i--) pathargs[i] = args[i];
		} else {
			options = {};
			pathargs = args;
		}
		var resolvedPath = path__default["default"].resolve.apply(null, pathargs);
		return {
			options,
			resolvedPath
		};
	}
	function copydirSync() {
		var ref = resolvePathAndOptions(arguments);
		var src$2 = ref.resolvedPath;
		var readOptions = ref.options;
		return { to: function to() {
			var ref$1 = resolvePathAndOptions(arguments);
			var dest = ref$1.resolvedPath;
			var writeOptions = ref$1.options;
			function copydir(src$3, dest$1) {
				mkdirp$1.sync(dest$1);
				gracefulFs.readdirSync(src$3).forEach(function(filename) {
					var srcpath = src$3 + path__default["default"].sep + filename;
					var destpath = dest$1 + path__default["default"].sep + filename;
					if (gracefulFs.statSync(srcpath).isDirectory()) return copydir(srcpath, destpath);
					var data = gracefulFs.readFileSync(srcpath, readOptions);
					gracefulFs.writeFileSync(destpath, data, writeOptions);
				});
			}
			copydir(src$2, dest);
		} };
	}
	function rimrafSync() {
		_rimraf.sync(resolvePath(arguments));
	}
	process.platform === "win32";
	gracefulFs.closeSync;
	gracefulFs.fchmodSync;
	gracefulFs.fchownSync;
	gracefulFs.fstatSync;
	gracefulFs.fsyncSync;
	gracefulFs.ftruncateSync;
	gracefulFs.futimesSync;
	gracefulFs.readSync;
	var copydirSync_1 = copydirSync;
	var rimrafSync_1 = rimrafSync;
	var homeOrTmp = os__default["default"].homedir() || os__default["default"].tmpdir();
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	var ms = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$1(val);
else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$1(str) {
		str = String(str);
		if (str.length > 100) return;
		var match$1 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match$1) return;
		var n = parseFloat(match$1[1]);
		var type = (match$1[2] || "ms").toLowerCase();
		switch (type) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return undefined;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms$1) {
		var msAbs = Math.abs(ms$1);
		if (msAbs >= d) return Math.round(ms$1 / d) + "d";
		if (msAbs >= h) return Math.round(ms$1 / h) + "h";
		if (msAbs >= m) return Math.round(ms$1 / m) + "m";
		if (msAbs >= s) return Math.round(ms$1 / s) + "s";
		return ms$1 + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms$1) {
		var msAbs = Math.abs(ms$1);
		if (msAbs >= d) return plural(ms$1, msAbs, d, "day");
		if (msAbs >= h) return plural(ms$1, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms$1, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms$1, msAbs, s, "second");
		return ms$1 + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms$1, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms$1 / n) + " " + name + (isPlural ? "s" : "");
	}
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup$1(env$2) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = ms;
		createDebug.destroy = destroy;
		Object.keys(env$2).forEach((key) => {
			createDebug[key] = env$2[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			function debug$3(...args) {
				if (!debug$3.enabled) return;
				const self$1 = debug$3;
				const curr = Number(new Date());
				const ms$1 = curr - (prevTime || curr);
				self$1.diff = ms$1;
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index$1 = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match$1, format) => {
					if (match$1 === "%%") return "%";
					index$1++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index$1];
						match$1 = formatter.call(self$1, val);
						args.splice(index$1, 1);
						index$1--;
					}
					return match$1;
				});
				createDebug.formatArgs.call(self$1, args);
				const logFn = self$1.log || createDebug.log;
				logFn.apply(self$1, args);
			}
			debug$3.namespace = namespace;
			debug$3.useColors = createDebug.useColors();
			debug$3.color = createDebug.selectColor(namespace);
			debug$3.extend = extend$1;
			debug$3.destroy = createDebug.destroy;
			Object.defineProperty(debug$3, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$3);
			return debug$3;
		}
		function extend$1(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.names = [];
			createDebug.skips = [];
			let i;
			const split$2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
			const len = split$2.length;
			for (i = 0; i < len; i++) {
				if (!split$2[i]) continue;
				namespaces = split$2[i].replace(/\*/g, ".*?");
				if (namespaces[0] === "-") createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
else createDebug.names.push(new RegExp("^" + namespaces + "$"));
			}
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === "*") return true;
			let i;
			let len;
			for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return false;
			for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return true;
			return false;
		}
		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	var common = setup$1;
	var browser = createCommonjsModule(function(module$1, exports$1) {
		/**
		* This is the web browser implementation of `debug()`.
		*/
		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.storage = localstorage();
		exports$1.destroy = (() => {
			let warned = false;
			return () => {
				if (!warned) {
					warned = true;
					console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
				}
			};
		})();
		/**
		* Colors.
		*/
		exports$1.colors = [
			"#0000CC",
			"#0000FF",
			"#0033CC",
			"#0033FF",
			"#0066CC",
			"#0066FF",
			"#0099CC",
			"#0099FF",
			"#00CC00",
			"#00CC33",
			"#00CC66",
			"#00CC99",
			"#00CCCC",
			"#00CCFF",
			"#3300CC",
			"#3300FF",
			"#3333CC",
			"#3333FF",
			"#3366CC",
			"#3366FF",
			"#3399CC",
			"#3399FF",
			"#33CC00",
			"#33CC33",
			"#33CC66",
			"#33CC99",
			"#33CCCC",
			"#33CCFF",
			"#6600CC",
			"#6600FF",
			"#6633CC",
			"#6633FF",
			"#66CC00",
			"#66CC33",
			"#9900CC",
			"#9900FF",
			"#9933CC",
			"#9933FF",
			"#99CC00",
			"#99CC33",
			"#CC0000",
			"#CC0033",
			"#CC0066",
			"#CC0099",
			"#CC00CC",
			"#CC00FF",
			"#CC3300",
			"#CC3333",
			"#CC3366",
			"#CC3399",
			"#CC33CC",
			"#CC33FF",
			"#CC6600",
			"#CC6633",
			"#CC9900",
			"#CC9933",
			"#CCCC00",
			"#CCCC33",
			"#FF0000",
			"#FF0033",
			"#FF0066",
			"#FF0099",
			"#FF00CC",
			"#FF00FF",
			"#FF3300",
			"#FF3333",
			"#FF3366",
			"#FF3399",
			"#FF33CC",
			"#FF33FF",
			"#FF6600",
			"#FF6633",
			"#FF9900",
			"#FF9933",
			"#FFCC00",
			"#FFCC33"
		];
		/**
		* Currently only WebKit-based Web Inspectors, Firefox >= v31,
		* and the Firebug extension (any Firefox version) are known
		* to support "%c" CSS customizations.
		*
		* TODO: add a `localStorage` variable to explicitly enable/disable colors
		*/
		function useColors() {
			if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
			if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
			return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
		}
		/**
		* Colorize log arguments if enabled.
		*
		* @api public
		*/
		function formatArgs(args) {
			args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module$1.exports.humanize(this.diff);
			if (!this.useColors) return;
			const c = "color: " + this.color;
			args.splice(1, 0, c, "color: inherit");
			let index$1 = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, (match$1) => {
				if (match$1 === "%%") return;
				index$1++;
				if (match$1 === "%c") lastC = index$1;
			});
			args.splice(lastC, 0, c);
		}
		/**
		* Invokes `console.debug()` when available.
		* No-op when `console.debug` is not a "function".
		* If `console.debug` is not available, falls back
		* to `console.log`.
		*
		* @api public
		*/
		exports$1.log = console.debug || console.log || (() => {});
		/**
		* Save `namespaces`.
		*
		* @param {String} namespaces
		* @api private
		*/
		function save(namespaces) {
			try {
				if (namespaces) exports$1.storage.setItem("debug", namespaces);
else exports$1.storage.removeItem("debug");
			} catch (error) {}
		}
		/**
		* Load `namespaces`.
		*
		* @return {String} returns the previously persisted debug modes
		* @api private
		*/
		function load() {
			let r;
			try {
				r = exports$1.storage.getItem("debug");
			} catch (error) {}
			if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
			return r;
		}
		/**
		* Localstorage attempts to return the localstorage.
		*
		* This is necessary because safari throws
		* when a user disables cookies/localstorage
		* and you attempt to access it.
		*
		* @return {LocalStorage}
		* @api private
		*/
		function localstorage() {
			try {
				return localStorage;
			} catch (error) {}
		}
		module$1.exports = common(exports$1);
		const { formatters } = module$1.exports;
		/**
		* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		*/
		formatters.j = function(v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return "[UnexpectedJSONParseError]: " + error.message;
			}
		};
	});
	/**
	* Module dependencies.
	*/
	var node = createCommonjsModule(function(module$1, exports$1) {
		/**
		* This is the Node.js implementation of `debug()`.
		*/
		exports$1.init = init;
		exports$1.log = log;
		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.destroy = util__default["default"].deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		/**
		* Colors.
		*/
		exports$1.colors = [
			6,
			2,
			3,
			4,
			5,
			1
		];
		try {
			const supportsColor$1 = supportsColor_1;
			if (supportsColor$1 && (supportsColor$1.stderr || supportsColor$1).level >= 2) exports$1.colors = [
				20,
				21,
				26,
				27,
				32,
				33,
				38,
				39,
				40,
				41,
				42,
				43,
				44,
				45,
				56,
				57,
				62,
				63,
				68,
				69,
				74,
				75,
				76,
				77,
				78,
				79,
				80,
				81,
				92,
				93,
				98,
				99,
				112,
				113,
				128,
				129,
				134,
				135,
				148,
				149,
				160,
				161,
				162,
				163,
				164,
				165,
				166,
				167,
				168,
				169,
				170,
				171,
				172,
				173,
				178,
				179,
				184,
				185,
				196,
				197,
				198,
				199,
				200,
				201,
				202,
				203,
				204,
				205,
				206,
				207,
				208,
				209,
				214,
				215,
				220,
				221
			];
		} catch (error) {}
		/**
		* Build up the default `inspectOpts` object from the environment variables.
		*
		*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		*/
		exports$1.inspectOpts = Object.keys(process.env).filter((key) => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
				return k.toUpperCase();
			});
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
else if (val === "null") val = null;
else val = Number(val);
			obj[prop] = val;
			return obj;
		}, {});
		/**
		* Is stdout a TTY? Colored output is enabled when `true`.
		*/
		function useColors() {
			return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty__default["default"].isatty(process.stderr.fd);
		}
		/**
		* Adds ANSI color escape codes if enabled.
		*
		* @api public
		*/
		function formatArgs(args) {
			const { namespace: name, useColors: useColors$1 } = this;
			if (useColors$1) {
				const c = this.color;
				const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;
				args[0] = prefix + args[0].split("\n").join("\n" + prefix);
				args.push(colorCode + "m+" + module$1.exports.humanize(this.diff) + "\x1B[0m");
			} else args[0] = getDate() + name + " " + args[0];
		}
		function getDate() {
			if (exports$1.inspectOpts.hideDate) return "";
			return new Date().toISOString() + " ";
		}
		/**
		* Invokes `util.format()` with the specified arguments and writes to stderr.
		*/
		function log(...args) {
			return process.stderr.write(util__default["default"].format(...args) + "\n");
		}
		/**
		* Save `namespaces`.
		*
		* @param {String} namespaces
		* @api private
		*/
		function save(namespaces) {
			if (namespaces) process.env.DEBUG = namespaces;
else delete process.env.DEBUG;
		}
		/**
		* Load `namespaces`.
		*
		* @return {String} returns the previously persisted debug modes
		* @api private
		*/
		function load() {
			return process.env.DEBUG;
		}
		/**
		* Init logic for `debug` instances.
		*
		* Create a new `inspectOpts` object in case `useColors` is set
		* differently for a particular `debug` instance.
		*/
		function init(debug$3) {
			debug$3.inspectOpts = {};
			const keys = Object.keys(exports$1.inspectOpts);
			for (let i = 0; i < keys.length; i++) debug$3.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
		}
		module$1.exports = common(exports$1);
		const { formatters } = module$1.exports;
		/**
		* Map %o to `util.inspect()`, all on a single line.
		*/
		formatters.o = function(v) {
			this.inspectOpts.colors = this.useColors;
			return util__default["default"].inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
		};
		/**
		* Map %O to `util.inspect()`, allowing multiple lines if needed.
		*/
		formatters.O = function(v) {
			this.inspectOpts.colors = this.useColors;
			return util__default["default"].inspect(v, this.inspectOpts);
		};
	});
	/**
	* Detect Electron renderer / nwjs process, which is node, but we should
	* treat as a browser.
	*/
	var src$1 = createCommonjsModule(function(module$1) {
		if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module$1.exports = browser;
else module$1.exports = node;
	});
	function promisify(fn) {
		return function(req, opts) {
			return new Promise((resolve$2, reject) => {
				fn.call(this, req, opts, (err, rtn) => {
					if (err) reject(err);
else resolve$2(rtn);
				});
			});
		};
	}
	var _default$2 = promisify;
	var promisify_1$1 = /*#__PURE__*/ Object.defineProperty({ default: _default$2 }, "__esModule", { value: true });
	var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	const debug_1$2 = __importDefault$3(src$1);
	const promisify_1 = __importDefault$3(promisify_1$1);
	const debug$2 = debug_1$2.default("agent-base");
	function isAgent(v) {
		return Boolean(v) && typeof v.addRequest === "function";
	}
	function isSecureEndpoint() {
		const { stack } = new Error();
		if (typeof stack !== "string") return false;
		return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
	}
	function createAgent(callback, opts) {
		return new createAgent.Agent(callback, opts);
	}
	(function(createAgent$1) {
		/**
		* Base `http.Agent` implementation.
		* No pooling/keep-alive is implemented by default.
		*
		* @param {Function} callback
		* @api public
		*/
		class Agent extends Events__default["default"].EventEmitter {
			constructor(callback, _opts) {
				super();
				let opts = _opts;
				if (typeof callback === "function") this.callback = callback;
else if (callback) opts = callback;
				this.timeout = null;
				if (opts && typeof opts.timeout === "number") this.timeout = opts.timeout;
				this.maxFreeSockets = 1;
				this.maxSockets = 1;
				this.maxTotalSockets = Infinity;
				this.sockets = {};
				this.freeSockets = {};
				this.requests = {};
				this.options = {};
			}
			get defaultPort() {
				if (typeof this.explicitDefaultPort === "number") return this.explicitDefaultPort;
				return isSecureEndpoint() ? 443 : 80;
			}
			set defaultPort(v) {
				this.explicitDefaultPort = v;
			}
			get protocol() {
				if (typeof this.explicitProtocol === "string") return this.explicitProtocol;
				return isSecureEndpoint() ? "https:" : "http:";
			}
			set protocol(v) {
				this.explicitProtocol = v;
			}
			callback(req, opts, fn) {
				throw new Error("\"agent-base\" has no default implementation, you must subclass and override `callback()`");
			}
			/**
			* Called by node-core's "_http_client.js" module when creating
			* a new HTTP request with this Agent instance.
			*
			* @api public
			*/
			addRequest(req, _opts) {
				const opts = Object.assign({}, _opts);
				if (typeof opts.secureEndpoint !== "boolean") opts.secureEndpoint = isSecureEndpoint();
				if (opts.host == null) opts.host = "localhost";
				if (opts.port == null) opts.port = opts.secureEndpoint ? 443 : 80;
				if (opts.protocol == null) opts.protocol = opts.secureEndpoint ? "https:" : "http:";
				if (opts.host && opts.path) delete opts.path;
				delete opts.agent;
				delete opts.hostname;
				delete opts._defaultAgent;
				delete opts.defaultPort;
				delete opts.createConnection;
				req._last = true;
				req.shouldKeepAlive = false;
				let timedOut = false;
				let timeoutId = null;
				const timeoutMs = opts.timeout || this.timeout;
				const onerror = (err) => {
					if (req._hadError) return;
					req.emit("error", err);
					req._hadError = true;
				};
				const ontimeout = () => {
					timeoutId = null;
					timedOut = true;
					const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
					err.code = "ETIMEOUT";
					onerror(err);
				};
				const callbackError = (err) => {
					if (timedOut) return;
					if (timeoutId !== null) {
						clearTimeout(timeoutId);
						timeoutId = null;
					}
					onerror(err);
				};
				const onsocket = (socket) => {
					if (timedOut) return;
					if (timeoutId != null) {
						clearTimeout(timeoutId);
						timeoutId = null;
					}
					if (isAgent(socket)) {
						debug$2("Callback returned another Agent instance %o", socket.constructor.name);
						socket.addRequest(req, opts);
						return;
					}
					if (socket) {
						socket.once("free", () => {
							this.freeSocket(socket, opts);
						});
						req.onSocket(socket);
						return;
					}
					const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
					onerror(err);
				};
				if (typeof this.callback !== "function") {
					onerror(new Error("`callback` is not defined"));
					return;
				}
				if (!this.promisifiedCallback) if (this.callback.length >= 3) {
					debug$2("Converting legacy callback function to promise");
					this.promisifiedCallback = promisify_1.default(this.callback);
				} else this.promisifiedCallback = this.callback;
				if (typeof timeoutMs === "number" && timeoutMs > 0) timeoutId = setTimeout(ontimeout, timeoutMs);
				if ("port" in opts && typeof opts.port !== "number") opts.port = Number(opts.port);
				try {
					debug$2("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
					Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
				} catch (err) {
					Promise.reject(err).catch(callbackError);
				}
			}
			freeSocket(socket, opts) {
				debug$2("Freeing socket %o %o", socket.constructor.name, opts);
				socket.destroy();
			}
			destroy() {
				debug$2("Destroying agent %o", this.constructor.name);
			}
		}
		createAgent$1.Agent = Agent;
		createAgent$1.prototype = createAgent$1.Agent.prototype;
	})(createAgent || (createAgent = {}));
	var src = createAgent;
	var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	const debug_1$1 = __importDefault$2(src$1);
	const debug$1 = debug_1$1.default("https-proxy-agent:parse-proxy-response");
	function parseProxyResponse(socket) {
		return new Promise((resolve$2, reject) => {
			let buffersLength = 0;
			const buffers = [];
			function read() {
				const b = socket.read();
				if (b) ondata(b);
else socket.once("readable", read);
			}
			function cleanup() {
				socket.removeListener("end", onend);
				socket.removeListener("error", onerror);
				socket.removeListener("close", onclose);
				socket.removeListener("readable", read);
			}
			function onclose(err) {
				debug$1("onclose had error %o", err);
			}
			function onend() {
				debug$1("onend");
			}
			function onerror(err) {
				cleanup();
				debug$1("onerror %o", err);
				reject(err);
			}
			function ondata(b) {
				buffers.push(b);
				buffersLength += b.length;
				const buffered = Buffer.concat(buffers, buffersLength);
				const endOfHeaders = buffered.indexOf("\r\n\r\n");
				if (endOfHeaders === -1) {
					debug$1("have not received end of HTTP headers yet...");
					read();
					return;
				}
				const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
				const statusCode = +firstLine.split(" ")[1];
				debug$1("got proxy server response: %o", firstLine);
				resolve$2({
					statusCode,
					buffered
				});
			}
			socket.on("error", onerror);
			socket.on("close", onclose);
			socket.on("end", onend);
			read();
		});
	}
	var _default$1 = parseProxyResponse;
	var parseProxyResponse_1 = /*#__PURE__*/ Object.defineProperty({ default: _default$1 }, "__esModule", { value: true });
	var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve$2) {
				resolve$2(value);
			});
		}
		return new (P || (P = Promise))(function(resolve$2, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve$2(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	const net_1 = __importDefault$1(require$$0__default$2["default"]);
	const tls_1 = __importDefault$1(require$$1__default["default"]);
	const url_1 = __importDefault$1(require$$2__default["default"]);
	const assert_1 = __importDefault$1(assert__default["default"]);
	const debug_1 = __importDefault$1(src$1);
	const parse_proxy_response_1 = __importDefault$1(parseProxyResponse_1);
	const debug = debug_1.default("https-proxy-agent:agent");
	var HttpsProxyAgent = class extends src.Agent {
		constructor(_opts) {
			let opts;
			if (typeof _opts === "string") opts = url_1.default.parse(_opts);
else opts = _opts;
			if (!opts) throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
			debug("creating new HttpsProxyAgent instance: %o", opts);
			super(opts);
			const proxy = Object.assign({}, opts);
			this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
			proxy.host = proxy.hostname || proxy.host;
			if (typeof proxy.port === "string") proxy.port = parseInt(proxy.port, 10);
			if (!proxy.port && proxy.host) proxy.port = this.secureProxy ? 443 : 80;
			if (this.secureProxy && !("ALPNProtocols" in proxy)) proxy.ALPNProtocols = ["http 1.1"];
			if (proxy.host && proxy.path) {
				delete proxy.path;
				delete proxy.pathname;
			}
			this.proxy = proxy;
		}
		/**
		* Called when the node-core HTTP client library is creating a
		* new HTTP request.
		*
		* @api protected
		*/
		callback(req, opts) {
			return __awaiter(this, void 0, void 0, function* () {
				const { proxy, secureProxy } = this;
				let socket;
				if (secureProxy) {
					debug("Creating `tls.Socket`: %o", proxy);
					socket = tls_1.default.connect(proxy);
				} else {
					debug("Creating `net.Socket`: %o", proxy);
					socket = net_1.default.connect(proxy);
				}
				const headers = Object.assign({}, proxy.headers);
				const hostname = `${opts.host}:${opts.port}`;
				let payload = `CONNECT ${hostname} HTTP/1.1\r\n`;
				if (proxy.auth) headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
				let { host, port, secureEndpoint } = opts;
				if (!isDefaultPort(port, secureEndpoint)) host += `:${port}`;
				headers.Host = host;
				headers.Connection = "close";
				for (const name of Object.keys(headers)) payload += `${name}: ${headers[name]}\r\n`;
				const proxyResponsePromise = parse_proxy_response_1.default(socket);
				socket.write(`${payload}\r\n`);
				const { statusCode, buffered } = yield proxyResponsePromise;
				if (statusCode === 200) {
					req.once("socket", resume);
					if (opts.secureEndpoint) {
						const servername = opts.servername || opts.host;
						if (!servername) throw new Error("Could not determine \"servername\"");
						debug("Upgrading socket connection to TLS");
						return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
							socket,
							servername
						}));
					}
					return socket;
				}
				socket.destroy();
				const fakeSocket = new net_1.default.Socket();
				fakeSocket.readable = true;
				req.once("socket", (s$1) => {
					debug("replaying proxy buffer for failed request");
					assert_1.default(s$1.listenerCount("data") > 0);
					s$1.push(buffered);
					s$1.push(null);
				});
				return fakeSocket;
			});
		}
	};
	var _default = HttpsProxyAgent;
	function resume(socket) {
		socket.resume();
	}
	function isDefaultPort(port, secure) {
		return Boolean(!secure && port === 80 || secure && port === 443);
	}
	function isHTTPS(protocol) {
		return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
	}
	function omit(obj, ...keys) {
		const ret = {};
		let key;
		for (key in obj) if (!keys.includes(key)) ret[key] = obj[key];
		return ret;
	}
	var agent = /*#__PURE__*/ Object.defineProperty({ default: _default }, "__esModule", { value: true });
	var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	const agent_1 = __importDefault(agent);
	function createHttpsProxyAgent(opts) {
		return new agent_1.default(opts);
	}
	(function(createHttpsProxyAgent$1) {
		createHttpsProxyAgent$1.HttpsProxyAgent = agent_1.default;
		createHttpsProxyAgent$1.prototype = agent_1.default.prototype;
	})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
	var dist = createHttpsProxyAgent;
	const tmpDirName = "tmp";
	const degitConfigName = "degit.json";
	var DegitError = class extends Error {
		constructor(message, opts) {
			super(message);
			Object.assign(this, opts);
		}
	};
	function tryRequire(file, opts) {
		try {
			if (opts && opts.clearCache === true) delete require.cache[require.resolve(file)];
			return require(file);
		} catch (err) {
			return null;
		}
	}
	function exec(command) {
		return new Promise((fulfil, reject) => {
			child_process__default["default"].exec(command, (err, stdout$1, stderr) => {
				if (err) {
					reject(err);
					return;
				}
				fulfil({
					stdout: stdout$1,
					stderr
				});
			});
		});
	}
	function mkdirp(dir) {
		const parent = path__default["default"].dirname(dir);
		if (parent === dir) return;
		mkdirp(parent);
		try {
			fs__default["default"].mkdirSync(dir);
		} catch (err) {
			if (err.code !== "EEXIST") throw err;
		}
	}
	function fetch(url, dest, proxy) {
		return new Promise((fulfil, reject) => {
			let options = url;
			if (proxy) {
				const parsedUrl = require$$2__default["default"].parse(url);
				options = {
					hostname: parsedUrl.host,
					path: parsedUrl.path,
					agent: new dist(proxy)
				};
			}
			https__default["default"].get(options, (response) => {
				const code = response.statusCode;
				if (code >= 400) reject({
					code,
					message: response.statusMessage
				});
else if (code >= 300) fetch(response.headers.location, dest, proxy).then(fulfil, reject);
else response.pipe(fs__default["default"].createWriteStream(dest)).on("finish", () => fulfil()).on("error", reject);
			}).on("error", reject);
		});
	}
	function stashFiles(dir, dest) {
		const tmpDir = path__default["default"].join(dir, tmpDirName);
		rimrafSync_1(tmpDir);
		mkdirp(tmpDir);
		fs__default["default"].readdirSync(dest).forEach((file) => {
			const filePath = path__default["default"].join(dest, file);
			const targetPath = path__default["default"].join(tmpDir, file);
			const isDir = fs__default["default"].lstatSync(filePath).isDirectory();
			if (isDir) {
				copydirSync_1(filePath).to(targetPath);
				rimrafSync_1(filePath);
			} else {
				fs__default["default"].copyFileSync(filePath, targetPath);
				fs__default["default"].unlinkSync(filePath);
			}
		});
	}
	function unstashFiles(dir, dest) {
		const tmpDir = path__default["default"].join(dir, tmpDirName);
		fs__default["default"].readdirSync(tmpDir).forEach((filename) => {
			const tmpFile = path__default["default"].join(tmpDir, filename);
			const targetPath = path__default["default"].join(dest, filename);
			const isDir = fs__default["default"].lstatSync(tmpFile).isDirectory();
			if (isDir) {
				copydirSync_1(tmpFile).to(targetPath);
				rimrafSync_1(tmpFile);
			} else {
				if (filename !== "degit.json") fs__default["default"].copyFileSync(tmpFile, targetPath);
				fs__default["default"].unlinkSync(tmpFile);
			}
		});
		rimrafSync_1(tmpDir);
	}
	const base = path__default["default"].join(homeOrTmp, ".degit");
	const validModes = new Set(["tar", "git"]);
	function degit$1(src$2, opts) {
		return new Degit(src$2, opts);
	}
	var Degit = class extends Events__default["default"] {
		constructor(src$2, opts = {}) {
			super();
			this.src = src$2;
			this.cache = opts.cache;
			this.force = opts.force;
			this.verbose = opts.verbose;
			this.proxy = process.env.https_proxy;
			this.repo = parse(src$2);
			this.mode = opts.mode || this.repo.mode;
			if (!validModes.has(this.mode)) throw new Error(`Valid modes are ${Array.from(validModes).join(", ")}`);
			this._hasStashed = false;
			this.directiveActions = {
				clone: async (dir, dest, action) => {
					if (this._hasStashed === false) {
						stashFiles(dir, dest);
						this._hasStashed = true;
					}
					const opts$1 = Object.assign({ force: true }, {
						cache: action.cache,
						verbose: action.verbose
					});
					const d$1 = degit$1(action.src, opts$1);
					d$1.on("info", (event) => {
						console.error(source.cyan(`> ${event.message.replace("options.", "--")}`));
					});
					d$1.on("warn", (event) => {
						console.error(source.magenta(`! ${event.message.replace("options.", "--")}`));
					});
					await d$1.clone(dest).catch((err) => {
						console.error(source.red(`! ${err.message}`));
						process.exit(1);
					});
				},
				remove: this.remove.bind(this)
			};
		}
		_getDirectives(dest) {
			const directivesPath = path__default["default"].resolve(dest, degitConfigName);
			const directives = tryRequire(directivesPath, { clearCache: true }) || false;
			if (directives) fs__default["default"].unlinkSync(directivesPath);
			return directives;
		}
		async clone(dest) {
			this._checkDirIsEmpty(dest);
			const { repo } = this;
			const dir = path__default["default"].join(base, repo.site, repo.user, repo.name);
			if (this.mode === "tar") await this._cloneWithTar(dir, dest);
else await this._cloneWithGit(dir, dest);
			this._info({
				code: "SUCCESS",
				message: `cloned ${source.bold(repo.user + "/" + repo.name)}#${source.bold(repo.ref)}${dest !== "." ? ` to ${dest}` : ""}`,
				repo,
				dest
			});
			const directives = this._getDirectives(dest);
			if (directives) {
				for (const d$1 of directives) await this.directiveActions[d$1.action](dir, dest, d$1);
				if (this._hasStashed === true) unstashFiles(dir, dest);
			}
		}
		remove(dir, dest, action) {
			let files = action.files;
			if (!Array.isArray(files)) files = [files];
			const removedFiles = files.map((file) => {
				const filePath = path__default["default"].resolve(dest, file);
				if (fs__default["default"].existsSync(filePath)) {
					const isDir = fs__default["default"].lstatSync(filePath).isDirectory();
					if (isDir) {
						rimrafSync_1(filePath);
						return file + "/";
					} else {
						fs__default["default"].unlinkSync(filePath);
						return file;
					}
				} else {
					this._warn({
						code: "FILE_DOES_NOT_EXIST",
						message: `action wants to remove ${source.bold(file)} but it does not exist`
					});
					return null;
				}
			}).filter((d$1) => d$1);
			if (removedFiles.length > 0) this._info({
				code: "REMOVED",
				message: `removed: ${source.bold(removedFiles.map((d$1) => source.bold(d$1)).join(", "))}`
			});
		}
		_checkDirIsEmpty(dir) {
			try {
				const files = fs__default["default"].readdirSync(dir);
				if (files.length > 0) if (this.force) this._info({
					code: "DEST_NOT_EMPTY",
					message: `destination directory is not empty. Using options.force, continuing`
				});
else throw new DegitError(`destination directory is not empty, aborting. Use options.force to override`, { code: "DEST_NOT_EMPTY" });
else this._verbose({
					code: "DEST_IS_EMPTY",
					message: `destination directory is empty`
				});
			} catch (err) {
				if (err.code !== "ENOENT") throw err;
			}
		}
		_info(info) {
			this.emit("info", info);
		}
		_warn(info) {
			this.emit("warn", info);
		}
		_verbose(info) {
			if (this.verbose) this._info(info);
		}
		async _getHash(repo, cached) {
			try {
				const refs = await fetchRefs(repo);
				if (repo.ref === "HEAD") return refs.find((ref) => ref.type === "HEAD").hash;
				return this._selectRef(refs, repo.ref);
			} catch (err) {
				this._warn(err);
				this._verbose(err.original);
				return this._getHashFromCache(repo, cached);
			}
		}
		_getHashFromCache(repo, cached) {
			if (repo.ref in cached) {
				const hash = cached[repo.ref];
				this._info({
					code: "USING_CACHE",
					message: `using cached commit hash ${hash}`
				});
				return hash;
			}
		}
		_selectRef(refs, selector) {
			for (const ref of refs) if (ref.name === selector) {
				this._verbose({
					code: "FOUND_MATCH",
					message: `found matching commit hash: ${ref.hash}`
				});
				return ref.hash;
			}
			if (selector.length < 8) return null;
			for (const ref of refs) if (ref.hash.startsWith(selector)) return ref.hash;
		}
		async _cloneWithTar(dir, dest) {
			const { repo } = this;
			const cached = tryRequire(path__default["default"].join(dir, "map.json")) || {};
			const hash = this.cache ? this._getHashFromCache(repo, cached) : await this._getHash(repo, cached);
			const subdir = repo.subdir ? `${repo.name}-${hash}${repo.subdir}` : null;
			if (!hash) throw new DegitError(`could not find commit hash for ${repo.ref}`, {
				code: "MISSING_REF",
				ref: repo.ref
			});
			const file = `${dir}/${hash}.tar.gz`;
			const url = repo.site === "gitlab" ? `${repo.url}/repository/archive.tar.gz?ref=${hash}` : repo.site === "bitbucket" ? `${repo.url}/get/${hash}.tar.gz` : `${repo.url}/archive/${hash}.tar.gz`;
			try {
				if (!this.cache) try {
					fs__default["default"].statSync(file);
					this._verbose({
						code: "FILE_EXISTS",
						message: `${file} already exists locally`
					});
				} catch (err) {
					mkdirp(path__default["default"].dirname(file));
					if (this.proxy) this._verbose({
						code: "PROXY",
						message: `using proxy ${this.proxy}`
					});
					this._verbose({
						code: "DOWNLOADING",
						message: `downloading ${url} to ${file}`
					});
					await fetch(url, file, this.proxy);
				}
			} catch (err) {
				throw new DegitError(`could not download ${url}`, {
					code: "COULD_NOT_DOWNLOAD",
					url,
					original: err
				});
			}
			updateCache(dir, repo, hash, cached);
			this._verbose({
				code: "EXTRACTING",
				message: `extracting ${subdir ? repo.subdir + " from " : ""}${file} to ${dest}`
			});
			mkdirp(dest);
			await untar(file, dest, subdir);
		}
		async _cloneWithGit(dir, dest) {
			await exec(`git clone ${this.repo.ssh} ${dest}`);
			await exec(`rm -rf ${path__default["default"].resolve(dest, ".git")}`);
		}
	};
	const supported = new Set([
		"github",
		"gitlab",
		"bitbucket",
		"git.sr.ht"
	]);
	function parse(src$2) {
		const match$1 = /^(?:(?:https:\/\/)?([^:/]+\.[^:/]+)\/|git@([^:/]+)[:/]|([^/]+):)?([^/\s]+)\/([^/\s#]+)(?:((?:\/[^/\s#]+)+))?(?:\/)?(?:#(.+))?/.exec(src$2);
		if (!match$1) throw new DegitError(`could not parse ${src$2}`, { code: "BAD_SRC" });
		const site = (match$1[1] || match$1[2] || match$1[3] || "github").replace(/\.(com|org)$/, "");
		if (!supported.has(site)) throw new DegitError(`degit supports GitHub, GitLab, Sourcehut and BitBucket`, { code: "UNSUPPORTED_HOST" });
		const user = match$1[4];
		const name = match$1[5].replace(/\.git$/, "");
		const subdir = match$1[6];
		const ref = match$1[7] || "HEAD";
		const domain = `${site}.${site === "bitbucket" ? "org" : site === "git.sr.ht" ? "" : "com"}`;
		const url = `https://${domain}/${user}/${name}`;
		const ssh = `git@${domain}:${user}/${name}`;
		const mode = supported.has(site) ? "tar" : "git";
		return {
			site,
			user,
			name,
			ref,
			url,
			ssh,
			subdir,
			mode
		};
	}
	async function untar(file, dest, subdir = null) {
		return tar.extract({
			file,
			strip: subdir ? subdir.split("/").length : 1,
			C: dest
		}, subdir ? [subdir] : []);
	}
	async function fetchRefs(repo) {
		try {
			const { stdout: stdout$1 } = await exec(`git ls-remote ${repo.url}`);
			return stdout$1.split("\n").filter(Boolean).map((row) => {
				const [hash, ref] = row.split("	");
				if (ref === "HEAD") return {
					type: "HEAD",
					hash
				};
				const match$1 = /refs\/(\w+)\/(.+)/.exec(ref);
				if (!match$1) throw new DegitError(`could not parse ${ref}`, { code: "BAD_REF" });
				return {
					type: match$1[1] === "heads" ? "branch" : match$1[1] === "refs" ? "ref" : match$1[1],
					name: match$1[2],
					hash
				};
			});
		} catch (error) {
			throw new DegitError(`could not fetch remote ${repo.url}`, {
				code: "COULD_NOT_FETCH",
				url: repo.url,
				original: error
			});
		}
	}
	function updateCache(dir, repo, hash, cached) {
		const logs = tryRequire(path__default["default"].join(dir, "access.json")) || {};
		logs[repo.ref] = new Date().toISOString();
		fs__default["default"].writeFileSync(path__default["default"].join(dir, "access.json"), JSON.stringify(logs, null, "  "));
		if (cached[repo.ref] === hash) return;
		const oldHash = cached[repo.ref];
		if (oldHash) {
			let used = false;
			for (const key in cached) if (cached[key] === hash) {
				used = true;
				break;
			}
			if (!used) try {
				fs__default["default"].unlinkSync(path__default["default"].join(dir, `${oldHash}.tar.gz`));
			} catch (err) {}
		}
		cached[repo.ref] = hash;
		fs__default["default"].writeFileSync(path__default["default"].join(dir, "map.json"), JSON.stringify(cached, null, "  "));
	}
	exports.base = base;
	exports.createCommonjsModule = createCommonjsModule;
	exports.degit = degit$1;
	exports.source = source;
	exports.tryRequire = tryRequire;
} });

//#endregion
//#region node_modules/.pnpm/degit@2.8.4/node_modules/degit/dist/index.js
var require_dist = __commonJS({ "node_modules/.pnpm/degit@2.8.4/node_modules/degit/dist/index.js"(exports, module) {
	__require("fs");
	__require("path");
	var index = require_index_688c5d50();
	__require("events");
	__require("stream");
	__require("string_decoder");
	__require("assert");
	__require("buffer");
	__require("zlib");
	__require("util");
	__require("crypto");
	__require("os");
	__require("tty");
	__require("constants");
	__require("https");
	__require("child_process");
	__require("url");
	__require("net");
	__require("tls");
	module.exports = index.degit;
} });

//#endregion
//#region node_modules/.pnpm/through@2.3.8/node_modules/through/index.js
var require_through = __commonJS({ "node_modules/.pnpm/through@2.3.8/node_modules/through/index.js"(exports, module) {
	var Stream$4 = __require("stream");
	exports = module.exports = through$2;
	through$2.through = through$2;
	function through$2(write, end, opts) {
		write = write || function(data) {
			this.queue(data);
		};
		end = end || function() {
			this.queue(null);
		};
		var ended = false, destroyed = false, buffer = [], _ended$1 = false;
		var stream = new Stream$4();
		stream.readable = stream.writable = true;
		stream.paused = false;
		stream.autoDestroy = !(opts && opts.autoDestroy === false);
		stream.write = function(data) {
			write.call(this, data);
			return !stream.paused;
		};
		function drain() {
			while (buffer.length && !stream.paused) {
				var data = buffer.shift();
				if (null === data) return stream.emit("end");
else stream.emit("data", data);
			}
		}
		stream.queue = stream.push = function(data) {
			if (_ended$1) return stream;
			if (data === null) _ended$1 = true;
			buffer.push(data);
			drain();
			return stream;
		};
		stream.on("end", function() {
			stream.readable = false;
			if (!stream.writable && stream.autoDestroy) process.nextTick(function() {
				stream.destroy();
			});
		});
		function _end() {
			stream.writable = false;
			end.call(stream);
			if (!stream.readable && stream.autoDestroy) stream.destroy();
		}
		stream.end = function(data) {
			if (ended) return;
			ended = true;
			if (arguments.length) stream.write(data);
			_end();
			return stream;
		};
		stream.destroy = function() {
			if (destroyed) return;
			destroyed = true;
			ended = true;
			buffer.length = 0;
			stream.writable = stream.readable = false;
			stream.emit("close");
			return stream;
		};
		stream.pause = function() {
			if (stream.paused) return;
			stream.paused = true;
			return stream;
		};
		stream.resume = function() {
			if (stream.paused) {
				stream.paused = false;
				stream.emit("resume");
			}
			drain();
			if (!stream.paused) stream.emit("drain");
			return stream;
		};
		return stream;
	}
} });

//#endregion
//#region node_modules/.pnpm/from@0.1.7/node_modules/from/index.js
var require_from = __commonJS({ "node_modules/.pnpm/from@0.1.7/node_modules/from/index.js"(exports, module) {
	var Stream$3 = __require("stream");
	module.exports = function from$1(source$1) {
		if (Array.isArray(source$1)) {
			var source_index = 0, source_len = source$1.length;
			return from$1(function(i$1) {
				if (source_index < source_len) this.emit("data", source$1[source_index++]);
else this.emit("end");
				return true;
			});
		}
		var s$1 = new Stream$3(), i = 0;
		s$1.ended = false;
		s$1.started = false;
		s$1.readable = true;
		s$1.writable = false;
		s$1.paused = false;
		s$1.ended = false;
		s$1.pause = function() {
			s$1.started = true;
			s$1.paused = true;
		};
		function next() {
			s$1.started = true;
			if (s$1.ended) return;
			while (!s$1.ended && !s$1.paused && source$1.call(s$1, i++, function() {
				if (!s$1.ended && !s$1.paused) process.nextTick(next);
			}));
		}
		s$1.resume = function() {
			s$1.started = true;
			s$1.paused = false;
			next();
		};
		s$1.on("end", function() {
			s$1.ended = true;
			s$1.readable = false;
			process.nextTick(s$1.destroy);
		});
		s$1.destroy = function() {
			s$1.ended = true;
			s$1.emit("close");
		};
		process.nextTick(function() {
			if (!s$1.started) s$1.resume();
		});
		return s$1;
	};
} });

//#endregion
//#region node_modules/.pnpm/duplexer@0.1.2/node_modules/duplexer/index.js
var require_duplexer = __commonJS({ "node_modules/.pnpm/duplexer@0.1.2/node_modules/duplexer/index.js"(exports, module) {
	var Stream$2 = __require("stream");
	var writeMethods = [
		"write",
		"end",
		"destroy"
	];
	var readMethods = ["resume", "pause"];
	var readEvents = ["data", "close"];
	var slice = Array.prototype.slice;
	module.exports = duplex$1;
	function forEach(arr, fn) {
		if (arr.forEach) return arr.forEach(fn);
		for (var i = 0; i < arr.length; i++) fn(arr[i], i);
	}
	function duplex$1(writer, reader) {
		var stream = new Stream$2();
		var ended = false;
		forEach(writeMethods, proxyWriter);
		forEach(readMethods, proxyReader);
		forEach(readEvents, proxyStream);
		reader.on("end", handleEnd);
		writer.on("drain", function() {
			stream.emit("drain");
		});
		writer.on("error", reemit);
		reader.on("error", reemit);
		stream.writable = writer.writable;
		stream.readable = reader.readable;
		return stream;
		function proxyWriter(methodName) {
			stream[methodName] = method;
			function method() {
				return writer[methodName].apply(writer, arguments);
			}
		}
		function proxyReader(methodName) {
			stream[methodName] = method;
			function method() {
				stream.emit(methodName);
				var func = reader[methodName];
				if (func) return func.apply(reader, arguments);
				reader.emit(methodName);
			}
		}
		function proxyStream(methodName) {
			reader.on(methodName, reemit$1);
			function reemit$1() {
				var args = slice.call(arguments);
				args.unshift(methodName);
				stream.emit.apply(stream, args);
			}
		}
		function handleEnd() {
			if (ended) return;
			ended = true;
			var args = slice.call(arguments);
			args.unshift("end");
			stream.emit.apply(stream, args);
		}
		function reemit(err) {
			stream.emit("error", err);
		}
	}
} });

//#endregion
//#region node_modules/.pnpm/map-stream@0.1.0/node_modules/map-stream/index.js
var require_map_stream = __commonJS({ "node_modules/.pnpm/map-stream@0.1.0/node_modules/map-stream/index.js"(exports, module) {
	var Stream$1 = __require("stream").Stream;
	module.exports = function(mapper, opts) {
		var stream = new Stream$1(), self$1 = this, inputs = 0, outputs = 0, ended = false, paused = false, destroyed = false, lastWritten = 0, inNext = false;
		this.opts = opts || {};
		var errorEventName = this.opts.failures ? "failure" : "error";
		var writeQueue = {};
		stream.writable = true;
		stream.readable = true;
		function queueData(data, number) {
			var nextToWrite = lastWritten + 1;
			if (number === nextToWrite) {
				if (data !== undefined) stream.emit.apply(stream, ["data", data]);
				lastWritten++;
				nextToWrite++;
			} else writeQueue[number] = data;
			if (writeQueue.hasOwnProperty(nextToWrite)) {
				var dataToWrite = writeQueue[nextToWrite];
				delete writeQueue[nextToWrite];
				return queueData(dataToWrite, nextToWrite);
			}
			outputs++;
			if (inputs === outputs) {
				if (paused) paused = false, stream.emit("drain");
				if (ended) end();
			}
		}
		function next(err, data, number) {
			if (destroyed) return;
			inNext = true;
			if (!err || self$1.opts.failures) queueData(data, number);
			if (err) stream.emit.apply(stream, [errorEventName, err]);
			inNext = false;
		}
		function wrappedMapper(input, number, callback) {
			return mapper.call(null, input, function(err, data) {
				callback(err, data, number);
			});
		}
		stream.write = function(data) {
			if (ended) throw new Error("map stream is not writable");
			inNext = false;
			inputs++;
			try {
				var written = wrappedMapper(data, inputs, next);
				paused = written === false;
				return !paused;
			} catch (err) {
				if (inNext) throw err;
				next(err);
				return !paused;
			}
		};
		function end(data) {
			ended = true;
			stream.writable = false;
			if (data !== undefined) return queueData(data, inputs);
else if (inputs == outputs) stream.readable = false, stream.emit("end"), stream.destroy();
		}
		stream.end = function(data) {
			if (ended) return;
			end();
		};
		stream.destroy = function() {
			ended = destroyed = true;
			stream.writable = stream.readable = paused = false;
			process.nextTick(function() {
				stream.emit("close");
			});
		};
		stream.pause = function() {
			paused = true;
		};
		stream.resume = function() {
			paused = false;
		};
		return stream;
	};
} });

//#endregion
//#region node_modules/.pnpm/pause-stream@0.0.11/node_modules/pause-stream/index.js
var require_pause_stream = __commonJS({ "node_modules/.pnpm/pause-stream@0.0.11/node_modules/pause-stream/index.js"(exports, module) {
	module.exports = require_through();
} });

//#endregion
//#region node_modules/.pnpm/split@0.3.3/node_modules/split/index.js
var require_split = __commonJS({ "node_modules/.pnpm/split@0.3.3/node_modules/split/index.js"(exports, module) {
	var through$1 = require_through();
	var Decoder = __require("string_decoder").StringDecoder;
	module.exports = split$1;
	function split$1(matcher, mapper, options) {
		var decoder = new Decoder();
		var soFar = "";
		var maxLength = options && options.maxLength;
		if ("function" === typeof matcher) mapper = matcher, matcher = null;
		if (!matcher) matcher = /\r?\n/;
		function emit(stream, piece) {
			if (mapper) {
				try {
					piece = mapper(piece);
				} catch (err) {
					return stream.emit("error", err);
				}
				if ("undefined" !== typeof piece) stream.queue(piece);
			} else stream.queue(piece);
		}
		function next(stream, buffer) {
			var pieces = ((soFar != null ? soFar : "") + buffer).split(matcher);
			soFar = pieces.pop();
			if (maxLength && soFar.length > maxLength) stream.emit("error", new Error("maximum buffer reached"));
			for (var i = 0; i < pieces.length; i++) {
				var piece = pieces[i];
				emit(stream, piece);
			}
		}
		return through$1(function(b) {
			next(this, decoder.write(b));
		}, function() {
			if (decoder.end) next(this, decoder.end());
			if (soFar != null) emit(this, soFar);
			this.queue(null);
		});
	}
} });

//#endregion
//#region node_modules/.pnpm/stream-combiner@0.0.4/node_modules/stream-combiner/index.js
var require_stream_combiner = __commonJS({ "node_modules/.pnpm/stream-combiner@0.0.4/node_modules/stream-combiner/index.js"(exports, module) {
	var duplexer = require_duplexer();
	module.exports = function() {
		var streams = [].slice.call(arguments), first = streams[0], last = streams[streams.length - 1], thepipe = duplexer(first, last);
		if (streams.length == 1) return streams[0];
else if (!streams.length) throw new Error("connect called with empty args");
		function recurse(streams$1) {
			if (streams$1.length < 2) return;
			streams$1[0].pipe(streams$1[1]);
			recurse(streams$1.slice(1));
		}
		recurse(streams);
		function onerror() {
			var args = [].slice.call(arguments);
			args.unshift("error");
			thepipe.emit.apply(thepipe, args);
		}
		for (var i = 1; i < streams.length - 1; i++) streams[i].on("error", onerror);
		return thepipe;
	};
} });

//#endregion
//#region node_modules/.pnpm/event-stream@3.3.4/node_modules/event-stream/index.js
var require_event_stream = __commonJS({ "node_modules/.pnpm/event-stream@3.3.4/node_modules/event-stream/index.js"(exports) {
	var Stream = __require("stream").Stream, es$1 = exports, through = require_through(), from = require_from(), duplex = require_duplexer(), map = require_map_stream(), pause = require_pause_stream(), split = require_split(), pipeline = require_stream_combiner(), immediately = global.setImmediate || process.nextTick;
	es$1.Stream = Stream;
	es$1.through = through;
	es$1.from = from;
	es$1.duplex = duplex;
	es$1.map = map;
	es$1.pause = pause;
	es$1.split = split;
	es$1.pipeline = es$1.connect = es$1.pipe = pipeline;
	es$1.concat = es$1.merge = function() {
		var toMerge = [].slice.call(arguments);
		if (toMerge.length === 1 && toMerge[0] instanceof Array) toMerge = toMerge[0];
		var stream = new Stream();
		stream.setMaxListeners(0);
		var endCount = 0;
		stream.writable = stream.readable = true;
		if (toMerge.length) toMerge.forEach(function(e) {
			e.pipe(stream, { end: false });
			var ended = false;
			e.on("end", function() {
				if (ended) return;
				ended = true;
				endCount++;
				if (endCount == toMerge.length) stream.emit("end");
			});
		});
else process.nextTick(function() {
			stream.emit("end");
		});
		stream.write = function(data) {
			this.emit("data", data);
		};
		stream.destroy = function() {
			toMerge.forEach(function(e) {
				if (e.destroy) e.destroy();
			});
		};
		return stream;
	};
	es$1.writeArray = function(done) {
		if ("function" !== typeof done) throw new Error("function writeArray (done): done must be function");
		var a = new Stream(), array = [], isDone = false;
		a.write = function(l) {
			array.push(l);
		};
		a.end = function() {
			isDone = true;
			done(null, array);
		};
		a.writable = true;
		a.readable = false;
		a.destroy = function() {
			a.writable = a.readable = false;
			if (isDone) return;
			done(new Error("destroyed before end"), array);
		};
		return a;
	};
	es$1.readArray = function(array) {
		var stream = new Stream(), i = 0, paused = false, ended = false;
		stream.readable = true;
		stream.writable = false;
		if (!Array.isArray(array)) throw new Error("event-stream.read expects an array");
		stream.resume = function() {
			if (ended) return;
			paused = false;
			var l = array.length;
			while (i < l && !paused && !ended) stream.emit("data", array[i++]);
			if (i == l && !ended) ended = true, stream.readable = false, stream.emit("end");
		};
		process.nextTick(stream.resume);
		stream.pause = function() {
			paused = true;
		};
		stream.destroy = function() {
			ended = true;
			stream.emit("close");
		};
		return stream;
	};
	es$1.readable = function(func, continueOnError) {
		var stream = new Stream(), i = 0, paused = false, ended = false, reading = false;
		stream.readable = true;
		stream.writable = false;
		if ("function" !== typeof func) throw new Error("event-stream.readable expects async function");
		stream.on("end", function() {
			ended = true;
		});
		function get(err, data) {
			if (err) {
				stream.emit("error", err);
				if (!continueOnError) stream.emit("end");
			} else if (arguments.length > 1) stream.emit("data", data);
			immediately(function() {
				if (ended || paused || reading) return;
				try {
					reading = true;
					func.call(stream, i++, function() {
						reading = false;
						get.apply(null, arguments);
					});
				} catch (err$1) {
					stream.emit("error", err$1);
				}
			});
		}
		stream.resume = function() {
			paused = false;
			get();
		};
		process.nextTick(get);
		stream.pause = function() {
			paused = true;
		};
		stream.destroy = function() {
			stream.emit("end");
			stream.emit("close");
			ended = true;
		};
		return stream;
	};
	es$1.mapSync = function(sync$2) {
		return es$1.through(function write(data) {
			var mappedData;
			try {
				mappedData = sync$2(data);
			} catch (err) {
				return this.emit("error", err);
			}
			if (mappedData !== undefined) this.emit("data", mappedData);
		});
	};
	es$1.log = function(name) {
		return es$1.through(function(data) {
			var args = [].slice.call(arguments);
			if (name) console.error(name, data);
else console.error(data);
			this.emit("data", data);
		});
	};
	es$1.child = function(child) {
		return es$1.duplex(child.stdin, child.stdout);
	};
	es$1.parse = function(options) {
		var emitError = !!(options ? options.error : false);
		return es$1.through(function(data) {
			var obj;
			try {
				if (data) obj = JSON.parse(data.toString());
			} catch (err) {
				if (emitError) return this.emit("error", err);
				return console.error(err, "attempting to parse:", data);
			}
			if (obj !== undefined) this.emit("data", obj);
		});
	};
	es$1.stringify = function() {
		var Buffer$1 = __require("buffer").Buffer;
		return es$1.mapSync(function(e) {
			return JSON.stringify(Buffer$1.isBuffer(e) ? e.toString() : e) + "\n";
		});
	};
	es$1.replace = function(from$1, to) {
		return es$1.pipeline(es$1.split(from$1), es$1.join(to));
	};
	es$1.join = function(str) {
		if ("function" === typeof str) return es$1.wait(str);
		var first = true;
		return es$1.through(function(data) {
			if (!first) this.emit("data", str);
			first = false;
			this.emit("data", data);
			return true;
		});
	};
	es$1.wait = function(callback) {
		var arr = [];
		return es$1.through(function(data) {
			arr.push(data);
		}, function() {
			var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr) : arr.join("");
			this.emit("data", body);
			this.emit("end");
			if (callback) callback(null, body);
		});
	};
	es$1.pipeable = function() {
		throw new Error("[EVENT-STREAM] es.pipeable is deprecated");
	};
} });

//#endregion
//#region node_modules/.pnpm/ps-tree@1.2.0/node_modules/ps-tree/index.js
var require_ps_tree = __commonJS({ "node_modules/.pnpm/ps-tree@1.2.0/node_modules/ps-tree/index.js"(exports, module) {
	var spawn = __require("child_process").spawn, es = require_event_stream();
	module.exports = function childrenOfPid(pid, callback) {
		var headers = null;
		if (typeof callback !== "function") throw new Error("childrenOfPid(pid, callback) expects callback");
		if (typeof pid === "number") pid = pid.toString();
		var processLister;
		if (process.platform === "win32") processLister = spawn("wmic.exe", [
			"PROCESS",
			"GET",
			"Name,ProcessId,ParentProcessId,Status"
		]);
else processLister = spawn("ps", [
			"-A",
			"-o",
			"ppid,pid,stat,comm"
		]);
		es.connect(
			// spawn('ps', ['-A', '-o', 'ppid,pid,stat,comm']).stdout,
			processLister.stdout,
			es.split(),
			es.map(function(line, cb) {
				var columns = line.trim().split(/\s+/);
				if (!headers) {
					headers = columns;
					headers = headers.map(normalizeHeader);
					return cb();
				}
				var row = {};
				var h$1 = headers.slice();
				while (h$1.length) row[h$1.shift()] = h$1.length ? columns.shift() : columns.join(" ");
				return cb(null, row);
			}),
			es.writeArray(function(err, ps) {
				var parents = {}, children = [];
				parents[pid] = true;
				ps.forEach(function(proc) {
					if (parents[proc.PPID]) {
						parents[proc.PID] = true;
						children.push(proc);
					}
				});
				callback(null, children);
			})
).on("error", callback);
	};
	/**
	* Normalizes the given header `str` from the Windows
	* title to the *nix title.
	*
	* @param {string} str Header string to normalize
	*/
	function normalizeHeader(str) {
		if (process.platform !== "win32") return str;
		switch (str) {
			case "Name": return "COMMAND";
			case "ParentProcessId": return "PPID";
			case "ProcessId": return "PID";
			case "Status": return "STAT";
			default: throw new Error("Unknown process listing header: " + str);
		}
	}
} });

//#endregion
//#region packages/cli/lib/testing.ts
var import_dist = __toESM(require_dist(), 1);
var import_ps_tree = __toESM(require_ps_tree(), 1);
const TEMPLATES_DIR = ".templates";
async function setup({ cwd: cwd$1, clean = false, variants }) {
	const workingDir = path.resolve(cwd$1);
	if (clean && fs.existsSync(workingDir)) fs.rmSync(workingDir, {
		force: true,
		recursive: true
	});
	const templatesDir = path.resolve(workingDir, TEMPLATES_DIR);
	fs.mkdirSync(templatesDir, { recursive: true });
	for (const variant of variants) {
		const templatePath = path.resolve(templatesDir, variant);
		if (fs.existsSync(templatePath)) continue;
		if (variant === "kit-js") create(templatePath, {
			name: variant,
			template: "minimal",
			types: "checkjs"
		});
else if (variant === "kit-ts") create(templatePath, {
			name: variant,
			template: "minimal",
			types: "typescript"
		});
else if (variant === "vite-js" || variant === "vite-ts") {
			const name = `template-svelte${variant === "vite-ts" ? "-ts" : ""}`;
			const template$1 = (0, import_dist.default)(`vitejs/vite/packages/create-vite/${name}`, { force: true });
			await template$1.clone(templatePath);
			const gitignorePath = path.resolve(templatePath, "_gitignore");
			if (fs.existsSync(gitignorePath)) {
				const fixedPath = path.resolve(templatePath, ".gitignore");
				fs.renameSync(gitignorePath, fixedPath);
			}
		} else throw new Error(`Unknown project variant: ${variant}`);
	}
	return { templatesDir };
}
function createProject({ cwd: cwd$1, testName, templatesDir }) {
	const testDir = path.resolve(cwd$1, testName);
	fs.mkdirSync(testDir, { recursive: true });
	return ({ testId, variant, clean = true }) => {
		const targetDir = path.resolve(testDir, testId);
		if (clean && fs.existsSync(targetDir)) fs.rmSync(targetDir, {
			force: true,
			recursive: true
		});
		const templatePath = path.resolve(templatesDir, variant);
		fs.cpSync(templatePath, targetDir, {
			recursive: true,
			force: true
		});
		return targetDir;
	};
}
async function startPreview({ cwd: cwd$1, command = "npm run preview" }) {
	const [cmd, ...args] = command.split(" ");
	const proc = be(cmd, args, {
		nodeOptions: {
			cwd: cwd$1,
			stdio: "pipe"
		},
		throwOnError: true,
		timeout: 6e4
	});
	const close = async () => {
		if (!proc.pid) return;
		await terminate(proc.pid);
	};
	return await new Promise((resolve$2, reject) => {
		if (!proc.process?.stdout) return reject("impossible state");
		proc.process.stdout.on("data", (data) => {
			const value = data.toString();
			const regexUnicode = /[^\x20-\xaf]+/g;
			const withoutUnicode = value.replace(regexUnicode, "");
			const regexUnicodeDigits = /\[[0-9]{1,2}m/g;
			const withoutColors = withoutUnicode.replace(regexUnicodeDigits, "");
			const regexUrl = /http:\/\/[^:\s]+:[0-9]+\//g;
			const urls = withoutColors.match(regexUrl);
			if (urls && urls.length > 0) {
				const url = urls[0];
				resolve$2({
					url,
					close
				});
			}
		});
	});
}
async function getProcessTree(pid) {
	return new Promise((res, rej) => {
		(0, import_ps_tree.default)(pid, (err, children) => {
			if (err) rej(err);
			res(children);
		});
	});
}
async function terminate(pid) {
	const children = await getProcessTree(pid);
	for (let i = children.length - 1; i >= 0; i--) {
		const child = children[i];
		const pid$1 = Number(child.PID);
		kill(pid$1);
	}
	kill(pid);
}
function kill(pid) {
	try {
		process$1.kill(pid);
	} catch {}
}

//#endregion
export { addPnpmBuildDependencies, createProject, setup, startPreview };