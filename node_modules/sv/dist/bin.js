#!/usr/bin/env node
import { AGENT_NAMES, Command, Element, Option, Tag, __commonJS, __export, __require, __toESM as __toESM$1, __toESM$1 as __toESM, addPnpmBuildDependencies, box, cancel, confirm, create, detect, esm_exports, from, getUserAgent, group, installDependencies, installOption, intro, isCancel, log, multiselect, note, outro, packageManagerPrompt, parseCss$1, parseHtml, parseHtml$1, parseJson$1, parseScript$1, parseSvelte, program, require_picocolors, resolveCommand, select, spinner, templates, text, up, walk_exports } from "./package-manager-D3PRQ-L_.js";
import { addFromString, applyAddons, array_exports, common_exports, createWorkspace, dedent_default, exports_exports, formatFiles, function_exports, getHighlighter, imports_exports, kit_exports, object_exports, require_picocolors$1, setupAddons, variables_exports } from "./install-iBxCFLH9.js";
import fs, { existsSync } from "node:fs";
import path, { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import process$1 from "node:process";
import { exec, execSync } from "node:child_process";
import { createGunzip } from "node:zlib";
import { pipeline } from "node:stream/promises";
import { promisify } from "node:util";

//#region packages/cli/package.json
var name = "sv";
var version = "0.8.1";
var type = "module";
var description = "A CLI for creating and updating SvelteKit projects";
var license = "MIT";
var repository = {
	"type": "git",
	"url": "https://github.com/sveltejs/cli",
	"directory": "packages/cli"
};
var homepage = "https://svelte.dev";
var scripts = {
	"check": "tsc",
	"format": "pnpm lint --write",
	"lint": "prettier --check . --config ../../prettier.config.js --ignore-path ../../.gitignore --ignore-path .gitignore --ignore-path ../../.prettierignore"
};
var files = ["dist"];
var bin = "./dist/bin.js";
var exports$1 = {
	".": {
		"types": "./dist/lib/index.d.ts",
		"default": "./dist/index.js"
	},
	"./testing": {
		"types": "./dist/lib/testing.d.ts",
		"default": "./dist/testing.js"
	}
};
var devDependencies = {
	"@sveltejs/addons": "workspace:*",
	"@sveltejs/clack-prompts": "workspace:*",
	"@sveltejs/cli-core": "workspace:*",
	"@sveltejs/create": "workspace:*",
	"@types/degit": "^2.8.6",
	"@types/ps-tree": "^1.1.6",
	"@types/tar-fs": "^2.0.4",
	"commander": "^13.1.0",
	"degit": "^2.8.4",
	"empathic": "^1.0.0",
	"package-manager-detector": "^0.2.11",
	"picocolors": "^1.1.1",
	"ps-tree": "^1.2.0",
	"tar-fs": "^3.0.8",
	"tinyexec": "^0.3.2",
	"valibot": "^0.41.0"
};
var keywords = [
	"create",
	"new",
	"project",
	"starter",
	"svelte",
	"sveltekit",
	"template",
	"wizard"
];
var package_default = {
	name,
	version,
	type,
	description,
	license,
	repository,
	homepage,
	scripts,
	files,
	bin,
	exports: exports$1,
	devDependencies,
	keywords
};

//#endregion
//#region node_modules/.pnpm/valibot@0.41.0_typescript@5.8.3/node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
	return {
		lang: config2?.lang ?? store?.lang,
		message: config2?.message,
		abortEarly: config2?.abortEarly ?? store?.abortEarly,
		abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
	};
}
var store2;
function getGlobalMessage(lang) {
	return store2?.get(lang);
}
var store3;
function getSchemaMessage(lang) {
	return store3?.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
	return store4?.get(reference)?.get(lang);
}
function _stringify(input) {
	const type$1 = typeof input;
	if (type$1 === "string") return `"${input}"`;
	if (type$1 === "number" || type$1 === "bigint" || type$1 === "boolean") return `${input}`;
	if (type$1 === "object" || type$1 === "function") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
	return type$1;
}
function _addIssue(context, label, dataset, config2, other) {
	const input = other && "input" in other ? other.input : dataset.value;
	const expected = other?.expected ?? context.expects ?? null;
	const received = other?.received ?? _stringify(input);
	const issue = {
		kind: context.kind,
		type: context.type,
		input,
		expected,
		received,
		message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
		requirement: context.requirement,
		path: other?.path,
		issues: other?.issues,
		lang: config2.lang,
		abortEarly: config2.abortEarly,
		abortPipeEarly: config2.abortPipeEarly
	};
	const isSchema = context.kind === "schema";
	const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
	if (message) issue.message = typeof message === "function" ? message(issue) : message;
	if (isSchema) dataset.typed = false;
	if (dataset.issues) dataset.issues.push(issue);
else dataset.issues = [issue];
}
function _joinExpects(values, separator) {
	const list = [...new Set(values)];
	if (list.length > 1) return `(${list.join(` ${separator} `)})`;
	return list[0] ?? "never";
}
var ValiError = class extends Error {
	/**
	* The error issues.
	*/
	issues;
	/**
	* Creates a Valibot error with useful information.
	*
	* @param issues The error issues.
	*/
	constructor(issues) {
		super(issues[0].message);
		this.name = "ValiError";
		this.issues = issues;
	}
};
function transform(operation) {
	return {
		kind: "transformation",
		type: "transform",
		reference: transform,
		async: false,
		operation,
		_run(dataset) {
			dataset.value = this.operation(dataset.value);
			return dataset;
		}
	};
}
function getDefault(schema, dataset, config2) {
	return typeof schema.default === "function" ? schema.default(dataset, config2) : schema.default;
}
function array(item, message) {
	return {
		kind: "schema",
		type: "array",
		reference: array,
		expects: "Array",
		async: false,
		item,
		message,
		_run(dataset, config2) {
			const input = dataset.value;
			if (Array.isArray(input)) {
				dataset.typed = true;
				dataset.value = [];
				for (let key = 0; key < input.length; key++) {
					const value2 = input[key];
					const itemDataset = this.item._run({
						typed: false,
						value: value2
					}, config2);
					if (itemDataset.issues) {
						const pathItem = {
							type: "array",
							origin: "value",
							input,
							key,
							value: value2
						};
						for (const issue of itemDataset.issues) {
							if (issue.path) issue.path.unshift(pathItem);
else issue.path = [pathItem];
							dataset.issues?.push(issue);
						}
						if (!dataset.issues) dataset.issues = itemDataset.issues;
						if (config2.abortEarly) {
							dataset.typed = false;
							break;
						}
					}
					if (!itemDataset.typed) dataset.typed = false;
					dataset.value.push(itemDataset.value);
				}
			} else _addIssue(this, "type", dataset, config2);
			return dataset;
		}
	};
}
function boolean(message) {
	return {
		kind: "schema",
		type: "boolean",
		reference: boolean,
		expects: "boolean",
		async: false,
		message,
		_run(dataset, config2) {
			if (typeof dataset.value === "boolean") dataset.typed = true;
else _addIssue(this, "type", dataset, config2);
			return dataset;
		}
	};
}
function object(entries, message) {
	return {
		kind: "schema",
		type: "object",
		reference: object,
		expects: "Object",
		async: false,
		entries,
		message,
		_run(dataset, config2) {
			const input = dataset.value;
			if (input && typeof input === "object") {
				dataset.typed = true;
				dataset.value = {};
				for (const key in this.entries) {
					const value2 = input[key];
					const valueDataset = this.entries[key]._run({
						typed: false,
						value: value2
					}, config2);
					if (valueDataset.issues) {
						const pathItem = {
							type: "object",
							origin: "value",
							input,
							key,
							value: value2
						};
						for (const issue of valueDataset.issues) {
							if (issue.path) issue.path.unshift(pathItem);
else issue.path = [pathItem];
							dataset.issues?.push(issue);
						}
						if (!dataset.issues) dataset.issues = valueDataset.issues;
						if (config2.abortEarly) {
							dataset.typed = false;
							break;
						}
					}
					if (!valueDataset.typed) dataset.typed = false;
					if (valueDataset.value !== void 0 || key in input) dataset.value[key] = valueDataset.value;
				}
			} else _addIssue(this, "type", dataset, config2);
			return dataset;
		}
	};
}
function optional(wrapped, ...args) {
	const schema = {
		kind: "schema",
		type: "optional",
		reference: optional,
		expects: `(${wrapped.expects} | undefined)`,
		async: false,
		wrapped,
		_run(dataset, config2) {
			if (dataset.value === void 0) {
				if ("default" in this) dataset.value = getDefault(this, dataset, config2);
				if (dataset.value === void 0) {
					dataset.typed = true;
					return dataset;
				}
			}
			return this.wrapped._run(dataset, config2);
		}
	};
	if (0 in args) schema.default = args[0];
	return schema;
}
function picklist(options$6, message) {
	return {
		kind: "schema",
		type: "picklist",
		reference: picklist,
		expects: _joinExpects(options$6.map(_stringify), "|"),
		async: false,
		options: options$6,
		message,
		_run(dataset, config2) {
			if (this.options.includes(dataset.value)) dataset.typed = true;
else _addIssue(this, "type", dataset, config2);
			return dataset;
		}
	};
}
function strictObject(entries, message) {
	return {
		kind: "schema",
		type: "strict_object",
		reference: strictObject,
		expects: "Object",
		async: false,
		entries,
		message,
		_run(dataset, config2) {
			const input = dataset.value;
			if (input && typeof input === "object") {
				dataset.typed = true;
				dataset.value = {};
				for (const key in this.entries) {
					const value2 = input[key];
					const valueDataset = this.entries[key]._run({
						typed: false,
						value: value2
					}, config2);
					if (valueDataset.issues) {
						const pathItem = {
							type: "object",
							origin: "value",
							input,
							key,
							value: value2
						};
						for (const issue of valueDataset.issues) {
							if (issue.path) issue.path.unshift(pathItem);
else issue.path = [pathItem];
							dataset.issues?.push(issue);
						}
						if (!dataset.issues) dataset.issues = valueDataset.issues;
						if (config2.abortEarly) {
							dataset.typed = false;
							break;
						}
					}
					if (!valueDataset.typed) dataset.typed = false;
					if (valueDataset.value !== void 0 || key in input) dataset.value[key] = valueDataset.value;
				}
				if (!dataset.issues || !config2.abortEarly) {
					for (const key in input) if (!(key in this.entries)) {
						const value2 = input[key];
						_addIssue(this, "type", dataset, config2, {
							input: value2,
							expected: "never",
							path: [{
								type: "object",
								origin: "value",
								input,
								key,
								value: value2
							}]
						});
						break;
					}
				}
			} else _addIssue(this, "type", dataset, config2);
			return dataset;
		}
	};
}
function string(message) {
	return {
		kind: "schema",
		type: "string",
		reference: string,
		expects: "string",
		async: false,
		message,
		_run(dataset, config2) {
			if (typeof dataset.value === "string") dataset.typed = true;
else _addIssue(this, "type", dataset, config2);
			return dataset;
		}
	};
}
function _subIssues(datasets) {
	let issues;
	if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);
else issues = dataset.issues;
	return issues;
}
function union(options$6, message) {
	return {
		kind: "schema",
		type: "union",
		reference: union,
		expects: _joinExpects(options$6.map((option) => option.expects), "|"),
		async: false,
		options: options$6,
		message,
		_run(dataset, config2) {
			let validDataset;
			let typedDatasets;
			let untypedDatasets;
			for (const schema of this.options) {
				const optionDataset = schema._run({
					typed: false,
					value: dataset.value
				}, config2);
				if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
else typedDatasets = [optionDataset];
else {
					validDataset = optionDataset;
					break;
				}
else if (untypedDatasets) untypedDatasets.push(optionDataset);
else untypedDatasets = [optionDataset];
			}
			if (validDataset) return validDataset;
			if (typedDatasets) {
				if (typedDatasets.length === 1) return typedDatasets[0];
				_addIssue(this, "type", dataset, config2, { issues: _subIssues(typedDatasets) });
				dataset.typed = true;
			} else if (untypedDatasets?.length === 1) return untypedDatasets[0];
else _addIssue(this, "type", dataset, config2, { issues: _subIssues(untypedDatasets) });
			return dataset;
		}
	};
}
function parse(schema, input, config2) {
	const dataset = schema._run({
		typed: false,
		value: input
	}, getGlobalConfig(config2));
	if (dataset.issues) throw new ValiError(dataset.issues);
	return dataset.value;
}
function pipe$1(...pipe2) {
	return {
		...pipe2[0],
		pipe: pipe2,
		_run(dataset, config2) {
			for (const item of pipe2) if (item.kind !== "metadata") {
				if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
					dataset.typed = false;
					break;
				}
				if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) dataset = item._run(dataset, config2);
			}
			return dataset;
		}
	};
}

//#endregion
//#region node_modules/.pnpm/empathic@1.0.0/node_modules/empathic/package.mjs
function up$1(options$6) {
	return up("package.json", options$6);
}

//#endregion
//#region packages/core/dist/index.js
function defineAddon(config) {
	return config;
}
function defineAddonOptions(options$6) {
	return options$6;
}
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from$2, except, desc) => {
	if (from$2 && typeof from$2 === "object" || typeof from$2 === "function") for (var keys$1 = __getOwnPropNames$1(from$2), i = 0, n$1 = keys$1.length, key; i < n$1; i++) {
		key = keys$1[i];
		if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: ((k) => from$2[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$1(from$2, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS$2 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from$2, except, desc) => {
	if (from$2 && typeof from$2 === "object" || typeof from$2 === "function") for (var keys$1 = __getOwnPropNames(from$2), i = 0, n$1 = keys$1.length, key; i < n$1; i++) {
		key = keys$1[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from$2[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from$2, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var require_src$1 = __commonJS$2({ "node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js"(exports$2, module$1) {
	const ESC$1 = "\x1B";
	const CSI$1 = `${ESC$1}[`;
	const beep$1 = "\x07";
	const cursor$3 = {
		to(x, y) {
			if (!y) return `${CSI$1}${x + 1}G`;
			return `${CSI$1}${y + 1};${x + 1}H`;
		},
		move(x, y) {
			let ret = "";
			if (x < 0) ret += `${CSI$1}${-x}D`;
else if (x > 0) ret += `${CSI$1}${x}C`;
			if (y < 0) ret += `${CSI$1}${-y}A`;
else if (y > 0) ret += `${CSI$1}${y}B`;
			return ret;
		},
		up: (count = 1) => `${CSI$1}${count}A`,
		down: (count = 1) => `${CSI$1}${count}B`,
		forward: (count = 1) => `${CSI$1}${count}C`,
		backward: (count = 1) => `${CSI$1}${count}D`,
		nextLine: (count = 1) => `${CSI$1}E`.repeat(count),
		prevLine: (count = 1) => `${CSI$1}F`.repeat(count),
		left: `${CSI$1}G`,
		hide: `${CSI$1}?25l`,
		show: `${CSI$1}?25h`,
		save: `${ESC$1}7`,
		restore: `${ESC$1}8`
	};
	const scroll$1 = {
		up: (count = 1) => `${CSI$1}S`.repeat(count),
		down: (count = 1) => `${CSI$1}T`.repeat(count)
	};
	const erase$1$1 = {
		screen: `${CSI$1}2J`,
		up: (count = 1) => `${CSI$1}1J`.repeat(count),
		down: (count = 1) => `${CSI$1}J`.repeat(count),
		line: `${CSI$1}2K`,
		lineEnd: `${CSI$1}K`,
		lineStart: `${CSI$1}1K`,
		lines(count) {
			let clear = "";
			for (let i = 0; i < count; i++) clear += this.line + (i < count - 1 ? cursor$3.up() : "");
			if (count) clear += cursor$3.left;
			return clear;
		}
	};
	module$1.exports = {
		cursor: cursor$3,
		scroll: scroll$1,
		erase: erase$1$1,
		beep: beep$1
	};
} });
function ansiRegex$1({ onlyFirst = false } = {}) {
	const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
	const pattern = [`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`, "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
	return new RegExp(pattern, onlyFirst ? undefined : "g");
}
const regex = ansiRegex$1();
var require_eastasianwidth = __commonJS$2({ "node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js"(exports$2, module$1) {
	var eaw = {};
	if ("undefined" == typeof module$1) window.eastasianwidth = eaw;
else module$1.exports = eaw;
	eaw.eastAsianWidth = function(character) {
		var x = character.charCodeAt(0);
		var y = character.length == 2 ? character.charCodeAt(1) : 0;
		var codePoint = x;
		if (55296 <= x && x <= 56319 && 56320 <= y && y <= 57343) {
			x &= 1023;
			y &= 1023;
			codePoint = x << 10 | y;
			codePoint += 65536;
		}
		if (12288 == codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) return "F";
		if (8361 == codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518) return "H";
		if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) return "W";
		if (32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 == codePoint || 175 == codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630) return "Na";
		if (161 == codePoint || 164 == codePoint || 167 <= codePoint && codePoint <= 168 || 170 == codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 == codePoint || 208 == codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 == codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 == codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 == codePoint || 254 == codePoint || 257 == codePoint || 273 == codePoint || 275 == codePoint || 283 == codePoint || 294 <= codePoint && codePoint <= 295 || 299 == codePoint || 305 <= codePoint && codePoint <= 307 || 312 == codePoint || 319 <= codePoint && codePoint <= 322 || 324 == codePoint || 328 <= codePoint && codePoint <= 331 || 333 == codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 == codePoint || 462 == codePoint || 464 == codePoint || 466 == codePoint || 468 == codePoint || 470 == codePoint || 472 == codePoint || 474 == codePoint || 476 == codePoint || 593 == codePoint || 609 == codePoint || 708 == codePoint || 711 == codePoint || 713 <= codePoint && codePoint <= 715 || 717 == codePoint || 720 == codePoint || 728 <= codePoint && codePoint <= 731 || 733 == codePoint || 735 == codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 == codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 == codePoint || 8208 == codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 == codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 == codePoint || 8251 == codePoint || 8254 == codePoint || 8308 == codePoint || 8319 == codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 == codePoint || 8451 == codePoint || 8453 == codePoint || 8457 == codePoint || 8467 == codePoint || 8470 == codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 == codePoint || 8491 == codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 == codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 == codePoint || 8660 == codePoint || 8679 == codePoint || 8704 == codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 == codePoint || 8719 == codePoint || 8721 == codePoint || 8725 == codePoint || 8730 == codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 == codePoint || 8741 == codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 == codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 == codePoint || 8780 == codePoint || 8786 == codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 == codePoint || 8857 == codePoint || 8869 == codePoint || 8895 == codePoint || 8978 == codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 == codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 == codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 == codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 == codePoint || 9758 == codePoint || 9792 == codePoint || 9794 == codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 == codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 == codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 == codePoint || 10071 == codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 == codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109) return "A";
		return "N";
	};
	eaw.characterLength = function(character) {
		var code = this.eastAsianWidth(character);
		if (code == "F" || code == "W" || code == "A") return 2;
else return 1;
	};
	function stringToArray(string$1) {
		return string$1.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
	}
	eaw.length = function(string$1) {
		var characters = stringToArray(string$1);
		var len = 0;
		for (var i = 0; i < characters.length; i++) len = len + this.characterLength(characters[i]);
		return len;
	};
	eaw.slice = function(text$1, start, end) {
		textLen = eaw.length(text$1);
		start = start ? start : 0;
		end = end ? end : 1;
		if (start < 0) start = textLen + start;
		if (end < 0) end = textLen + end;
		var result = "";
		var eawLen = 0;
		var chars$1 = stringToArray(text$1);
		for (var i = 0; i < chars$1.length; i++) {
			var char = chars$1[i];
			var charLen = eaw.length(char);
			if (eawLen >= start - (charLen == 2 ? 1 : 0)) if (eawLen + charLen <= end) result += char;
else break;
			eawLen += charLen;
		}
		return result;
	};
} });
var require_emoji_regex = __commonJS$2({ "node_modules/.pnpm/emoji-regex@9.2.2/node_modules/emoji-regex/index.js"(exports$2, module$1) {
	module$1.exports = function() {
		return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
	};
} });
var import_eastasianwidth = __toESM$2(require_eastasianwidth(), 1);
var import_emoji_regex = __toESM$2(require_emoji_regex(), 1);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
	const codes = new Map();
	for (const [groupName, group$1] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group$1)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group$1[styleName] = styles[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles, groupName, {
			value: group$1,
			enumerable: false
		});
	}
	Object.defineProperty(styles, "codes", {
		value: codes,
		enumerable: false
	});
	styles.color.close = "\x1B[39m";
	styles.bgColor.close = "\x1B[49m";
	styles.color.ansi = wrapAnsi16();
	styles.color.ansi256 = wrapAnsi256();
	styles.color.ansi16m = wrapAnsi16m();
	styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles, {
		rgbToAnsi256: {
			value: (red, green, blue) => {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value: (hex) => {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value: (code) => {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles;
}
const ansiStyles = assembleStyles();
const ANSI_OSC = "]";
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
var import_src$2 = __toESM$2(require_src$1(), 1);
const cancel$1 = Symbol("clack:cancel");
var import_src$1 = __toESM$2(require_src$1(), 1);
var require_picocolors$1$1 = __commonJS$2({ "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports$2, module$1) {
	let p$1 = process || {}, argv$1 = p$1.argv || [], env$1 = p$1.env || {};
	let isColorSupported$1 = !(!!env$1.NO_COLOR || argv$1.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv$1.includes("--color") || p$1.platform === "win32" || (p$1.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI);
	let formatter$1 = (open, close, replace = open) => (input) => {
		let string$1 = "" + input, index = string$1.indexOf(close, open.length);
		return ~index ? open + replaceClose$1(string$1, close, replace, index) + close : open + string$1 + close;
	};
	let replaceClose$1 = (string$1, close, replace, index) => {
		let result = "", cursor$4 = 0;
		do {
			result += string$1.substring(cursor$4, index) + replace;
			cursor$4 = index + close.length;
			index = string$1.indexOf(close, cursor$4);
		} while (~index);
		return result + string$1.substring(cursor$4);
	};
	let createColors$1 = (enabled = isColorSupported$1) => {
		let f = enabled ? formatter$1 : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m")
		};
	};
	module$1.exports = createColors$1();
	module$1.exports.createColors = createColors$1;
} });
var import_picocolors$1$1 = __toESM$2(require_picocolors$1$1(), 1);
var import_picocolors$2$1 = __toESM$2(require_picocolors$1$1(), 1);
var import_src$3 = __toESM$2(require_src$1(), 1);
const isWindows = process$1.platform.startsWith("win");
function isUnicodeSupported() {
	if (process$1.platform !== "win32") return process$1.env.TERM !== "linux";
	return Boolean(process$1.env.CI) || Boolean(process$1.env.WT_SESSION) || Boolean(process$1.env.TERMINUS_SUBLIME) || process$1.env.ConEmuTask === "{cmd::Cmder}" || process$1.env.TERM_PROGRAM === "Terminus-Sublime" || process$1.env.TERM_PROGRAM === "vscode" || process$1.env.TERM === "xterm-256color" || process$1.env.TERM === "alacritty" || process$1.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var require_picocolors$2 = __commonJS$1({ "node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports$2, module$1) {
	let p = process || {}, argv = p.argv || [], env$1 = p.env || {};
	let isColorSupported = !(!!env$1.NO_COLOR || argv.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI);
	let formatter = (open, close, replace = open) => (input) => {
		let string$1 = "" + input, index = string$1.indexOf(close, open.length);
		return ~index ? open + replaceClose(string$1, close, replace, index) + close : open + string$1 + close;
	};
	let replaceClose = (string$1, close, replace, index) => {
		let result = "", cursor$2 = 0;
		do {
			result += string$1.substring(cursor$2, index) + replace;
			cursor$2 = index + close.length;
			index = string$1.indexOf(close, cursor$2);
		} while (~index);
		return result + string$1.substring(cursor$2);
	};
	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m")
		};
	};
	module$1.exports = createColors();
	module$1.exports.createColors = createColors;
} });
var require_src = __commonJS$1({ "node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js"(exports$2, module$1) {
	const ESC = "\x1B";
	const CSI = `${ESC}[`;
	const beep = "\x07";
	const cursor$1 = {
		to(x, y) {
			if (!y) return `${CSI}${x + 1}G`;
			return `${CSI}${y + 1};${x + 1}H`;
		},
		move(x, y) {
			let ret = "";
			if (x < 0) ret += `${CSI}${-x}D`;
else if (x > 0) ret += `${CSI}${x}C`;
			if (y < 0) ret += `${CSI}${-y}A`;
else if (y > 0) ret += `${CSI}${y}B`;
			return ret;
		},
		up: (count = 1) => `${CSI}${count}A`,
		down: (count = 1) => `${CSI}${count}B`,
		forward: (count = 1) => `${CSI}${count}C`,
		backward: (count = 1) => `${CSI}${count}D`,
		nextLine: (count = 1) => `${CSI}E`.repeat(count),
		prevLine: (count = 1) => `${CSI}F`.repeat(count),
		left: `${CSI}G`,
		hide: `${CSI}?25l`,
		show: `${CSI}?25h`,
		save: `${ESC}7`,
		restore: `${ESC}8`
	};
	const scroll = {
		up: (count = 1) => `${CSI}S`.repeat(count),
		down: (count = 1) => `${CSI}T`.repeat(count)
	};
	const erase$1 = {
		screen: `${CSI}2J`,
		up: (count = 1) => `${CSI}1J`.repeat(count),
		down: (count = 1) => `${CSI}J`.repeat(count),
		line: `${CSI}2K`,
		lineEnd: `${CSI}K`,
		lineStart: `${CSI}1K`,
		lines(count) {
			let clear = "";
			for (let i = 0; i < count; i++) clear += this.line + (i < count - 1 ? cursor$1.up() : "");
			if (count) clear += cursor$1.left;
			return clear;
		}
	};
	module$1.exports = {
		cursor: cursor$1,
		scroll,
		erase: erase$1,
		beep
	};
} });
var import_picocolors$3$1 = __toESM$1$1(require_picocolors$2(), 1);
var import_src = __toESM$1$1(require_src(), 1);
const unicode = isUnicodeSupported();
const s = (c, fallback) => unicode ? c : fallback;
const S_STEP_ACTIVE = s("◆", "*");
const S_STEP_CANCEL = s("■", "x");
const S_STEP_ERROR = s("▲", "x");
const S_STEP_SUBMIT = s("◇", "o");
const S_BAR_START = s("┌", "T");
const S_BAR = s("│", "|");
const S_BAR_END = s("└", "—");
const S_RADIO_ACTIVE = s("●", ">");
const S_RADIO_INACTIVE = s("○", " ");
const S_CHECKBOX_ACTIVE = s("◻", "[•]");
const S_CHECKBOX_SELECTED = s("◼", "[+]");
const S_CHECKBOX_INACTIVE = s("◻", "[ ]");
const S_PASSWORD_MASK = s("▪", "•");
const S_BAR_H = s("─", "-");
const S_CORNER_TOP_RIGHT = s("╮", "+");
const S_CONNECT_LEFT = s("├", "+");
const S_CORNER_BOTTOM_RIGHT = s("╯", "+");
const S_INFO = s("●", "•");
const S_SUCCESS = s("◆", "*");
const S_WARN = s("▲", "!");
const S_ERROR = s("■", "x");
const log$1 = {
	message: (message = "", { symbol: symbol$1 = import_picocolors$3$1.default.gray(S_BAR) } = {}) => {
		const parts = [import_picocolors$3$1.default.gray(S_BAR)];
		if (message) {
			const [firstLine, ...lines] = message.split("\n");
			parts.push(`${symbol$1}  ${firstLine}`, ...lines.map((ln) => `${import_picocolors$3$1.default.gray(S_BAR)}  ${ln}`));
		}
		process$1.stdout.write(`${parts.join("\n")}\n`);
	},
	info: (message) => {
		log$1.message(message, { symbol: import_picocolors$3$1.default.blue(S_INFO) });
	},
	success: (message) => {
		log$1.message(message, { symbol: import_picocolors$3$1.default.green(S_SUCCESS) });
	},
	step: (message) => {
		log$1.message(message, { symbol: import_picocolors$3$1.default.green(S_STEP_SUBMIT) });
	},
	warn: (message) => {
		log$1.message(message, { symbol: import_picocolors$3$1.default.yellow(S_WARN) });
	},
	warning: (message) => {
		log$1.warn(message);
	},
	error: (message) => {
		log$1.message(message, { symbol: import_picocolors$3$1.default.red(S_ERROR) });
	}
};
var utils_exports = {};
__export(utils_exports, { createPrinter: () => createPrinter });
function createPrinter(...conditions) {
	const printers = conditions.map((condition) => {
		return (content, alt = "") => condition ? content : alt;
	});
	return printers;
}
var import_picocolors$4 = __toESM$1(require_picocolors(), 1);
var colors = import_picocolors$4.default;

//#endregion
//#region packages/addons/drizzle/index.ts
const PORTS = {
	mysql: "3306",
	postgresql: "5432",
	sqlite: ""
};
const options$5 = defineAddonOptions({
	database: {
		question: "Which database would you like to use?",
		type: "select",
		default: "sqlite",
		options: [
			{
				value: "postgresql",
				label: "PostgreSQL"
			},
			{
				value: "mysql",
				label: "MySQL"
			},
			{
				value: "sqlite",
				label: "SQLite"
			}
		]
	},
	postgresql: {
		question: "Which PostgreSQL client would you like to use?",
		type: "select",
		group: "client",
		default: "postgres.js",
		options: [{
			value: "postgres.js",
			label: "Postgres.JS",
			hint: "recommended for most users"
		}, {
			value: "neon",
			label: "Neon",
			hint: "popular hosted platform"
		}],
		condition: ({ database }) => database === "postgresql"
	},
	mysql: {
		question: "Which MySQL client would you like to use?",
		type: "select",
		group: "client",
		default: "mysql2",
		options: [{
			value: "mysql2",
			hint: "recommended for most users"
		}, {
			value: "planetscale",
			label: "PlanetScale",
			hint: "popular hosted platform"
		}],
		condition: ({ database }) => database === "mysql"
	},
	sqlite: {
		question: "Which SQLite client would you like to use?",
		type: "select",
		group: "client",
		default: "libsql",
		options: [
			{
				value: "better-sqlite3",
				hint: "for traditional Node environments"
			},
			{
				value: "libsql",
				label: "libSQL",
				hint: "for serverless environments"
			},
			{
				value: "turso",
				label: "Turso",
				hint: "popular hosted platform"
			}
		],
		condition: ({ database }) => database === "sqlite"
	},
	docker: {
		question: "Do you want to run the database locally with docker-compose?",
		default: false,
		type: "boolean",
		condition: ({ database, mysql, postgresql }) => database === "mysql" && mysql === "mysql2" || database === "postgresql" && postgresql === "postgres.js"
	}
});
var drizzle_default = defineAddon({
	id: "drizzle",
	shortDescription: "database orm",
	homepage: "https://orm.drizzle.team",
	options: options$5,
	setup: ({ kit, unsupported }) => {
		if (!kit) unsupported("Requires SvelteKit");
	},
	run: ({ sv, typescript, options: options$6, kit }) => {
		const ext = typescript ? "ts" : "js";
		sv.dependency("drizzle-orm", "^0.40.0");
		sv.devDependency("drizzle-kit", "^0.30.2");
		if (options$6.mysql === "mysql2") sv.dependency("mysql2", "^3.12.0");
		if (options$6.mysql === "planetscale") sv.dependency("@planetscale/database", "^1.19.0");
		if (options$6.postgresql === "neon") sv.dependency("@neondatabase/serverless", "^0.10.4");
		if (options$6.postgresql === "postgres.js") sv.dependency("postgres", "^3.4.5");
		if (options$6.sqlite === "better-sqlite3") {
			sv.dependency("better-sqlite3", "^11.8.0");
			sv.devDependency("@types/better-sqlite3", "^7.6.12");
			sv.pnpmBuildDependendency("better-sqlite3");
		}
		if (options$6.sqlite === "libsql" || options$6.sqlite === "turso") sv.dependency("@libsql/client", "^0.14.0");
		sv.file(".env", (content) => generateEnvFileContent(content, options$6));
		sv.file(".env.example", (content) => generateEnvFileContent(content, options$6));
		if (options$6.docker && (options$6.mysql === "mysql2" || options$6.postgresql === "postgres.js")) sv.file("docker-compose.yml", (content) => {
			if (content.length > 0) return content;
			const imageName = options$6.database === "mysql" ? "mysql" : "postgres";
			const port = PORTS[options$6.database];
			const USER = "root";
			const PASSWORD = "mysecretpassword";
			const DB_NAME = "local";
			let dbSpecificContent = "";
			if (options$6.mysql === "mysql2") dbSpecificContent = `
                      MYSQL_ROOT_PASSWORD: ${PASSWORD}
                      MYSQL_DATABASE: ${DB_NAME}
                    volumes:
                      - mysqldata:/var/lib/mysql
                volumes:
                  mysqldata:
                `;
			if (options$6.postgresql === "postgres.js") dbSpecificContent = `
                      POSTGRES_USER: ${USER}
                      POSTGRES_PASSWORD: ${PASSWORD}
                      POSTGRES_DB: ${DB_NAME}
                    volumes:
                      - pgdata:/var/lib/postgresql/data
                volumes:
                  pgdata:
                `;
			content = dedent_default`
                services:
                  db:
                    image: ${imageName}
                    restart: always
                    ports:
                      - ${port}:${port}
                    environment: ${dbSpecificContent}
                `;
			return content;
		});
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson$1(content);
			data.scripts ??= {};
			const scripts$1 = data.scripts;
			if (options$6.docker) scripts$1["db:start"] ??= "docker compose up";
			scripts$1["db:push"] ??= "drizzle-kit push";
			scripts$1["db:migrate"] ??= "drizzle-kit migrate";
			scripts$1["db:studio"] ??= "drizzle-kit studio";
			return generateCode();
		});
		if (options$6.database === "sqlite") sv.file(".gitignore", (content) => {
			if (content.length === 0) return content;
			if (!content.includes("\n*.db")) content = content.trimEnd() + "\n\n# SQLite\n*.db";
			return content;
		});
		sv.file(`drizzle.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamed(ast, "drizzle-kit", { defineConfig: "defineConfig" });
			const envCheckStatement = common_exports.statementFromString("if (!process.env.DATABASE_URL) throw new Error('DATABASE_URL is not set');");
			common_exports.addStatement(ast, envCheckStatement);
			const fallback = common_exports.expressionFromString("defineConfig({})");
			const { value: exportDefault } = exports_exports.defaultExport(ast, fallback);
			if (exportDefault.type !== "CallExpression") return content;
			const objExpression = exportDefault.arguments?.[0];
			if (!objExpression || objExpression.type !== "ObjectExpression") return content;
			const authToken = options$6.sqlite === "turso" ? common_exports.expressionFromString("process.env.DATABASE_AUTH_TOKEN") : undefined;
			object_exports.properties(objExpression, {
				schema: common_exports.createLiteral(`./src/lib/server/db/schema.${typescript ? "ts" : "js"}`),
				dbCredentials: object_exports.create({
					url: common_exports.expressionFromString("process.env.DATABASE_URL"),
					authToken
				}),
				verbose: {
					type: "Literal",
					value: true
				},
				strict: {
					type: "Literal",
					value: true
				}
			});
			const dialect = options$6.sqlite === "turso" ? "turso" : options$6.database;
			object_exports.overrideProperties(objExpression, { dialect: common_exports.createLiteral(dialect) });
			if (options$6.database !== "sqlite") object_exports.removeProperty(objExpression, "driver");
			return generateCode();
		});
		sv.file(`${kit?.libDirectory}/server/db/schema.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			let userSchemaExpression;
			if (options$6.database === "sqlite") {
				imports_exports.addNamed(ast, "drizzle-orm/sqlite-core", {
					sqliteTable: "sqliteTable",
					text: "text",
					integer: "integer"
				});
				userSchemaExpression = common_exports.expressionFromString(`sqliteTable('user', {
					id: integer('id').primaryKey(),
					age: integer('age')
				})`);
			}
			if (options$6.database === "mysql") {
				imports_exports.addNamed(ast, "drizzle-orm/mysql-core", {
					mysqlTable: "mysqlTable",
					serial: "serial",
					text: "text",
					int: "int"
				});
				userSchemaExpression = common_exports.expressionFromString(`mysqlTable('user', {
					id: serial('id').primaryKey(),
					age: int('age'),
				})`);
			}
			if (options$6.database === "postgresql") {
				imports_exports.addNamed(ast, "drizzle-orm/pg-core", {
					pgTable: "pgTable",
					serial: "serial",
					text: "text",
					integer: "integer"
				});
				userSchemaExpression = common_exports.expressionFromString(`pgTable('user', {
					id: serial('id').primaryKey(),
					age: integer('age'),
				})`);
			}
			if (!userSchemaExpression) throw new Error("unreachable state...");
			const userIdentifier = variables_exports.declaration(ast, "const", "user", userSchemaExpression);
			exports_exports.namedExport(ast, "user", userIdentifier);
			return generateCode();
		});
		sv.file(`${kit?.libDirectory}/server/db/index.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamed(ast, "$env/dynamic/private", { env: "env" });
			imports_exports.addNamespace(ast, "./schema", "schema");
			const dbURLCheck = common_exports.statementFromString("if (!env.DATABASE_URL) throw new Error('DATABASE_URL is not set');");
			common_exports.addStatement(ast, dbURLCheck);
			let clientExpression;
			if (options$6.sqlite === "better-sqlite3") {
				imports_exports.addDefault(ast, "better-sqlite3", "Database");
				imports_exports.addNamed(ast, "drizzle-orm/better-sqlite3", { drizzle: "drizzle" });
				clientExpression = common_exports.expressionFromString("new Database(env.DATABASE_URL)");
			}
			if (options$6.sqlite === "libsql" || options$6.sqlite === "turso") {
				imports_exports.addNamed(ast, "@libsql/client", { createClient: "createClient" });
				imports_exports.addNamed(ast, "drizzle-orm/libsql", { drizzle: "drizzle" });
				if (options$6.sqlite === "turso") {
					imports_exports.addNamed(ast, "$app/environment", { dev: "dev" });
					const authTokenCheck = common_exports.statementFromString("if (!dev && !env.DATABASE_AUTH_TOKEN) throw new Error('DATABASE_AUTH_TOKEN is not set');");
					common_exports.addStatement(ast, authTokenCheck);
					clientExpression = common_exports.expressionFromString("createClient({ url: env.DATABASE_URL, authToken: env.DATABASE_AUTH_TOKEN })");
				} else clientExpression = common_exports.expressionFromString("createClient({ url: env.DATABASE_URL })");
			}
			if (options$6.mysql === "mysql2" || options$6.mysql === "planetscale") {
				imports_exports.addDefault(ast, "mysql2/promise", "mysql");
				imports_exports.addNamed(ast, "drizzle-orm/mysql2", { drizzle: "drizzle" });
				clientExpression = common_exports.expressionFromString("await mysql.createConnection(env.DATABASE_URL)");
			}
			if (options$6.postgresql === "neon") {
				imports_exports.addNamed(ast, "@neondatabase/serverless", { neon: "neon" });
				imports_exports.addNamed(ast, "drizzle-orm/neon-http", { drizzle: "drizzle" });
				clientExpression = common_exports.expressionFromString("neon(env.DATABASE_URL)");
			}
			if (options$6.postgresql === "postgres.js") {
				imports_exports.addDefault(ast, "postgres", "postgres");
				imports_exports.addNamed(ast, "drizzle-orm/postgres-js", { drizzle: "drizzle" });
				clientExpression = common_exports.expressionFromString("postgres(env.DATABASE_URL)");
			}
			if (!clientExpression) throw new Error("unreachable state...");
			const clientIdentifier = variables_exports.declaration(ast, "const", "client", clientExpression);
			common_exports.addStatement(ast, clientIdentifier);
			const drizzleCall = function_exports.callByIdentifier("drizzle", ["client"]);
			const paramObject = object_exports.create({ schema: variables_exports.identifier("schema") });
			if (options$6.database === "mysql") {
				const mode = options$6.mysql === "planetscale" ? "planetscale" : "default";
				object_exports.property(paramObject, "mode", common_exports.createLiteral(mode));
			}
			drizzleCall.arguments.push(paramObject);
			const db = variables_exports.declaration(ast, "const", "db", drizzleCall);
			exports_exports.namedExport(ast, "db", db);
			return generateCode();
		});
	},
	nextSteps: ({ options: options$6, highlighter, packageManager }) => {
		const steps = [`You will need to set ${highlighter.env("DATABASE_URL")} in your production environment`];
		if (options$6.docker) steps.push(`Run ${highlighter.command(`${packageManager} run db:start`)} to start the docker container`);
else steps.push(`Check ${highlighter.env("DATABASE_URL")} in ${highlighter.path(".env")} and adjust it to your needs`);
		steps.push(`Run ${highlighter.command(`${packageManager} run db:push`)} to update your database schema`);
		return steps;
	}
});
function generateEnvFileContent(content, opts) {
	const DB_URL_KEY = "DATABASE_URL";
	if (opts.docker) {
		const protocol = opts.database === "mysql" ? "mysql" : "postgres";
		const port = PORTS[opts.database];
		content = addEnvVar(content, DB_URL_KEY, `"${protocol}://root:mysecretpassword@localhost:${port}/local"`);
		return content;
	}
	if (opts.sqlite === "better-sqlite3" || opts.sqlite === "libsql") {
		const dbFile = opts.sqlite === "libsql" ? "file:local.db" : "local.db";
		content = addEnvVar(content, DB_URL_KEY, dbFile);
		return content;
	}
	content = addEnvComment(content, "Replace with your DB credentials!");
	if (opts.sqlite === "turso") {
		content = addEnvVar(content, DB_URL_KEY, "\"libsql://db-name-user.turso.io\"");
		content = addEnvVar(content, "DATABASE_AUTH_TOKEN", "\"\"");
		content = addEnvComment(content, "A local DB can also be used in dev as well");
		content = addEnvComment(content, `${DB_URL_KEY}="file:local.db"`);
	}
	if (opts.database === "mysql") content = addEnvVar(content, DB_URL_KEY, "\"mysql://user:password@host:port/db-name\"");
	if (opts.database === "postgresql") content = addEnvVar(content, DB_URL_KEY, "\"postgres://user:password@host:port/db-name\"");
	return content;
}
function addEnvVar(content, key, value) {
	if (!content.includes(key + "=")) content = appendEnvContent(content, `${key}=${value}`);
	return content;
}
function addEnvComment(content, comment) {
	const commented = `# ${comment}`;
	if (!content.includes(commented)) content = appendEnvContent(content, commented);
	return content;
}
function appendEnvContent(existing, content) {
	const withNewLine = !existing.length || existing.endsWith("\n") ? existing : existing + "\n";
	return withNewLine + content + "\n";
}

//#endregion
//#region packages/addons/common.ts
function addEslintConfigPrettier(content) {
	const { ast, generateCode } = parseScript$1(content);
	const importNodes = ast.body.filter((n$1) => n$1.type === "ImportDeclaration");
	const sveltePluginImport = importNodes.find((n$1) => n$1.type === "ImportDeclaration" && n$1.source.value === "eslint-plugin-svelte" && n$1.specifiers?.some((n$2) => n$2.type === "ImportDefaultSpecifier"));
	let svelteImportName;
	for (const specifier of sveltePluginImport?.specifiers ?? []) if (specifier.type === "ImportDefaultSpecifier" && specifier.local?.name) svelteImportName = specifier.local.name;
	svelteImportName ??= "svelte";
	imports_exports.addDefault(ast, "eslint-plugin-svelte", svelteImportName);
	imports_exports.addDefault(ast, "eslint-config-prettier", "prettier");
	const fallbackConfig = common_exports.expressionFromString("[]");
	const defaultExport = exports_exports.defaultExport(ast, fallbackConfig);
	const eslintConfig = defaultExport.value;
	if (eslintConfig.type !== "ArrayExpression" && eslintConfig.type !== "CallExpression") return content;
	const prettier = common_exports.expressionFromString("prettier");
	const sveltePrettierConfig = common_exports.expressionFromString(`${svelteImportName}.configs.prettier`);
	const configSpread = common_exports.createSpreadElement(sveltePrettierConfig);
	const nodesToInsert = [];
	if (!common_exports.hasNode(eslintConfig, prettier)) nodesToInsert.push(prettier);
	if (!common_exports.hasNode(eslintConfig, configSpread)) nodesToInsert.push(configSpread);
	const elements = eslintConfig.type === "ArrayExpression" ? eslintConfig.elements : eslintConfig.arguments;
	const idx = elements.findIndex((el) => el?.type === "SpreadElement" && el.argument.type === "MemberExpression" && el.argument.object.type === "MemberExpression" && el.argument.object.property.type === "Identifier" && el.argument.object.property.name === "configs" && el.argument.object.object.type === "Identifier" && el.argument.object.object.name === svelteImportName);
	if (idx !== -1) elements.splice(idx + 1, 0, ...nodesToInsert);
else elements.push(...nodesToInsert);
	return generateCode();
}
function addToDemoPage(content, path$2) {
	const { template, generateCode } = parseSvelte(content);
	for (const node of template.ast.childNodes) if (node.type === "tag" && node.attribs["href"] === `/demo/${path$2}`) return content;
	const newLine = template.source ? "\n" : "";
	const src = template.source + `${newLine}<a href="/demo/${path$2}">${path$2}</a>`;
	return generateCode({ template: src });
}

//#endregion
//#region packages/addons/eslint/index.ts
var eslint_default = defineAddon({
	id: "eslint",
	shortDescription: "linter",
	homepage: "https://eslint.org",
	options: {},
	run: ({ sv, typescript, dependencyVersion }) => {
		const prettierInstalled = Boolean(dependencyVersion("prettier"));
		sv.devDependency("eslint", "^9.18.0");
		sv.devDependency("@eslint/compat", "^1.2.5");
		sv.devDependency("eslint-plugin-svelte", "^3.0.0");
		sv.devDependency("globals", "^16.0.0");
		sv.devDependency("@eslint/js", "^9.18.0");
		if (typescript) sv.devDependency("typescript-eslint", "^8.20.0");
		if (prettierInstalled) sv.devDependency("eslint-config-prettier", "^10.0.1");
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson$1(content);
			data.scripts ??= {};
			const scripts$1 = data.scripts;
			const LINT_CMD = "eslint .";
			scripts$1["lint"] ??= LINT_CMD;
			if (!scripts$1["lint"].includes(LINT_CMD)) scripts$1["lint"] += ` && ${LINT_CMD}`;
			return generateCode();
		});
		sv.file(".vscode/settings.json", (content) => {
			if (!content) return content;
			const { data, generateCode } = parseJson$1(content);
			const validate$1 = data["eslint.validate"];
			if (validate$1 && !validate$1.includes("svelte")) validate$1.push("svelte");
			return generateCode();
		});
		sv.file("eslint.config.js", (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const eslintConfigs = [];
			imports_exports.addDefault(ast, "./svelte.config.js", "svelteConfig");
			const gitIgnorePathStatement = common_exports.statementFromString("\nconst gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url));");
			common_exports.addStatement(ast, gitIgnorePathStatement);
			const ignoresConfig = common_exports.expressionFromString("includeIgnoreFile(gitignorePath)");
			eslintConfigs.push(ignoresConfig);
			const jsConfig = common_exports.expressionFromString("js.configs.recommended");
			eslintConfigs.push(jsConfig);
			if (typescript) {
				const tsConfig = common_exports.expressionFromString("ts.configs.recommended");
				eslintConfigs.push(common_exports.createSpreadElement(tsConfig));
			}
			const svelteConfig = common_exports.expressionFromString("svelte.configs.recommended");
			eslintConfigs.push(common_exports.createSpreadElement(svelteConfig));
			const globalsBrowser = common_exports.createSpreadElement(common_exports.expressionFromString("globals.browser"));
			const globalsNode = common_exports.createSpreadElement(common_exports.expressionFromString("globals.node"));
			const globalsObjLiteral = object_exports.createEmpty();
			globalsObjLiteral.properties = [globalsBrowser, globalsNode];
			const off = common_exports.createLiteral("off");
			const rules = object_exports.create({ "\"no-undef\"": off });
			if (rules.properties[0].type !== "Property") throw new Error("rules.properties[0].type !== \"Property\"");
			rules.properties[0].key.leadingComments = [{
				type: "Line",
				value: " typescript-eslint strongly recommend that you do not use the no-undef lint rule on TypeScript projects."
			}, {
				type: "Line",
				value: " see: https://typescript-eslint.io/troubleshooting/faqs/eslint/#i-get-errors-from-the-no-undef-rule-about-global-variables-not-being-defined-even-though-there-are-no-typescript-errors"
			}];
			const globalsConfig = object_exports.create({
				languageOptions: object_exports.create({ globals: globalsObjLiteral }),
				rules: typescript ? rules : undefined
			});
			eslintConfigs.push(globalsConfig);
			if (typescript) {
				const svelteTSParserConfig = object_exports.create({
					files: common_exports.expressionFromString("['**/*.svelte', '**/*.svelte.ts', '**/*.svelte.js']"),
					languageOptions: object_exports.create({ parserOptions: object_exports.create({
						projectService: common_exports.expressionFromString("true"),
						extraFileExtensions: common_exports.expressionFromString("['.svelte']"),
						parser: common_exports.expressionFromString("ts.parser"),
						svelteConfig: common_exports.expressionFromString("svelteConfig")
					}) })
				});
				eslintConfigs.push(svelteTSParserConfig);
			} else {
				const svelteTSParserConfig = object_exports.create({
					files: common_exports.expressionFromString("['**/*.svelte', '**/*.svelte.js']"),
					languageOptions: object_exports.create({ parserOptions: object_exports.create({ svelteConfig: common_exports.expressionFromString("svelteConfig") }) })
				});
				eslintConfigs.push(svelteTSParserConfig);
			}
			let exportExpression;
			if (typescript) {
				const tsConfigCall = function_exports.call("ts.config", []);
				tsConfigCall.arguments.push(...eslintConfigs);
				exportExpression = tsConfigCall;
			} else {
				const eslintArray = array_exports.createEmpty();
				eslintConfigs.map((x) => array_exports.push(eslintArray, x));
				exportExpression = eslintArray;
			}
			const defaultExport = exports_exports.defaultExport(ast, exportExpression);
			if (defaultExport.value !== exportExpression) {
				log$1.warn("An eslint config is already defined. Skipping initialization.");
				return content;
			}
			if (!typescript) common_exports.addJsDocTypeComment(defaultExport.astNode, "import('eslint').Linter.Config[]");
			if (typescript) imports_exports.addDefault(ast, "typescript-eslint", "ts");
			imports_exports.addNamed(ast, "node:url", { fileURLToPath: "fileURLToPath" });
			imports_exports.addDefault(ast, "globals", "globals");
			imports_exports.addDefault(ast, "eslint-plugin-svelte", "svelte");
			imports_exports.addNamed(ast, "@eslint/compat", { includeIgnoreFile: "includeIgnoreFile" });
			imports_exports.addDefault(ast, "@eslint/js", "js");
			return generateCode();
		});
		if (prettierInstalled) sv.file("eslint.config.js", addEslintConfigPrettier);
	}
});

//#endregion
//#region packages/addons/sveltekit-adapter/index.ts
const adapters = [
	{
		id: "auto",
		package: "@sveltejs/adapter-auto",
		version: "^6.0.0"
	},
	{
		id: "node",
		package: "@sveltejs/adapter-node",
		version: "^5.2.12"
	},
	{
		id: "static",
		package: "@sveltejs/adapter-static",
		version: "^3.0.8"
	},
	{
		id: "vercel",
		package: "@sveltejs/adapter-vercel",
		version: "^5.6.3"
	},
	{
		id: "cloudflare-pages",
		package: "@sveltejs/adapter-cloudflare",
		version: "^7.0.0"
	},
	{
		id: "netlify",
		package: "@sveltejs/adapter-netlify",
		version: "^5.0.0"
	}
];
const options$4 = defineAddonOptions({ adapter: {
	type: "select",
	question: "Which SvelteKit adapter would you like to use?",
	options: adapters.map((p) => ({
		value: p.id,
		label: p.id,
		hint: p.package
	})),
	default: "auto"
} });
var sveltekit_adapter_default = defineAddon({
	id: "sveltekit-adapter",
	alias: "adapter",
	shortDescription: "deployment",
	homepage: "https://svelte.dev/docs/kit/adapters",
	options: options$4,
	setup: ({ kit, unsupported }) => {
		if (!kit) unsupported("Requires SvelteKit");
	},
	run: ({ sv, options: options$6 }) => {
		const adapter = adapters.find((a) => a.id === options$6.adapter);
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson$1(content);
			const devDeps = data["devDependencies"];
			for (const pkg of Object.keys(devDeps)) if (pkg.startsWith("@sveltejs/adapter-")) delete devDeps[pkg];
			return generateCode();
		});
		sv.devDependency(adapter.package, adapter.version);
		sv.file("svelte.config.js", (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const importDecls = ast.body.filter((n$1) => n$1.type === "ImportDeclaration");
			const adapterImportDecl = importDecls.find((importDecl) => typeof importDecl.source.value === "string" && importDecl.source.value.startsWith("@sveltejs/adapter-") && importDecl.importKind === "value");
			let adapterName = "adapter";
			if (adapterImportDecl) {
				adapterImportDecl.source.value = adapter.package;
				adapterImportDecl.source.raw = undefined;
				adapterName = adapterImportDecl.specifiers?.find((s$1) => s$1.type === "ImportDefaultSpecifier")?.local?.name;
			} else imports_exports.addDefault(ast, adapter.package, adapterName);
			const { value: config } = exports_exports.defaultExport(ast, object_exports.createEmpty());
			const kitConfig = config.properties.find((p) => p.type === "Property" && p.key.type === "Identifier" && p.key.name === "kit");
			if (kitConfig && kitConfig.value.type === "ObjectExpression") {
				const adapterProp = kitConfig.value.properties.find((p) => p.type === "Property" && p.key.type === "Identifier" && p.key.name === "adapter");
				if (adapterProp) adapterProp.leadingComments = [];
				object_exports.overrideProperties(kitConfig.value, { adapter: function_exports.callByIdentifier(adapterName, []) });
			} else object_exports.properties(config, { kit: object_exports.create({ adapter: function_exports.callByIdentifier(adapterName, []) }) });
			return generateCode();
		});
	}
});

//#endregion
//#region node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
const comma = ",".charCodeAt(0);
const semicolon = ";".charCodeAt(0);
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar = new Uint8Array(64);
const charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
	const c = chars.charCodeAt(i);
	intToChar[i] = c;
	charToInt[c] = i;
}
function encodeInteger(builder, num, relative) {
	let delta = num - relative;
	delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
	do {
		let clamped = delta & 31;
		delta >>>= 5;
		if (delta > 0) clamped |= 32;
		builder.write(intToChar[clamped]);
	} while (delta > 0);
	return num;
}
const bufLength = 16384;
const td = typeof TextDecoder !== "undefined" ? /* #__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? { decode(buf) {
	const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
	return out.toString();
} } : { decode(buf) {
	let out = "";
	for (let i = 0; i < buf.length; i++) out += String.fromCharCode(buf[i]);
	return out;
} };
var StringWriter = class {
	constructor() {
		this.pos = 0;
		this.out = "";
		this.buffer = new Uint8Array(bufLength);
	}
	write(v) {
		const { buffer } = this;
		buffer[this.pos++] = v;
		if (this.pos === bufLength) {
			this.out += td.decode(buffer);
			this.pos = 0;
		}
	}
	flush() {
		const { buffer, out, pos } = this;
		return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
	}
};
function encode(decoded) {
	const writer = new StringWriter();
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	for (let i = 0; i < decoded.length; i++) {
		const line = decoded[i];
		if (i > 0) writer.write(semicolon);
		if (line.length === 0) continue;
		let genColumn = 0;
		for (let j = 0; j < line.length; j++) {
			const segment = line[j];
			if (j > 0) writer.write(comma);
			genColumn = encodeInteger(writer, segment[0], genColumn);
			if (segment.length === 1) continue;
			sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
			sourceLine = encodeInteger(writer, segment[2], sourceLine);
			sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
			if (segment.length === 4) continue;
			namesIndex = encodeInteger(writer, segment[4], namesIndex);
		}
	}
	return writer.flush();
}

//#endregion
//#region node_modules/.pnpm/magic-string@0.30.17/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}
	add(n$1) {
		this.bits[n$1 >> 5] |= 1 << (n$1 & 31);
	}
	has(n$1) {
		return !!(this.bits[n$1 >> 5] & 1 << (n$1 & 31));
	}
};
var Chunk = class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;
		this.intro = "";
		this.outro = "";
		this.content = content;
		this.storeName = false;
		this.edited = false;
		{
			this.previous = null;
			this.next = null;
		}
	}
	appendLeft(content) {
		this.outro += content;
	}
	appendRight(content) {
		this.intro = this.intro + content;
	}
	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);
		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;
		return chunk;
	}
	contains(index) {
		return this.start < index && index < this.end;
	}
	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}
	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}
	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = "";
			this.outro = "";
		}
		this.storeName = storeName;
		this.edited = true;
		return this;
	}
	prependLeft(content) {
		this.outro = content + this.outro;
	}
	prependRight(content) {
		this.intro = content + this.intro;
	}
	reset() {
		this.intro = "";
		this.outro = "";
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}
	split(index) {
		const sliceIndex = index - this.start;
		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);
		this.original = originalBefore;
		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = "";
		this.end = index;
		if (this.edited) {
			newChunk.edit("", false);
			this.content = "";
		} else this.content = originalBefore;
		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;
		return newChunk;
	}
	toString() {
		return this.intro + this.content + this.outro;
	}
	trimEnd(rx) {
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit("", undefined, true);
				if (this.edited) this.edit(trimmed, this.storeName, true);
			}
			return true;
		} else {
			this.edit("", undefined, true);
			this.intro = this.intro.replace(rx, "");
			if (this.intro.length) return true;
		}
	}
	trimStart(rx) {
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) newChunk.edit(trimmed, this.storeName, true);
				this.edit("", undefined, true);
			}
			return true;
		} else {
			this.edit("", undefined, true);
			this.outro = this.outro.replace(rx, "");
			if (this.outro.length) return true;
		}
	}
};
function getBtoa() {
	if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
else if (typeof Buffer === "function") return (str) => Buffer.from(str, "utf-8").toString("base64");
else return () => {
		throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
	};
}
const btoa = /*#__PURE__*/ getBtoa();
var SourceMap = class {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
		if (typeof properties.debugId !== "undefined") this.debugId = properties.debugId;
	}
	toString() {
		return JSON.stringify(this);
	}
	toUrl() {
		return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
	}
};
function guessIndent(code) {
	const lines = code.split("\n");
	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));
	if (tabbed.length === 0 && spaced.length === 0) return null;
	if (tabbed.length >= spaced.length) return "	";
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);
	return new Array(min + 1).join(" ");
}
function getRelativePath(from$2, to) {
	const fromParts = from$2.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);
	fromParts.pop();
	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}
	if (fromParts.length) {
		let i = fromParts.length;
		while (i--) fromParts[i] = "..";
	}
	return fromParts.concat(toParts).join("/");
}
const toString$1 = Object.prototype.toString;
function isObject(thing) {
	return toString$1.call(thing) === "[object Object]";
}
function getLocator(source) {
	const originalLines = source.split("\n");
	const lineOffsets = [];
	for (let i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}
	return function locate(index) {
		let i = 0;
		let j = lineOffsets.length;
		while (i < j) {
			const m = i + j >> 1;
			if (index < lineOffsets[m]) j = m;
else i = m + 1;
		}
		const line = i - 1;
		const column = index - lineOffsets[line];
		return {
			line,
			column
		};
	};
}
const wordRegex = /\w/;
var Mappings = class {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}
	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf("\n", 0);
			let previousContentLineEnd = -1;
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment$1 = [
					this.generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column
				];
				if (nameIndex >= 0) segment$1.push(nameIndex);
				this.rawSegments.push(segment$1);
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
			}
			const segment = [
				this.generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column
			];
			if (nameIndex >= 0) segment.push(nameIndex);
			this.rawSegments.push(segment);
			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}
		this.pending = null;
	}
	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		let charInHiresBoundary = false;
		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === "\n") {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [
						this.generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column
					];
					if (this.hires === "boundary") if (wordRegex.test(original[originalCharIndex])) {
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
else this.rawSegments.push(segment);
				}
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}
			originalCharIndex += 1;
		}
		this.pending = null;
	}
	advance(str) {
		if (!str) return;
		const lines = str.split("\n");
		if (lines.length > 1) {
			for (let i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}
		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
};
const n = "\n";
const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};
var MagicString = class MagicString {
	constructor(string$1, options$6 = {}) {
		const chunk = new Chunk(0, string$1.length, string$1);
		Object.defineProperties(this, {
			original: {
				writable: true,
				value: string$1
			},
			outro: {
				writable: true,
				value: ""
			},
			intro: {
				writable: true,
				value: ""
			},
			firstChunk: {
				writable: true,
				value: chunk
			},
			lastChunk: {
				writable: true,
				value: chunk
			},
			lastSearchedChunk: {
				writable: true,
				value: chunk
			},
			byStart: {
				writable: true,
				value: {}
			},
			byEnd: {
				writable: true,
				value: {}
			},
			filename: {
				writable: true,
				value: options$6.filename
			},
			indentExclusionRanges: {
				writable: true,
				value: options$6.indentExclusionRanges
			},
			sourcemapLocations: {
				writable: true,
				value: new BitSet()
			},
			storedNames: {
				writable: true,
				value: {}
			},
			indentStr: {
				writable: true,
				value: undefined
			},
			ignoreList: {
				writable: true,
				value: options$6.ignoreList
			},
			offset: {
				writable: true,
				value: options$6.offset || 0
			}
		});
		this.byStart[0] = chunk;
		this.byEnd[string$1.length] = chunk;
	}
	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}
	append(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.outro += content;
		return this;
	}
	appendLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.appendLeft(content);
else this.intro += content;
		return this;
	}
	appendRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.appendRight(content);
else this.outro += content;
		return this;
	}
	clone() {
		const cloned = new MagicString(this.original, {
			filename: this.filename,
			offset: this.offset
		});
		let originalChunk = this.firstChunk;
		let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;
			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;
				clonedChunk = nextClonedChunk;
			}
			originalChunk = nextOriginalChunk;
		}
		cloned.lastChunk = clonedChunk;
		if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
		cloned.intro = this.intro;
		cloned.outro = this.outro;
		return cloned;
	}
	generateDecodedMap(options$6) {
		options$6 = options$6 || {};
		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options$6.hires);
		const locate = getLocator(this.original);
		if (this.intro) mappings.advance(this.intro);
		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);
			if (chunk.intro.length) mappings.advance(chunk.intro);
			if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			if (chunk.outro.length) mappings.advance(chunk.outro);
		});
		return {
			file: options$6.file ? options$6.file.split(/[/\\]/).pop() : undefined,
			sources: [options$6.source ? getRelativePath(options$6.file || "", options$6.source) : options$6.file || ""],
			sourcesContent: options$6.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined
		};
	}
	generateMap(options$6) {
		return new SourceMap(this.generateDecodedMap(options$6));
	}
	_ensureindentStr() {
		if (this.indentStr === undefined) this.indentStr = guessIndent(this.original);
	}
	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}
	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? "	" : this.indentStr;
	}
	indent(indentStr, options$6) {
		const pattern = /^[^\r\n]/gm;
		if (isObject(indentStr)) {
			options$6 = indentStr;
			indentStr = undefined;
		}
		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || "	";
		}
		if (indentStr === "") return this;
		options$6 = options$6 || {};
		const isExcluded = {};
		if (options$6.exclude) {
			const exclusions = typeof options$6.exclude[0] === "number" ? [options$6.exclude] : options$6.exclude;
			exclusions.forEach((exclusion) => {
				for (let i = exclusion[0]; i < exclusion[1]; i += 1) isExcluded[i] = true;
			});
		}
		let shouldIndentNextCharacter = options$6.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};
		this.intro = this.intro.replace(pattern, replacer);
		let charIndex = 0;
		let chunk = this.firstChunk;
		while (chunk) {
			const end = chunk.end;
			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);
					if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
				}
			} else {
				charIndex = chunk.start;
				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];
						if (char === "\n") shouldIndentNextCharacter = true;
else if (char !== "\r" && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;
							if (charIndex === chunk.start) chunk.prependRight(indentStr);
else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}
					charIndex += 1;
				}
			}
			charIndex = chunk.end;
			chunk = chunk.next;
		}
		this.outro = this.outro.replace(pattern, replacer);
		return this;
	}
	insert() {
		throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
	}
	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
			warned.insertLeft = true;
		}
		return this.appendLeft(index, content);
	}
	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
			warned.insertRight = true;
		}
		return this.prependRight(index, content);
	}
	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;
		if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
		this._split(start);
		this._split(end);
		this._split(index);
		const first = this.byStart[start];
		const last = this.byEnd[end];
		const oldLeft = first.previous;
		const oldRight = last.next;
		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;
		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;
		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;
		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}
		first.previous = newLeft;
		last.next = newRight || null;
		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}
	overwrite(start, end, content, options$6) {
		options$6 = options$6 || {};
		return this.update(start, end, content, {
			...options$6,
			overwrite: !options$6.contentOnly
		});
	}
	update(start, end, content, options$6) {
		start = start + this.offset;
		end = end + this.offset;
		if (typeof content !== "string") throw new TypeError("replacement content must be a string");
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (end > this.original.length) throw new Error("end is out of bounds");
		if (start === end) throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
		this._split(start);
		this._split(end);
		if (options$6 === true) {
			if (!warned.storeName) {
				console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
				warned.storeName = true;
			}
			options$6 = { storeName: true };
		}
		const storeName = options$6 !== undefined ? options$6.storeName : false;
		const overwrite = options$6 !== undefined ? options$6.overwrite : false;
		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true
			});
		}
		const first = this.byStart[start];
		const last = this.byEnd[end];
		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
				chunk = chunk.next;
				chunk.edit("", false);
			}
			first.edit(content, storeName, !overwrite);
		} else {
			const newChunk = new Chunk(start, end, "").edit(content, storeName);
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}
	prepend(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.intro = content + this.intro;
		return this;
	}
	prependLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.prependLeft(content);
else this.intro = content + this.intro;
		return this;
	}
	prependRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.prependRight(content);
else this.outro = content + this.outro;
		return this;
	}
	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.intro = "";
			chunk.outro = "";
			chunk.edit("");
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.reset();
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while (chunk = chunk.previous);
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return "";
	}
	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}
			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}
			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while (chunk = chunk.previous);
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}
	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		let result = "";
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			if (chunk.start < end && chunk.end >= end) return result;
			chunk = chunk.next;
		}
		if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
			result += chunk.content.slice(sliceStart, sliceEnd);
			if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
			if (containsEnd) break;
			chunk = chunk.next;
		}
		return result;
	}
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);
		return clone;
	}
	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;
		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;
		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);
			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}
	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			const loc = getLocator(this.original)(index);
			throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`);
		}
		const newChunk = chunk.split(index);
		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;
		if (chunk === this.lastChunk) this.lastChunk = newChunk;
		this.lastSearchedChunk = chunk;
		return true;
	}
	toString() {
		let str = this.intro;
		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}
		return str + this.outro;
	}
	isEmpty() {
		let chunk = this.firstChunk;
		do 
			if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
		while (chunk = chunk.next);
		return true;
	}
	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do 
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		while (chunk = chunk.next);
		return length;
	}
	trimLines() {
		return this.trim("[\\r\\n]");
	}
	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}
	trimEndAborted(charType) {
		const rx = new RegExp((charType || "\\s") + "+$");
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		let chunk = this.lastChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);
		return false;
	}
	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp("^" + (charType || "\\s") + "+");
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		let chunk = this.firstChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);
			if (chunk.end !== end) {
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);
		return false;
	}
	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}
	hasChanged() {
		return this.original !== this.toString();
	}
	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
				if (i === "$") return "$";
				if (i === "&") return match[0];
				const num = +i;
				if (num < match.length) return match[+i];
				return `$${i}`;
			});
else return replacement(...match, match.index, str, match.groups);
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while (match = re.exec(str)) matches.push(match);
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement$1 = getReplacement(match, this.original);
					if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		}
		return this;
	}
	_replaceString(string$1, replacement) {
		const { original } = this;
		const index = original.indexOf(string$1);
		if (index !== -1) this.overwrite(index, index + string$1.length, replacement);
		return this;
	}
	replace(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceString(searchValue, replacement);
		return this._replaceRegexp(searchValue, replacement);
	}
	_replaceAllString(string$1, replacement) {
		const { original } = this;
		const stringLength = string$1.length;
		for (let index = original.indexOf(string$1); index !== -1; index = original.indexOf(string$1, index + stringLength)) {
			const previous = original.slice(index, index + stringLength);
			if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
		}
		return this;
	}
	replaceAll(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceAllString(searchValue, replacement);
		if (!searchValue.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
		return this._replaceRegexp(searchValue, replacement);
	}
};

//#endregion
//#region packages/addons/lucia/index.ts
const TABLE_TYPE = {
	mysql: "mysqlTable",
	postgresql: "pgTable",
	sqlite: "sqliteTable",
	turso: "sqliteTable"
};
let drizzleDialect;
let schemaPath;
const options$3 = defineAddonOptions({ demo: {
	type: "boolean",
	default: true,
	question: `Do you want to include a demo? ${colors.dim("(includes a login/register page)")}`
} });
var lucia_default = defineAddon({
	id: "lucia",
	shortDescription: "auth guide",
	homepage: "https://lucia-auth.com",
	options: options$3,
	setup: ({ kit, dependencyVersion, unsupported, dependsOn }) => {
		if (!kit) unsupported("Requires SvelteKit");
		if (!dependencyVersion("drizzle-orm")) dependsOn("drizzle");
	},
	run: ({ sv, typescript, options: options$6, kit, dependencyVersion }) => {
		const ext = typescript ? "ts" : "js";
		sv.dependency("@oslojs/crypto", "^1.0.1");
		sv.dependency("@oslojs/encoding", "^1.1.0");
		if (options$6.demo) sv.dependency("@node-rs/argon2", "^2.0.2");
		sv.file(`drizzle.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const isProp = (name$1, node) => node.key.type === "Identifier" && node.key.name === name$1;
			walk_exports.walk(ast, null, { Property(node) {
				if (isProp("dialect", node) && node.value.type === "Literal" && typeof node.value.value === "string") drizzleDialect = node.value.value;
				if (isProp("schema", node) && node.value.type === "Literal" && typeof node.value.value === "string") schemaPath = node.value.value;
			} });
			if (!drizzleDialect) throw new Error("Failed to detect DB dialect in your `drizzle.config.[js|ts]` file");
			if (!schemaPath) throw new Error("Failed to find schema path in your `drizzle.config.[js|ts]` file");
			return generateCode();
		});
		sv.file(schemaPath, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const createTable = (name$1) => function_exports.call(TABLE_TYPE[drizzleDialect], [name$1]);
			const userDecl = variables_exports.declaration(ast, "const", "user", createTable("user"));
			const sessionDecl = variables_exports.declaration(ast, "const", "session", createTable("session"));
			const user = exports_exports.namedExport(ast, "user", userDecl);
			const session = exports_exports.namedExport(ast, "session", sessionDecl);
			const userTable = getCallExpression(user);
			const sessionTable = getCallExpression(session);
			if (!userTable || !sessionTable) throw new Error("failed to find call expression of `user` or `session`");
			if (userTable.arguments.length === 1) userTable.arguments.push(object_exports.createEmpty());
			if (sessionTable.arguments.length === 1) sessionTable.arguments.push(object_exports.createEmpty());
			const userAttributes = userTable.arguments[1];
			const sessionAttributes = sessionTable.arguments[1];
			if (userAttributes?.type !== "ObjectExpression" || sessionAttributes?.type !== "ObjectExpression") throw new Error("unexpected shape of `user` or `session` table definition");
			if (drizzleDialect === "sqlite" || drizzleDialect === "turso") {
				imports_exports.addNamed(ast, "drizzle-orm/sqlite-core", {
					sqliteTable: "sqliteTable",
					text: "text",
					integer: "integer"
				});
				object_exports.overrideProperties(userAttributes, { id: common_exports.expressionFromString("text('id').primaryKey()") });
				if (options$6.demo) object_exports.overrideProperties(userAttributes, {
					username: common_exports.expressionFromString("text('username').notNull().unique()"),
					passwordHash: common_exports.expressionFromString("text('password_hash').notNull()")
				});
				object_exports.overrideProperties(sessionAttributes, {
					id: common_exports.expressionFromString("text('id').primaryKey()"),
					userId: common_exports.expressionFromString("text('user_id').notNull().references(() => user.id)"),
					expiresAt: common_exports.expressionFromString("integer('expires_at', { mode: 'timestamp' }).notNull()")
				});
			}
			if (drizzleDialect === "mysql") {
				imports_exports.addNamed(ast, "drizzle-orm/mysql-core", {
					mysqlTable: "mysqlTable",
					varchar: "varchar",
					datetime: "datetime"
				});
				object_exports.overrideProperties(userAttributes, { id: common_exports.expressionFromString("varchar('id', { length: 255 }).primaryKey()") });
				if (options$6.demo) object_exports.overrideProperties(userAttributes, {
					username: common_exports.expressionFromString("varchar('username', { length: 32 }).notNull().unique()"),
					passwordHash: common_exports.expressionFromString("varchar('password_hash', { length: 255 }).notNull()")
				});
				object_exports.overrideProperties(sessionAttributes, {
					id: common_exports.expressionFromString("varchar('id', { length: 255 }).primaryKey()"),
					userId: common_exports.expressionFromString("varchar('user_id', { length: 255 }).notNull().references(() => user.id)"),
					expiresAt: common_exports.expressionFromString("datetime('expires_at').notNull()")
				});
			}
			if (drizzleDialect === "postgresql") {
				imports_exports.addNamed(ast, "drizzle-orm/pg-core", {
					pgTable: "pgTable",
					text: "text",
					timestamp: "timestamp"
				});
				object_exports.overrideProperties(userAttributes, { id: common_exports.expressionFromString("text('id').primaryKey()") });
				if (options$6.demo) object_exports.overrideProperties(userAttributes, {
					username: common_exports.expressionFromString("text('username').notNull().unique()"),
					passwordHash: common_exports.expressionFromString("text('password_hash').notNull()")
				});
				object_exports.overrideProperties(sessionAttributes, {
					id: common_exports.expressionFromString("text('id').primaryKey()"),
					userId: common_exports.expressionFromString("text('user_id').notNull().references(() => user.id)"),
					expiresAt: common_exports.expressionFromString("timestamp('expires_at', { withTimezone: true, mode: 'date' }).notNull()")
				});
			}
			let code = generateCode();
			if (typescript) {
				if (!code.includes("export type Session =")) code += "\n\nexport type Session = typeof session.$inferSelect;";
				if (!code.includes("export type User =")) code += "\n\nexport type User = typeof user.$inferSelect;";
			}
			return code;
		});
		sv.file(`${kit?.libDirectory}/server/auth.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamespace(ast, "$lib/server/db/schema", "table");
			imports_exports.addNamed(ast, "$lib/server/db", { db: "db" });
			imports_exports.addNamed(ast, "@oslojs/encoding", {
				encodeBase64url: "encodeBase64url",
				encodeHexLowerCase: "encodeHexLowerCase"
			});
			imports_exports.addNamed(ast, "@oslojs/crypto/sha2", { sha256: "sha256" });
			imports_exports.addNamed(ast, "drizzle-orm", { eq: "eq" });
			if (typescript) imports_exports.addNamed(ast, "@sveltejs/kit", { RequestEvent: "RequestEvent" }, true);
			const ms = new MagicString(generateCode().trim());
			const [ts] = utils_exports.createPrinter(typescript);
			if (!ms.original.includes("const DAY_IN_MS")) ms.append("\n\nconst DAY_IN_MS = 1000 * 60 * 60 * 24;");
			if (!ms.original.includes("export const sessionCookieName")) ms.append("\n\nexport const sessionCookieName = 'auth-session';");
			if (!ms.original.includes("export function generateSessionToken")) {
				const generateSessionToken = dedent_default`					
					export function generateSessionToken() {
						const bytes = crypto.getRandomValues(new Uint8Array(18));
						const token = encodeBase64url(bytes);
						return token;
					}`;
				ms.append(`\n\n${generateSessionToken}`);
			}
			if (!ms.original.includes("async function createSession")) {
				const createSession = dedent_default`
					${ts("", "/**")}
					${ts("", " * @param {string} token")}
					${ts("", " * @param {string} userId")}
					${ts("", " */")}
					export async function createSession(token${ts(": string")}, userId${ts(": string")}) {
						const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
						const session${ts(": table.Session")} = {
							id: sessionId,
							userId,
							expiresAt: new Date(Date.now() + DAY_IN_MS * 30)
						};
						await db.insert(table.session).values(session);
						return session;
					}`;
				ms.append(`\n\n${createSession}`);
			}
			if (!ms.original.includes("async function validateSessionToken")) {
				const validateSessionToken = dedent_default`					
					${ts("", "/** @param {string} token */")}
					export async function validateSessionToken(token${ts(": string")}) {
						const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
						const [result] = await db
							.select({
								// Adjust user table here to tweak returned data
								user: { id: table.user.id, username: table.user.username },
								session: table.session
							})
							.from(table.session)
							.innerJoin(table.user, eq(table.session.userId, table.user.id))
							.where(eq(table.session.id, sessionId));

						if (!result) {
							return { session: null, user: null };
						}
						const { session, user } = result;

						const sessionExpired = Date.now() >= session.expiresAt.getTime();
						if (sessionExpired) {
							await db.delete(table.session).where(eq(table.session.id, session.id));
							return { session: null, user: null };
						}

						const renewSession = Date.now() >= session.expiresAt.getTime() - DAY_IN_MS * 15;
						if (renewSession) {
							session.expiresAt = new Date(Date.now() + DAY_IN_MS * 30);
							await db
								.update(table.session)
								.set({ expiresAt: session.expiresAt })
								.where(eq(table.session.id, session.id));
						}

						return { session, user };
					}`;
				ms.append(`\n\n${validateSessionToken}`);
			}
			if (typescript && !ms.original.includes("export type SessionValidationResult")) {
				const sessionType = "export type SessionValidationResult = Awaited<ReturnType<typeof validateSessionToken>>;";
				ms.append(`\n\n${sessionType}`);
			}
			if (!ms.original.includes("async function invalidateSession")) {
				const invalidateSession = dedent_default`					
					${ts("", "/** @param {string} sessionId */")}
					export async function invalidateSession(sessionId${ts(": string")}) {
						await db.delete(table.session).where(eq(table.session.id, sessionId));
					}`;
				ms.append(`\n\n${invalidateSession}`);
			}
			if (!ms.original.includes("export function setSessionTokenCookie")) {
				const setSessionTokenCookie = dedent_default`					
					${ts("", "/**")}
					${ts("", " * @param {import(\"@sveltejs/kit\").RequestEvent} event")}
					${ts("", " * @param {string} token")}
					${ts("", " * @param {Date} expiresAt")}
					${ts("", " */")}
					export function setSessionTokenCookie(event${ts(": RequestEvent")}, token${ts(": string")}, expiresAt${ts(": Date")}) {
						event.cookies.set(sessionCookieName, token, {
							expires: expiresAt,
							path: '/'
						});
					}`;
				ms.append(`\n\n${setSessionTokenCookie}`);
			}
			if (!ms.original.includes("export function deleteSessionTokenCookie")) {
				const deleteSessionTokenCookie = dedent_default`					
					${ts("", "/** @param {import(\"@sveltejs/kit\").RequestEvent} event */")}
					export function deleteSessionTokenCookie(event${ts(": RequestEvent")}) {
						event.cookies.delete(sessionCookieName, {
							path: '/'
						});
					}`;
				ms.append(`\n\n${deleteSessionTokenCookie}`);
			}
			return ms.toString();
		});
		if (typescript) sv.file("src/app.d.ts", (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const locals = kit_exports.addGlobalAppInterface(ast, "Locals");
			if (!locals) throw new Error("Failed detecting `locals` interface in `src/app.d.ts`");
			const user = locals.body.body.find((prop) => common_exports.hasTypeProp("user", prop));
			const session = locals.body.body.find((prop) => common_exports.hasTypeProp("session", prop));
			if (!user) locals.body.body.push(createLuciaType("user"));
			if (!session) locals.body.body.push(createLuciaType("session"));
			return generateCode();
		});
		sv.file(`src/hooks.server.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamespace(ast, "$lib/server/auth.js", "auth");
			kit_exports.addHooksHandle(ast, typescript, "handleAuth", getAuthHandleContent());
			return generateCode();
		});
		if (options$6.demo) {
			sv.file(`${kit?.routesDirectory}/demo/+page.svelte`, (content) => {
				return addToDemoPage(content, "lucia");
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/login/+page.server.${ext}`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/login/+page.server.${typescript ? "ts" : "js"}`;
					log$1.warn(`Existing ${colors.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const [ts] = utils_exports.createPrinter(typescript);
				return dedent_default`
					import { hash, verify } from '@node-rs/argon2';
					import { encodeBase32LowerCase } from '@oslojs/encoding';
					import { fail, redirect } from '@sveltejs/kit';
					import { eq } from 'drizzle-orm';
					import * as auth from '$lib/server/auth';
					import { db } from '$lib/server/db';
					import * as table from '$lib/server/db/schema';
					${ts("import type { Actions, PageServerLoad } from './$types';\n")}
					export const load${ts(": PageServerLoad")} = async (event) => {
						if (event.locals.user) {
							return redirect(302, '/demo/lucia');
						}
						return {};
					};

					export const actions${ts(": Actions")} = {
						login: async (event) => {
							const formData = await event.request.formData();
							const username = formData.get('username');
							const password = formData.get('password');

							if (!validateUsername(username)) {
								return fail(400, { message: 'Invalid username (min 3, max 31 characters, alphanumeric only)' });
							}
							if (!validatePassword(password)) {
								return fail(400, { message: 'Invalid password (min 6, max 255 characters)' });
							}

							const results = await db
								.select()
								.from(table.user)
								.where(eq(table.user.username, username));

							const existingUser = results.at(0);
							if (!existingUser) {
								return fail(400, { message: 'Incorrect username or password' });
							}

							const validPassword = await verify(existingUser.passwordHash, password, {
								memoryCost: 19456,
								timeCost: 2,
								outputLen: 32,
								parallelism: 1,
							});
							if (!validPassword) {
								return fail(400, { message: 'Incorrect username or password' });
							}

							const sessionToken = auth.generateSessionToken();
							const session = await auth.createSession(sessionToken, existingUser.id);
							auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);

							return redirect(302, '/demo/lucia');
						},
						register: async (event) => {
							const formData = await event.request.formData();
							const username = formData.get('username');
							const password = formData.get('password');

							if (!validateUsername(username)) {
								return fail(400, { message: 'Invalid username' });
							}
							if (!validatePassword(password)) {
								return fail(400, { message: 'Invalid password' });
							}

							const userId = generateUserId();
							const passwordHash = await hash(password, {
								// recommended minimum parameters
								memoryCost: 19456,
								timeCost: 2,
								outputLen: 32,
								parallelism: 1,
							});

							try {
								await db.insert(table.user).values({ id: userId, username, passwordHash });

								const sessionToken = auth.generateSessionToken();
								const session = await auth.createSession(sessionToken, userId);
								auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);
							} catch (e) {
								return fail(500, { message: 'An error has occurred' });
							}
							return redirect(302, '/demo/lucia');
						},
					};

					function generateUserId() {
						// ID with 120 bits of entropy, or about the same as UUID v4.
						const bytes = crypto.getRandomValues(new Uint8Array(15));
						const id = encodeBase32LowerCase(bytes);
						return id;
					}

					function validateUsername(username${ts(": unknown")})${ts(": username is string")} {
						return (
							typeof username === 'string' &&
							username.length >= 3 &&
							username.length <= 31 &&
							/^[a-z0-9_-]+$/.test(username)
						);
					}

					function validatePassword(password${ts(": unknown")})${ts(": password is string")} {
						return (
							typeof password === 'string' &&
							password.length >= 6 &&
							password.length <= 255
						);
					}
				`;
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/login/+page.svelte`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/login/+page.svelte`;
					log$1.warn(`Existing ${colors.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const svelte5 = !!dependencyVersion("svelte")?.startsWith("5");
				const [ts, s5] = utils_exports.createPrinter(typescript, svelte5);
				return dedent_default`
					<script ${ts("lang='ts'")}>
						import { enhance } from '$app/forms';
						${ts("import type { ActionData } from './$types';\n")}
						${s5(`let { form }${ts(": { form: ActionData }")} = $props();`, `export let form${ts(": ActionData")};`)}
					</script>

					<h1>Login/Register</h1>
					<form method='post' action='?/login' use:enhance>
						<label>
							Username
							<input name='username' />
						</label>
						<label>
							Password
							<input type='password' name='password' />
						</label>
						<button>Login</button>
						<button formaction='?/register'>Register</button>
					</form>
					<p style='color: red'>{form?.message ?? ''}</p>
				`;
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/+page.server.${ext}`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/+page.server.${typescript ? "ts" : "js"}`;
					log$1.warn(`Existing ${colors.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const [ts] = utils_exports.createPrinter(typescript);
				return dedent_default`
					import * as auth from '$lib/server/auth';
					import { fail, redirect } from '@sveltejs/kit';
					${ts("import type { Actions, PageServerLoad } from './$types';\n")}
					export const load${ts(": PageServerLoad")} = async (event) => {
						if (!event.locals.user) {
							return redirect(302, '/demo/lucia/login');
						}
						return { user: event.locals.user };
					};

					export const actions${ts(": Actions")} = {
						logout: async (event) => {
							if (!event.locals.session) {
								return fail(401);
							}
							await auth.invalidateSession(event.locals.session.id);
							auth.deleteSessionTokenCookie(event);

							return redirect(302, '/demo/lucia/login');
						},
					};
				`;
			});
			sv.file(`${kit.routesDirectory}/demo/lucia/+page.svelte`, (content) => {
				if (content) {
					const filePath = `${kit.routesDirectory}/demo/lucia/+page.svelte`;
					log$1.warn(`Existing ${colors.yellow(filePath)} file. Could not update.`);
					return content;
				}
				const svelte5 = !!dependencyVersion("svelte")?.startsWith("5");
				const [ts, s5] = utils_exports.createPrinter(typescript, svelte5);
				return dedent_default`
					<script ${ts("lang='ts'")}>
						import { enhance } from '$app/forms';
						${ts("import type { PageServerData } from './$types';\n")}
						${s5(`let { data }${ts(": { data: PageServerData }")} = $props();`, `export let data${ts(": PageServerData")};`)}
					</script>

					<h1>Hi, {data.user.username}!</h1>
					<p>Your user ID is {data.user.id}.</p>
					<form method='post' action='?/logout' use:enhance>
						<button>Sign out</button>
					</form>
				`;
			});
		}
	},
	nextSteps: ({ highlighter, options: options$6, packageManager }) => {
		const steps = [`Run ${highlighter.command(`${packageManager} run db:push`)} to update your database schema`];
		if (options$6.demo) steps.push(`Visit ${highlighter.route("/demo/lucia")} route to view the demo`);
		return steps;
	}
});
function createLuciaType(name$1) {
	return {
		type: "TSPropertySignature",
		key: {
			type: "Identifier",
			name: name$1
		},
		computed: false,
		typeAnnotation: {
			type: "TSTypeAnnotation",
			typeAnnotation: {
				type: "TSIndexedAccessType",
				objectType: {
					type: "TSImportType",
					argument: {
						type: "Literal",
						value: "$lib/server/auth"
					},
					qualifier: {
						type: "Identifier",
						name: "SessionValidationResult"
					}
				},
				indexType: {
					type: "TSLiteralType",
					literal: {
						type: "Literal",
						value: name$1
					}
				}
			}
		}
	};
}
function getAuthHandleContent() {
	return `
		async ({ event, resolve }) => {
			const sessionToken = event.cookies.get(auth.sessionCookieName);
			if (!sessionToken) {
				event.locals.user = null;
				event.locals.session = null;
				return resolve(event);
			}

			const { session, user } = await auth.validateSessionToken(sessionToken);
			if (session) {
				auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);
			} else {
				auth.deleteSessionTokenCookie(event);
			}

			event.locals.user = user;
			event.locals.session = session;

			return resolve(event);
		};`;
}
function getCallExpression(ast) {
	let callExpression;
	walk_exports.walk(ast, null, { CallExpression(node) {
		callExpression ??= node;
	} });
	return callExpression;
}

//#endregion
//#region packages/addons/mdsvex/index.ts
var mdsvex_default = defineAddon({
	id: "mdsvex",
	shortDescription: "svelte + markdown",
	homepage: "https://mdsvex.pngwn.io",
	options: {},
	run: ({ sv }) => {
		sv.devDependency("mdsvex", "^0.12.3");
		sv.file("svelte.config.js", (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamed(ast, "mdsvex", { mdsvex: "mdsvex" });
			const { value: exportDefault } = exports_exports.defaultExport(ast, object_exports.createEmpty());
			let preprocessorArray = object_exports.property(exportDefault, "preprocess", array_exports.createEmpty());
			const isArray = preprocessorArray.type === "ArrayExpression";
			if (!isArray) {
				const previousElement = preprocessorArray;
				preprocessorArray = array_exports.createEmpty();
				array_exports.push(preprocessorArray, previousElement);
				object_exports.overrideProperty(exportDefault, "preprocess", preprocessorArray);
			}
			const mdsvexCall = function_exports.call("mdsvex", []);
			array_exports.push(preprocessorArray, mdsvexCall);
			const extensionsArray = object_exports.property(exportDefault, "extensions", array_exports.createEmpty());
			array_exports.push(extensionsArray, ".svelte");
			array_exports.push(extensionsArray, ".svx");
			return generateCode();
		});
	}
});

//#endregion
//#region packages/core/dist/html.js
function element(tagName, attributes = {}) {
	const element$1 = new Element(tagName, {}, undefined, Tag);
	element$1.attribs = attributes;
	return element$1;
}
function appendElement(childNodes, elementToAppend) {
	childNodes.push(elementToAppend);
}
function addFromRawHtml(childNodes, html) {
	const document = parseHtml(html);
	for (const childNode of document.childNodes) childNodes.push(childNode);
}
function addSlot(jsAst, htmlAst, svelteVersion) {
	const slotSyntax = svelteVersion && (svelteVersion.startsWith("4") || svelteVersion.startsWith("3"));
	if (slotSyntax) {
		const slot = element("slot");
		appendElement(htmlAst.childNodes, slot);
		return;
	}
	addFromString(jsAst, "let { children } = $props();");
	addFromRawHtml(htmlAst.childNodes, "{@render children()}");
}

//#endregion
//#region packages/addons/paraglide/index.ts
const DEFAULT_INLANG_PROJECT = {
	$schema: "https://inlang.com/schema/project-settings",
	modules: ["https://cdn.jsdelivr.net/npm/@inlang/plugin-message-format@4/dist/index.js", "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@2/dist/index.js"],
	"plugin.inlang.messageFormat": { pathPattern: "./messages/{locale}.json" }
};
const options$2 = defineAddonOptions({
	availableLanguageTags: {
		question: `Which languages would you like to support? ${colors.gray("(e.g. en,de-ch)")}`,
		type: "string",
		default: "en, es",
		validate(input) {
			const { invalidLanguageTags, validLanguageTags } = parseLanguageTagInput(input);
			if (invalidLanguageTags.length > 0) if (invalidLanguageTags.length === 1) return `The input "${invalidLanguageTags[0]}" is not a valid IETF BCP 47 language tag`;
else {
				const listFormat = new Intl.ListFormat("en", {
					style: "long",
					type: "conjunction"
				});
				return `The inputs ${listFormat.format(invalidLanguageTags.map((x) => `"${x}"`))} are not valid BCP47 language tags`;
			}
			if (validLanguageTags.length === 0) return "Please enter at least one valid BCP47 language tag. Eg: en";
			return undefined;
		}
	},
	demo: {
		type: "boolean",
		default: true,
		question: "Do you want to include a demo?"
	}
});
var paraglide_default = defineAddon({
	id: "paraglide",
	shortDescription: "i18n",
	homepage: "https://inlang.com/m/gerre34r/library-inlang-paraglideJs",
	options: options$2,
	setup: ({ kit, unsupported }) => {
		if (!kit) unsupported("Requires SvelteKit");
	},
	run: ({ sv, options: options$6, typescript, kit }) => {
		const ext = typescript ? "ts" : "js";
		if (!kit) throw new Error("SvelteKit is required");
		const paraglideOutDir = "src/lib/paraglide";
		sv.dependency("@inlang/paraglide-js", "^2.0.0");
		sv.file("project.inlang/settings.json", (content) => {
			if (content) return content;
			const { data, generateCode } = parseJson$1(content);
			for (const key in DEFAULT_INLANG_PROJECT) data[key] = DEFAULT_INLANG_PROJECT[key];
			const { validLanguageTags: validLanguageTags$1 } = parseLanguageTagInput(options$6.availableLanguageTags);
			const baseLocale = validLanguageTags$1[0];
			data.baseLocale = baseLocale;
			data.locales = validLanguageTags$1;
			return generateCode();
		});
		sv.file(`vite.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const vitePluginName = "paraglideVitePlugin";
			imports_exports.addNamed(ast, "@inlang/paraglide-js", { paraglideVitePlugin: vitePluginName });
			const { value: rootObject } = exports_exports.defaultExport(ast, function_exports.call("defineConfig", []));
			const param1 = function_exports.argumentByIndex(rootObject, 0, object_exports.createEmpty());
			const pluginsArray = object_exports.property(param1, "plugins", array_exports.createEmpty());
			const pluginFunctionCall = function_exports.call(vitePluginName, []);
			const pluginConfig = object_exports.create({
				project: common_exports.createLiteral("./project.inlang"),
				outdir: common_exports.createLiteral(`./${paraglideOutDir}`)
			});
			function_exports.argumentByIndex(pluginFunctionCall, 0, pluginConfig);
			array_exports.push(pluginsArray, pluginFunctionCall);
			return generateCode();
		});
		sv.file(`src/hooks.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamed(ast, "$lib/paraglide/runtime", { deLocalizeUrl: "deLocalizeUrl" });
			const expression = common_exports.expressionFromString("(request) => deLocalizeUrl(request.url).pathname");
			const rerouteIdentifier = variables_exports.declaration(ast, "const", "reroute", expression);
			const existingExport = exports_exports.namedExport(ast, "reroute", rerouteIdentifier);
			if (existingExport.declaration !== rerouteIdentifier) log$1.warn("Adding the reroute hook automatically failed. Add it manually");
			return generateCode();
		});
		sv.file(`src/hooks.server.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamed(ast, "$lib/paraglide/server", { paraglideMiddleware: "paraglideMiddleware" });
			const hookHandleContent = `({ event, resolve }) => paraglideMiddleware(event.request, ({ request, locale }) => {
		event.request = request;
		return resolve(event, {
			transformPageChunk: ({ html }) => html.replace('%paraglide.lang%', locale)
		});
	});`;
			kit_exports.addHooksHandle(ast, typescript, "handleParaglide", hookHandleContent);
			return generateCode();
		});
		sv.file("src/app.html", (content) => {
			const { ast, generateCode } = parseHtml$1(content);
			const htmlNode = ast.children.find((child) => child.type === esm_exports.Tag && child.name === "html");
			if (!htmlNode) {
				log$1.warn("Could not find <html> node in app.html. You'll need to add the language placeholder manually");
				return generateCode();
			}
			htmlNode.attribs = {
				...htmlNode.attribs,
				lang: "%paraglide.lang%"
			};
			return generateCode();
		});
		sv.file(".gitignore", (content) => {
			if (!content) return content;
			if (!content.includes(`\n${paraglideOutDir}`)) content = content.trimEnd() + `\n\n# Paraglide\n${paraglideOutDir}`;
			return content;
		});
		if (options$6.demo) {
			sv.file(`${kit.routesDirectory}/demo/+page.svelte`, (content) => {
				return addToDemoPage(content, "paraglide");
			});
			sv.file(`${kit.routesDirectory}/demo/paraglide/+page.svelte`, (content) => {
				const { script, template, generateCode } = parseSvelte(content, { typescript });
				imports_exports.addNamed(script.ast, "$lib/paraglide/messages.js", { m: "m" });
				imports_exports.addNamed(script.ast, "$app/navigation", { goto: "goto" });
				imports_exports.addNamed(script.ast, "$app/state", { page: "page" });
				imports_exports.addNamed(script.ast, "$lib/paraglide/runtime", { setLocale: "setLocale" });
				const scriptCode = new MagicString(script.generateCode());
				const templateCode = new MagicString(template.source);
				templateCode.append("\n\n<h1>{m.hello_world({ name: 'SvelteKit User' })}</h1>\n");
				const { validLanguageTags: validLanguageTags$1 } = parseLanguageTagInput(options$6.availableLanguageTags);
				const links = validLanguageTags$1.map((x) => `${templateCode.getIndentString()}<button onclick={() => setLocale('${x}')}>${x}</button>`).join("\n");
				templateCode.append(`<div>\n${links}\n</div>`);
				templateCode.append("<p>\nIf you use VSCode, install the <a href=\"https://marketplace.visualstudio.com/items?itemName=inlang.vs-code-extension\" target=\"_blank\">Sherlock i18n extension</a> for a better i18n experience.\n</p>");
				return generateCode({
					script: scriptCode.toString(),
					template: templateCode.toString()
				});
			});
		}
		const { validLanguageTags } = parseLanguageTagInput(options$6.availableLanguageTags);
		for (const languageTag of validLanguageTags) sv.file(`messages/${languageTag}.json`, (content) => {
			const { data, generateCode } = parseJson$1(content);
			data["$schema"] = "https://inlang.com/schema/inlang-message-format";
			data.hello_world = `Hello, {name} from ${languageTag}!`;
			return generateCode();
		});
	},
	nextSteps: ({ highlighter }) => {
		const steps = [`Edit your messages in ${highlighter.path("messages/en.json")}`];
		if (options$2.demo) steps.push(`Visit ${highlighter.route("/demo/paraglide")} route to view the demo`);
		return steps;
	}
});
const isValidLanguageTag = (languageTag) => RegExp("^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$").test(languageTag);
function parseLanguageTagInput(input) {
	const probablyLanguageTags = input.replace(/[,:\s]/g, " ").split(" ").filter(Boolean).map((tag) => tag.toLowerCase());
	const validLanguageTags = [];
	const invalidLanguageTags = [];
	for (const tag of probablyLanguageTags) if (isValidLanguageTag(tag)) validLanguageTags.push(tag);
else invalidLanguageTags.push(tag);
	return {
		validLanguageTags,
		invalidLanguageTags
	};
}

//#endregion
//#region packages/addons/playwright/index.ts
var playwright_default = defineAddon({
	id: "playwright",
	shortDescription: "browser testing",
	homepage: "https://playwright.dev",
	options: {},
	run: ({ sv, typescript }) => {
		const ext = typescript ? "ts" : "js";
		sv.devDependency("@playwright/test", "^1.49.1");
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson$1(content);
			data.scripts ??= {};
			const scripts$1 = data.scripts;
			const TEST_CMD = "playwright test";
			const RUN_TEST = "npm run test:e2e";
			scripts$1["test:e2e"] ??= TEST_CMD;
			scripts$1["test"] ??= RUN_TEST;
			if (!scripts$1["test"].includes(RUN_TEST)) scripts$1["test"] += ` && ${RUN_TEST}`;
			return generateCode();
		});
		sv.file(".gitignore", (content) => {
			if (!content) return content;
			if (content.includes("test-results")) return content;
			return "test-results\n" + content.trim();
		});
		sv.file(`e2e/demo.test.${ext}`, (content) => {
			if (content) return content;
			return dedent_default`
				import { expect, test } from '@playwright/test';

				test('home page has expected h1', async ({ page }) => {
					await page.goto('/');
					await expect(page.locator('h1')).toBeVisible();
				});
				`;
		});
		sv.file(`playwright.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const defineConfig = common_exports.expressionFromString("defineConfig({})");
			const defaultExport = exports_exports.defaultExport(ast, defineConfig);
			const config = {
				webServer: object_exports.create({
					command: common_exports.createLiteral("npm run build && npm run preview"),
					port: common_exports.expressionFromString("4173")
				}),
				testDir: common_exports.createLiteral("e2e")
			};
			if (defaultExport.value.type === "CallExpression" && defaultExport.value.arguments[0]?.type === "ObjectExpression") {
				imports_exports.addNamed(ast, "@playwright/test", { defineConfig: "defineConfig" });
				object_exports.properties(defaultExport.value.arguments[0], config);
			} else if (defaultExport.value.type === "ObjectExpression") object_exports.properties(defaultExport.value, config);
else log$1.warn("Unexpected playwright config for playwright add-on. Could not update.");
			return generateCode();
		});
	}
});

//#endregion
//#region packages/addons/prettier/index.ts
var prettier_default = defineAddon({
	id: "prettier",
	shortDescription: "formatter",
	homepage: "https://prettier.io",
	options: {},
	run: ({ sv, dependencyVersion }) => {
		sv.devDependency("prettier", "^3.4.2");
		sv.devDependency("prettier-plugin-svelte", "^3.3.3");
		sv.file(".prettierignore", (content) => {
			if (content) return content;
			return dedent_default`
				# Package Managers
				package-lock.json
				pnpm-lock.yaml
				yarn.lock
				bun.lock
				bun.lockb
			`;
		});
		sv.file(".prettierrc", (content) => {
			let data, generateCode;
			try {
				({data, generateCode} = parseJson$1(content));
			} catch {
				log$1.warn(`A ${colors.yellow(".prettierrc")} config already exists and cannot be parsed as JSON. Skipping initialization.`);
				return content;
			}
			if (Object.keys(data).length === 0) {
				data.useTabs = true;
				data.singleQuote = true;
				data.trailingComma = "none";
				data.printWidth = 100;
			}
			data.plugins ??= [];
			data.overrides ??= [];
			const plugins$1 = data.plugins;
			if (!plugins$1.includes("prettier-plugin-svelte")) data.plugins.unshift("prettier-plugin-svelte");
			const overrides = data.overrides;
			const override = overrides.find((o) => o?.options?.parser === "svelte");
			if (!override) overrides.push({
				files: "*.svelte",
				options: { parser: "svelte" }
			});
			return generateCode();
		});
		const eslintVersion = dependencyVersion("eslint");
		const eslintInstalled = hasEslint(eslintVersion);
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson$1(content);
			data.scripts ??= {};
			const scripts$1 = data.scripts;
			const CHECK_CMD = "prettier --check .";
			scripts$1["format"] ??= "prettier --write .";
			if (eslintInstalled) {
				scripts$1["lint"] ??= `${CHECK_CMD} && eslint .`;
				if (!scripts$1["lint"].includes(CHECK_CMD)) scripts$1["lint"] += ` && ${CHECK_CMD}`;
			} else scripts$1["lint"] ??= CHECK_CMD;
			return generateCode();
		});
		if (eslintVersion?.startsWith(SUPPORTED_ESLINT_VERSION) === false) log$1.warn(`An older major version of ${colors.yellow("eslint")} was detected. Skipping ${colors.yellow("eslint-config-prettier")} installation.`);
		if (eslintInstalled) {
			sv.devDependency("eslint-config-prettier", "^10.0.1");
			sv.file("eslint.config.js", addEslintConfigPrettier);
		}
	}
});
const SUPPORTED_ESLINT_VERSION = "9";
function hasEslint(version$1) {
	return !!version$1 && version$1.startsWith(SUPPORTED_ESLINT_VERSION);
}

//#endregion
//#region packages/addons/storybook/index.ts
var storybook_default = defineAddon({
	id: "storybook",
	shortDescription: "frontend workshop",
	homepage: "https://storybook.js.org",
	options: {},
	run: async ({ sv }) => {
		await sv.execute([
			"storybook@latest",
			"init",
			"--skip-install",
			"--no-dev"
		], "inherit");
	}
});

//#endregion
//#region packages/addons/tailwindcss/index.ts
const plugins = [{
	id: "typography",
	package: "@tailwindcss/typography",
	version: "^0.5.15",
	identifier: "typography"
}, {
	id: "forms",
	package: "@tailwindcss/forms",
	version: "^0.5.9",
	identifier: "forms"
}];
const options$1 = defineAddonOptions({ plugins: {
	type: "multiselect",
	question: "Which plugins would you like to add?",
	options: plugins.map((p) => ({
		value: p.id,
		label: p.id,
		hint: p.package
	})),
	default: []
} });
var tailwindcss_default = defineAddon({
	id: "tailwindcss",
	alias: "tailwind",
	shortDescription: "css framework",
	homepage: "https://tailwindcss.com",
	options: options$1,
	run: ({ sv, options: options$6, typescript, kit, dependencyVersion }) => {
		const ext = typescript ? "ts" : "js";
		const prettierInstalled = Boolean(dependencyVersion("prettier"));
		sv.devDependency("tailwindcss", "^4.0.0");
		sv.devDependency("@tailwindcss/vite", "^4.0.0");
		if (prettierInstalled) sv.devDependency("prettier-plugin-tailwindcss", "^0.6.11");
		for (const plugin of plugins) {
			if (!options$6.plugins.includes(plugin.id)) continue;
			sv.devDependency(plugin.package, plugin.version);
		}
		sv.file(`vite.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			const vitePluginName = "tailwindcss";
			imports_exports.addDefault(ast, "@tailwindcss/vite", vitePluginName);
			const { value: rootObject } = exports_exports.defaultExport(ast, function_exports.call("defineConfig", []));
			const param1 = function_exports.argumentByIndex(rootObject, 0, object_exports.createEmpty());
			const pluginsArray = object_exports.property(param1, "plugins", array_exports.createEmpty());
			const pluginFunctionCall = function_exports.call(vitePluginName, []);
			array_exports.unshift(pluginsArray, pluginFunctionCall);
			return generateCode();
		});
		sv.file("src/app.css", (content) => {
			let atRules = parseCss$1(content).ast.nodes.filter((node) => node.type === "atrule");
			const findAtRule = (name$1, params) => atRules.find((rule) => rule.name === name$1 && rule.params.replace(/['"]/g, "") === params);
			let code = content;
			const importsTailwind = findAtRule("import", "tailwindcss");
			if (!importsTailwind) {
				code = "@import 'tailwindcss';\n" + code;
				atRules = parseCss$1(code).ast.nodes.filter((node) => node.type === "atrule");
			}
			const lastAtRule = atRules.findLast((rule) => ["plugin", "import"].includes(rule.name));
			const pluginPos = lastAtRule.source.end.offset;
			for (const plugin of plugins) {
				if (!options$6.plugins.includes(plugin.id)) continue;
				const pluginRule = findAtRule("plugin", plugin.package);
				if (!pluginRule) {
					const pluginImport = `\n@plugin '${plugin.package}';`;
					code = code.substring(0, pluginPos) + pluginImport + code.substring(pluginPos);
				}
			}
			return code;
		});
		if (!kit) sv.file("src/App.svelte", (content) => {
			const { script, generateCode } = parseSvelte(content, { typescript });
			imports_exports.addEmpty(script.ast, "./app.css");
			return generateCode({ script: script.generateCode() });
		});
else sv.file(`${kit?.routesDirectory}/+layout.svelte`, (content) => {
			const { script, template, generateCode } = parseSvelte(content, { typescript });
			imports_exports.addEmpty(script.ast, "../app.css");
			if (content.length === 0) {
				const svelteVersion = dependencyVersion("svelte");
				if (!svelteVersion) throw new Error("Failed to determine svelte version");
				addSlot(script.ast, template.ast, svelteVersion);
			}
			return generateCode({
				script: script.generateCode(),
				template: content.length === 0 ? template.generateCode() : undefined
			});
		});
		if (dependencyVersion("prettier")) sv.file(".prettierrc", (content) => {
			const { data, generateCode } = parseJson$1(content);
			const PLUGIN_NAME = "prettier-plugin-tailwindcss";
			data.plugins ??= [];
			const plugins$1 = data.plugins;
			if (!plugins$1.includes(PLUGIN_NAME)) plugins$1.push(PLUGIN_NAME);
			return generateCode();
		});
	}
});

//#endregion
//#region packages/addons/vitest-addon/index.ts
var vitest_addon_default = defineAddon({
	id: "vitest",
	shortDescription: "unit testing",
	homepage: "https://vitest.dev",
	options: {},
	run: ({ sv, typescript, kit }) => {
		const ext = typescript ? "ts" : "js";
		sv.devDependency("vitest", "^3.0.0");
		sv.devDependency("@testing-library/svelte", "^5.2.4");
		sv.devDependency("@testing-library/jest-dom", "^6.6.3");
		sv.devDependency("jsdom", "^26.0.0");
		sv.file("package.json", (content) => {
			const { data, generateCode } = parseJson$1(content);
			data.scripts ??= {};
			const scripts$1 = data.scripts;
			const TEST_CMD = "vitest";
			const RUN_TEST = "npm run test:unit -- --run";
			scripts$1["test:unit"] ??= TEST_CMD;
			scripts$1["test"] ??= RUN_TEST;
			if (!scripts$1["test"].includes(RUN_TEST)) scripts$1["test"] += ` && ${RUN_TEST}`;
			return generateCode();
		});
		sv.file(`src/demo.spec.${ext}`, (content) => {
			if (content) return content;
			return dedent_default`
				import { describe, it, expect } from 'vitest';

				describe('sum test', () => {
					it('adds 1 + 2 to equal 3', () => {
						expect(1 + 2).toBe(3);
					});
				});
			`;
		});
		if (kit) sv.file(`${kit.routesDirectory}/page.svelte.test.${ext}`, (content) => {
			if (content) return content;
			return dedent_default`
						import { describe, test, expect } from 'vitest';
						import '@testing-library/jest-dom/vitest';
						import { render, screen } from '@testing-library/svelte';
						import Page from './+page.svelte';
	
						describe('/+page.svelte', () => {
							test('should render h1', () => {
								render(Page);
								expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument();
							});
						});
					`;
		});
else sv.file(`src/App.svelte.test.${ext}`, (content) => {
			if (content) return content;
			return dedent_default`
						import { describe, test, expect } from 'vitest';
						import '@testing-library/jest-dom/vitest';
						import { render, screen } from '@testing-library/svelte';
						import App from './App.svelte';
	
						describe('App.svelte', () => {
							test('should render h1', () => {
								render(App);
								expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument();
							});
						});
					`;
		});
		sv.file(`vitest-setup-client.${ext}`, (content) => {
			if (content) return content;
			return dedent_default`
					import '@testing-library/jest-dom/vitest';
					import { vi } from 'vitest';

					// required for svelte5 + jsdom as jsdom does not support matchMedia
					Object.defineProperty(window, 'matchMedia', {
						writable: true,
						enumerable: true,
						value: vi.fn().mockImplementation(query => ({
							matches: false,
							media: query,
							onchange: null,
							addEventListener: vi.fn(),
							removeEventListener: vi.fn(),
							dispatchEvent: vi.fn(),
						})),
					})

					// add more mocks here if you need them
				`;
		});
		sv.file(`vite.config.${ext}`, (content) => {
			const { ast, generateCode } = parseScript$1(content);
			imports_exports.addNamed(ast, "@testing-library/svelte/vite", { svelteTesting: "svelteTesting" });
			const clientObjectExpression = object_exports.create({
				extends: common_exports.createLiteral(`./vite.config.${ext}`),
				plugins: common_exports.expressionFromString("[svelteTesting()]"),
				test: object_exports.create({
					name: common_exports.createLiteral("client"),
					environment: common_exports.createLiteral("jsdom"),
					clearMocks: common_exports.expressionFromString("true"),
					include: common_exports.expressionFromString("['src/**/*.svelte.{test,spec}.{js,ts}']"),
					exclude: common_exports.expressionFromString("['src/lib/server/**']"),
					setupFiles: common_exports.expressionFromString(`['./vitest-setup-client.${ext}']`)
				})
			});
			const serverObjectExpression = object_exports.create({
				extends: common_exports.createLiteral(`./vite.config.${ext}`),
				test: object_exports.create({
					name: common_exports.createLiteral("server"),
					environment: common_exports.createLiteral("node"),
					include: common_exports.expressionFromString("['src/**/*.{test,spec}.{js,ts}']"),
					exclude: common_exports.expressionFromString("['src/**/*.svelte.{test,spec}.{js,ts}']")
				})
			});
			const defineConfigFallback = function_exports.call("defineConfig", []);
			const { value: defineWorkspaceCall } = exports_exports.defaultExport(ast, defineConfigFallback);
			if (defineWorkspaceCall.type !== "CallExpression") log$1.warn("Unexpected vite config. Could not update.");
			const vitestConfig = function_exports.argumentByIndex(defineWorkspaceCall, 0, object_exports.createEmpty());
			const testObject = object_exports.property(vitestConfig, "test", object_exports.createEmpty());
			const workspaceArray = object_exports.property(testObject, "workspace", array_exports.createEmpty());
			array_exports.push(workspaceArray, clientObjectExpression);
			array_exports.push(workspaceArray, serverObjectExpression);
			return generateCode();
		});
	}
});

//#endregion
//#region packages/addons/_config/official.ts
const officialAddons = [
	prettier_default,
	eslint_default,
	vitest_addon_default,
	playwright_default,
	tailwindcss_default,
	sveltekit_adapter_default,
	drizzle_default,
	lucia_default,
	mdsvex_default,
	paraglide_default,
	storybook_default
];
function getAddonDetails(id) {
	const details = officialAddons.find((a) => a.id === id);
	if (!details) throw new Error(`Invalid add-on: ${id}`);
	return details;
}

//#endregion
//#region packages/addons/_config/community.ts
const communityAddonIds = ["unocss", "unplugin-icons"];
async function getCommunityAddon(name$1) {
	const { default: details } = await import(`../../../community-addons/${name$1}.ts`);
	return details;
}

//#endregion
//#region packages/cli/utils/errors.ts
var UnsupportedError = class extends Error {
	name = "Unsupported Environment";
	reasons = [];
	constructor(reasons) {
		super();
		this.reasons = reasons;
	}
};

//#endregion
//#region packages/cli/utils/common.ts
var import_picocolors$3 = __toESM(require_picocolors$1(), 1);
const NO_PREFIX = "--no-";
let options = [];
function getLongFlag(flags) {
	return flags.split(",").map((f) => f.trim()).find((f) => f.startsWith("--"));
}
const helpConfig = {
	argumentDescription: formatDescription,
	optionDescription: formatDescription,
	visibleOptions(cmd) {
		options = cmd.options;
		const visible = cmd.options.filter((o) => !o.hidden);
		const show = [];
		for (const option of visible) {
			const flag = getLongFlag(option.flags);
			if (flag?.startsWith(NO_PREFIX)) {
				const stripped = flag.slice(NO_PREFIX.length);
				const isNoVariant = visible.some((o) => getLongFlag(o.flags)?.startsWith(`--${stripped}`));
				if (isNoVariant) continue;
			}
			show.push(option);
		}
		return show;
	},
	optionTerm(option) {
		const longFlag = getLongFlag(option.flags);
		const flag = longFlag?.split(" ").at(0);
		if (!flag || !longFlag) return option.flags;
		const noVariant = `--no-${flag.slice(2)}`;
		const hasVariant = options.some((o) => getLongFlag(o.flags) === noVariant);
		if (hasVariant) return `--[no-]${longFlag.slice(2)}`;
		return option.flags;
	},
	styleTitle: (str) => import_picocolors$3.default.underline(str),
	styleCommandText: (str) => import_picocolors$3.default.red(str),
	styleDescriptionText: (str) => import_picocolors$3.default.gray(str),
	styleOptionText: (str) => import_picocolors$3.default.white(str),
	styleArgumentText: (str) => import_picocolors$3.default.white(str),
	styleSubcommandText: (str) => import_picocolors$3.default.red(str)
};
function formatDescription(arg) {
	let output = arg.description;
	if (arg.defaultValue !== undefined && String(arg.defaultValue)) output += import_picocolors$3.default.dim(` (default: ${JSON.stringify(arg.defaultValue)})`);
	if (arg.argChoices !== undefined && String(arg.argChoices)) output += import_picocolors$3.default.dim(` (choices: ${arg.argChoices.join(", ")})`);
	return output;
}
async function runCommand(action) {
	try {
		intro(`Welcome to the Svelte CLI! ${import_picocolors$3.default.gray(`(v${package_default.version})`)}`);
		await action();
		outro("You're all set!");
	} catch (e) {
		if (e instanceof UnsupportedError) {
			const padding = getPadding(e.reasons.map((r) => r.id));
			const message = e.reasons.map((r) => `  ${r.id.padEnd(padding)}  ${import_picocolors$3.default.red(r.reason)}`).join("\n");
			log.error(`${e.name}\n\n${message}`);
			log.message();
		} else if (e instanceof Error) {
			log.error(e.stack ?? String(e));
			log.message();
		}
		cancel("Operation failed.");
	}
}
function getPadding(lines) {
	const lengths = lines.map((s$1) => s$1.length);
	return Math.max(...lengths);
}
function forwardExitCode(error) {
	if (error && typeof error === "object" && "status" in error && typeof error.status === "number") process$1.exit(error.status);
else process$1.exit(1);
}

//#endregion
//#region node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({ "node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js"(exports, module) {
	module.exports = class FixedFIFO$1 {
		constructor(hwm) {
			if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error("Max size for a FixedFIFO should be a power of two");
			this.buffer = new Array(hwm);
			this.mask = hwm - 1;
			this.top = 0;
			this.btm = 0;
			this.next = null;
		}
		clear() {
			this.top = this.btm = 0;
			this.next = null;
			this.buffer.fill(undefined);
		}
		push(data) {
			if (this.buffer[this.top] !== undefined) return false;
			this.buffer[this.top] = data;
			this.top = this.top + 1 & this.mask;
			return true;
		}
		shift() {
			const last = this.buffer[this.btm];
			if (last === undefined) return undefined;
			this.buffer[this.btm] = undefined;
			this.btm = this.btm + 1 & this.mask;
			return last;
		}
		peek() {
			return this.buffer[this.btm];
		}
		isEmpty() {
			return this.buffer[this.btm] === undefined;
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({ "node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js"(exports, module) {
	const FixedFIFO = require_fixed_size();
	module.exports = class FastFIFO {
		constructor(hwm) {
			this.hwm = hwm || 16;
			this.head = new FixedFIFO(this.hwm);
			this.tail = this.head;
			this.length = 0;
		}
		clear() {
			this.head = this.tail;
			this.head.clear();
			this.length = 0;
		}
		push(val) {
			this.length++;
			if (!this.head.push(val)) {
				const prev = this.head;
				this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
				this.head.push(val);
			}
		}
		shift() {
			if (this.length !== 0) this.length--;
			const val = this.tail.shift();
			if (val === undefined && this.tail.next) {
				const next = this.tail.next;
				this.tail.next = null;
				this.tail = next;
				return this.tail.shift();
			}
			return val;
		}
		peek() {
			const val = this.tail.peek();
			if (val === undefined && this.tail.next) return this.tail.next.peek();
			return val;
		}
		isEmpty() {
			return this.length === 0;
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/b4a@1.6.7/node_modules/b4a/index.js
var require_b4a = __commonJS({ "node_modules/.pnpm/b4a@1.6.7/node_modules/b4a/index.js"(exports, module) {
	function isBuffer(value) {
		return Buffer.isBuffer(value) || value instanceof Uint8Array;
	}
	function isEncoding(encoding) {
		return Buffer.isEncoding(encoding);
	}
	function alloc(size, fill$1, encoding) {
		return Buffer.alloc(size, fill$1, encoding);
	}
	function allocUnsafe(size) {
		return Buffer.allocUnsafe(size);
	}
	function allocUnsafeSlow(size) {
		return Buffer.allocUnsafeSlow(size);
	}
	function byteLength(string$1, encoding) {
		return Buffer.byteLength(string$1, encoding);
	}
	function compare(a, b) {
		return Buffer.compare(a, b);
	}
	function concat(buffers, totalLength) {
		return Buffer.concat(buffers, totalLength);
	}
	function copy(source, target, targetStart, start, end) {
		return toBuffer(source).copy(target, targetStart, start, end);
	}
	function equals(a, b) {
		return toBuffer(a).equals(b);
	}
	function fill(buffer, value, offset, end, encoding) {
		return toBuffer(buffer).fill(value, offset, end, encoding);
	}
	function from$1(value, encodingOrOffset, length) {
		return Buffer.from(value, encodingOrOffset, length);
	}
	function includes(buffer, value, byteOffset, encoding) {
		return toBuffer(buffer).includes(value, byteOffset, encoding);
	}
	function indexOf$1(buffer, value, byfeOffset, encoding) {
		return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
	}
	function lastIndexOf(buffer, value, byteOffset, encoding) {
		return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
	}
	function swap16(buffer) {
		return toBuffer(buffer).swap16();
	}
	function swap32(buffer) {
		return toBuffer(buffer).swap32();
	}
	function swap64(buffer) {
		return toBuffer(buffer).swap64();
	}
	function toBuffer(buffer) {
		if (Buffer.isBuffer(buffer)) return buffer;
		return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
	}
	function toString(buffer, encoding, start, end) {
		return toBuffer(buffer).toString(encoding, start, end);
	}
	function write(buffer, string$1, offset, length, encoding) {
		return toBuffer(buffer).write(string$1, offset, length, encoding);
	}
	function writeDoubleLE(buffer, value, offset) {
		return toBuffer(buffer).writeDoubleLE(value, offset);
	}
	function writeFloatLE(buffer, value, offset) {
		return toBuffer(buffer).writeFloatLE(value, offset);
	}
	function writeUInt32LE(buffer, value, offset) {
		return toBuffer(buffer).writeUInt32LE(value, offset);
	}
	function writeInt32LE(buffer, value, offset) {
		return toBuffer(buffer).writeInt32LE(value, offset);
	}
	function readDoubleLE(buffer, offset) {
		return toBuffer(buffer).readDoubleLE(offset);
	}
	function readFloatLE(buffer, offset) {
		return toBuffer(buffer).readFloatLE(offset);
	}
	function readUInt32LE(buffer, offset) {
		return toBuffer(buffer).readUInt32LE(offset);
	}
	function readInt32LE(buffer, offset) {
		return toBuffer(buffer).readInt32LE(offset);
	}
	function writeDoubleBE(buffer, value, offset) {
		return toBuffer(buffer).writeDoubleBE(value, offset);
	}
	function writeFloatBE(buffer, value, offset) {
		return toBuffer(buffer).writeFloatBE(value, offset);
	}
	function writeUInt32BE(buffer, value, offset) {
		return toBuffer(buffer).writeUInt32BE(value, offset);
	}
	function writeInt32BE(buffer, value, offset) {
		return toBuffer(buffer).writeInt32BE(value, offset);
	}
	function readDoubleBE(buffer, offset) {
		return toBuffer(buffer).readDoubleBE(offset);
	}
	function readFloatBE(buffer, offset) {
		return toBuffer(buffer).readFloatBE(offset);
	}
	function readUInt32BE(buffer, offset) {
		return toBuffer(buffer).readUInt32BE(offset);
	}
	function readInt32BE(buffer, offset) {
		return toBuffer(buffer).readInt32BE(offset);
	}
	module.exports = {
		isBuffer,
		isEncoding,
		alloc,
		allocUnsafe,
		allocUnsafeSlow,
		byteLength,
		compare,
		concat,
		copy,
		equals,
		fill,
		from: from$1,
		includes,
		indexOf: indexOf$1,
		lastIndexOf,
		swap16,
		swap32,
		swap64,
		toBuffer,
		toString,
		write,
		writeDoubleLE,
		writeFloatLE,
		writeUInt32LE,
		writeInt32LE,
		readDoubleLE,
		readFloatLE,
		readUInt32LE,
		readInt32LE,
		writeDoubleBE,
		writeFloatBE,
		writeUInt32BE,
		writeInt32BE,
		readDoubleBE,
		readFloatBE,
		readUInt32BE,
		readInt32BE
	};
} });

//#endregion
//#region node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/pass-through-decoder.js
var require_pass_through_decoder = __commonJS({ "node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/pass-through-decoder.js"(exports, module) {
	const b4a$4 = require_b4a();
	module.exports = class PassThroughDecoder$1 {
		constructor(encoding) {
			this.encoding = encoding;
		}
		get remaining() {
			return 0;
		}
		decode(tail) {
			return b4a$4.toString(tail, this.encoding);
		}
		flush() {
			return "";
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/utf8-decoder.js
var require_utf8_decoder = __commonJS({ "node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/utf8-decoder.js"(exports, module) {
	const b4a$3 = require_b4a();
	/**
	* https://encoding.spec.whatwg.org/#utf-8-decoder
	*/
	module.exports = class UTF8Decoder$1 {
		constructor() {
			this.codePoint = 0;
			this.bytesSeen = 0;
			this.bytesNeeded = 0;
			this.lowerBoundary = 128;
			this.upperBoundary = 191;
		}
		get remaining() {
			return this.bytesSeen;
		}
		decode(data) {
			if (this.bytesNeeded === 0) {
				let isBoundary = true;
				for (let i = Math.max(0, data.byteLength - 4), n$1 = data.byteLength; i < n$1 && isBoundary; i++) isBoundary = data[i] <= 127;
				if (isBoundary) return b4a$3.toString(data, "utf8");
			}
			let result = "";
			for (let i = 0, n$1 = data.byteLength; i < n$1; i++) {
				const byte = data[i];
				if (this.bytesNeeded === 0) {
					if (byte <= 127) result += String.fromCharCode(byte);
else {
						this.bytesSeen = 1;
						if (byte >= 194 && byte <= 223) {
							this.bytesNeeded = 2;
							this.codePoint = byte & 31;
						} else if (byte >= 224 && byte <= 239) {
							if (byte === 224) this.lowerBoundary = 160;
else if (byte === 237) this.upperBoundary = 159;
							this.bytesNeeded = 3;
							this.codePoint = byte & 15;
						} else if (byte >= 240 && byte <= 244) {
							if (byte === 240) this.lowerBoundary = 144;
							if (byte === 244) this.upperBoundary = 143;
							this.bytesNeeded = 4;
							this.codePoint = byte & 7;
						} else result += "�";
					}
					continue;
				}
				if (byte < this.lowerBoundary || byte > this.upperBoundary) {
					this.codePoint = 0;
					this.bytesNeeded = 0;
					this.bytesSeen = 0;
					this.lowerBoundary = 128;
					this.upperBoundary = 191;
					result += "�";
					continue;
				}
				this.lowerBoundary = 128;
				this.upperBoundary = 191;
				this.codePoint = this.codePoint << 6 | byte & 63;
				this.bytesSeen++;
				if (this.bytesSeen !== this.bytesNeeded) continue;
				result += String.fromCodePoint(this.codePoint);
				this.codePoint = 0;
				this.bytesNeeded = 0;
				this.bytesSeen = 0;
			}
			return result;
		}
		flush() {
			const result = this.bytesNeeded > 0 ? "�" : "";
			this.codePoint = 0;
			this.bytesNeeded = 0;
			this.bytesSeen = 0;
			this.lowerBoundary = 128;
			this.upperBoundary = 191;
			return result;
		}
	};
} });

//#endregion
//#region node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js
var require_text_decoder = __commonJS({ "node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js"(exports, module) {
	const PassThroughDecoder = require_pass_through_decoder();
	const UTF8Decoder = require_utf8_decoder();
	module.exports = class TextDecoder$2 {
		constructor(encoding = "utf8") {
			this.encoding = normalizeEncoding(encoding);
			switch (this.encoding) {
				case "utf8":
					this.decoder = new UTF8Decoder();
					break;
				case "utf16le":
				case "base64": throw new Error("Unsupported encoding: " + this.encoding);
				default: this.decoder = new PassThroughDecoder(this.encoding);
			}
		}
		get remaining() {
			return this.decoder.remaining;
		}
		push(data) {
			if (typeof data === "string") return data;
			return this.decoder.decode(data);
		}
		write(data) {
			return this.push(data);
		}
		end(data) {
			let result = "";
			if (data) result = this.push(data);
			result += this.decoder.flush();
			return result;
		}
	};
	function normalizeEncoding(encoding) {
		encoding = encoding.toLowerCase();
		switch (encoding) {
			case "utf8":
			case "utf-8": return "utf8";
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return "utf16le";
			case "latin1":
			case "binary": return "latin1";
			case "base64":
			case "ascii":
			case "hex": return encoding;
			default: throw new Error("Unknown encoding: " + encoding);
		}
	}
} });

//#endregion
//#region node_modules/.pnpm/streamx@2.22.0/node_modules/streamx/index.js
var require_streamx = __commonJS({ "node_modules/.pnpm/streamx@2.22.0/node_modules/streamx/index.js"(exports, module) {
	const { EventEmitter } = __require("events");
	const STREAM_DESTROYED = new Error("Stream was destroyed");
	const PREMATURE_CLOSE = new Error("Premature close");
	const FIFO$1 = require_fast_fifo();
	const TextDecoder$1 = require_text_decoder();
	const MAX = 536870911;
	const OPENING = 1;
	const PREDESTROYING = 2;
	const DESTROYING = 4;
	const DESTROYED = 8;
	const NOT_OPENING = MAX ^ OPENING;
	const NOT_PREDESTROYING = MAX ^ PREDESTROYING;
	const READ_ACTIVE = 16;
	const READ_UPDATING = 32;
	const READ_PRIMARY = 64;
	const READ_QUEUED = 128;
	const READ_RESUMED = 256;
	const READ_PIPE_DRAINED = 512;
	const READ_ENDING = 1024;
	const READ_EMIT_DATA = 2048;
	const READ_EMIT_READABLE = 4096;
	const READ_EMITTED_READABLE = 8192;
	const READ_DONE = 16384;
	const READ_NEXT_TICK = 32768;
	const READ_NEEDS_PUSH = 65536;
	const READ_READ_AHEAD = 131072;
	const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
	const READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
	const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
	const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
	const READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
	const READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
	const READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
	const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
	const READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
	const READ_PAUSED = MAX ^ READ_RESUMED;
	const READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
	const READ_NOT_ENDING = MAX ^ READ_ENDING;
	const READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
	const READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
	const READ_NOT_UPDATING = MAX ^ READ_UPDATING;
	const READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
	const READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
	const WRITE_ACTIVE = 262144;
	const WRITE_UPDATING = 524288;
	const WRITE_PRIMARY = 1048576;
	const WRITE_QUEUED = 2097152;
	const WRITE_UNDRAINED = 4194304;
	const WRITE_DONE = 8388608;
	const WRITE_EMIT_DRAIN = 16777216;
	const WRITE_NEXT_TICK = 33554432;
	const WRITE_WRITING = 67108864;
	const WRITE_FINISHING = 134217728;
	const WRITE_CORKED = 268435456;
	const WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
	const WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
	const WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
	const WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
	const WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
	const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
	const WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
	const WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
	const ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
	const NOT_ACTIVE = MAX ^ ACTIVE;
	const DONE = READ_DONE | WRITE_DONE;
	const DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
	const OPEN_STATUS = DESTROY_STATUS | OPENING;
	const AUTO_DESTROY = DESTROY_STATUS | DONE;
	const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
	const ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
	const TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
	const IS_OPENING = OPEN_STATUS | TICKING;
	const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
	const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
	const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
	const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
	const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
	const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
	const READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
	const READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
	const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
	const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
	const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
	const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
	const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
	const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
	const WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
	const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
	const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
	const WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
	const WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
	const asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
	var WritableState = class {
		constructor(stream, { highWaterMark = 16384, map = null, mapWritable: mapWritable$1, byteLength: byteLength$1, byteLengthWritable } = {}) {
			this.stream = stream;
			this.queue = new FIFO$1();
			this.highWaterMark = highWaterMark;
			this.buffered = 0;
			this.error = null;
			this.pipeline = null;
			this.drains = null;
			this.byteLength = byteLengthWritable || byteLength$1 || defaultByteLength;
			this.map = mapWritable$1 || map;
			this.afterWrite = afterWrite.bind(this);
			this.afterUpdateNextTick = updateWriteNT.bind(this);
		}
		get ended() {
			return (this.stream._duplexState & WRITE_DONE) !== 0;
		}
		push(data) {
			if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false;
			if (this.map !== null) data = this.map(data);
			this.buffered += this.byteLength(data);
			this.queue.push(data);
			if (this.buffered < this.highWaterMark) {
				this.stream._duplexState |= WRITE_QUEUED;
				return true;
			}
			this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
			return false;
		}
		shift() {
			const data = this.queue.shift();
			this.buffered -= this.byteLength(data);
			if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;
			return data;
		}
		end(data) {
			if (typeof data === "function") this.stream.once("finish", data);
else if (data !== undefined && data !== null) this.push(data);
			this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
		}
		autoBatch(data, cb) {
			const buffer = [];
			const stream = this.stream;
			buffer.push(data);
			while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) buffer.push(stream._writableState.shift());
			if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);
			stream._writev(buffer, cb);
		}
		update() {
			const stream = this.stream;
			stream._duplexState |= WRITE_UPDATING;
			do {
				while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
					const data = this.shift();
					stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
					stream._write(data, this.afterWrite);
				}
				if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
			} while (this.continueUpdate() === true);
			stream._duplexState &= WRITE_NOT_UPDATING;
		}
		updateNonPrimary() {
			const stream = this.stream;
			if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
				stream._duplexState = stream._duplexState | WRITE_ACTIVE;
				stream._final(afterFinal.bind(this));
				return;
			}
			if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
				if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
					stream._duplexState |= ACTIVE;
					stream._destroy(afterDestroy.bind(this));
				}
				return;
			}
			if ((stream._duplexState & IS_OPENING) === OPENING) {
				stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
				stream._open(afterOpen.bind(this));
			}
		}
		continueUpdate() {
			if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;
			this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
			return true;
		}
		updateCallback() {
			if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();
else this.updateNextTick();
		}
		updateNextTick() {
			if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
			this.stream._duplexState |= WRITE_NEXT_TICK;
			if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick);
		}
	};
	var ReadableState = class {
		constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength: byteLength$1, byteLengthReadable } = {}) {
			this.stream = stream;
			this.queue = new FIFO$1();
			this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
			this.buffered = 0;
			this.readAhead = highWaterMark > 0;
			this.error = null;
			this.pipeline = null;
			this.byteLength = byteLengthReadable || byteLength$1 || defaultByteLength;
			this.map = mapReadable || map;
			this.pipeTo = null;
			this.afterRead = afterRead.bind(this);
			this.afterUpdateNextTick = updateReadNT.bind(this);
		}
		get ended() {
			return (this.stream._duplexState & READ_DONE) !== 0;
		}
		pipe(pipeTo, cb) {
			if (this.pipeTo !== null) throw new Error("Can only pipe to one destination");
			if (typeof cb !== "function") cb = null;
			this.stream._duplexState |= READ_PIPE_DRAINED;
			this.pipeTo = pipeTo;
			this.pipeline = new Pipeline(this.stream, pipeTo, cb);
			if (cb) this.stream.on("error", noop$5);
			if (isStreamx(pipeTo)) {
				pipeTo._writableState.pipeline = this.pipeline;
				if (cb) pipeTo.on("error", noop$5);
				pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
			} else {
				const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
				const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
				pipeTo.on("error", onerror);
				pipeTo.on("close", onclose);
				pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
			}
			pipeTo.on("drain", afterDrain.bind(this));
			this.stream.emit("piping", pipeTo);
			pipeTo.emit("pipe", this.stream);
		}
		push(data) {
			const stream = this.stream;
			if (data === null) {
				this.highWaterMark = 0;
				stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
				return false;
			}
			if (this.map !== null) {
				data = this.map(data);
				if (data === null) {
					stream._duplexState &= READ_PUSHED;
					return this.buffered < this.highWaterMark;
				}
			}
			this.buffered += this.byteLength(data);
			this.queue.push(data);
			stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
			return this.buffered < this.highWaterMark;
		}
		shift() {
			const data = this.queue.shift();
			this.buffered -= this.byteLength(data);
			if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
			return data;
		}
		unshift(data) {
			const pending = [this.map !== null ? this.map(data) : data];
			while (this.buffered > 0) pending.push(this.shift());
			for (let i = 0; i < pending.length - 1; i++) {
				const data$1 = pending[i];
				this.buffered += this.byteLength(data$1);
				this.queue.push(data$1);
			}
			this.push(pending[pending.length - 1]);
		}
		read() {
			const stream = this.stream;
			if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
				const data = this.shift();
				if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
				if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit("data", data);
				return data;
			}
			if (this.readAhead === false) {
				stream._duplexState |= READ_READ_AHEAD;
				this.updateNextTick();
			}
			return null;
		}
		drain() {
			const stream = this.stream;
			while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
				const data = this.shift();
				if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
				if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit("data", data);
			}
		}
		update() {
			const stream = this.stream;
			stream._duplexState |= READ_UPDATING;
			do {
				this.drain();
				while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
					stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
					stream._read(this.afterRead);
					this.drain();
				}
				if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
					stream._duplexState |= READ_EMITTED_READABLE;
					stream.emit("readable");
				}
				if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
			} while (this.continueUpdate() === true);
			stream._duplexState &= READ_NOT_UPDATING;
		}
		updateNonPrimary() {
			const stream = this.stream;
			if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
				stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
				stream.emit("end");
				if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
				if (this.pipeTo !== null) this.pipeTo.end();
			}
			if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
				if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
					stream._duplexState |= ACTIVE;
					stream._destroy(afterDestroy.bind(this));
				}
				return;
			}
			if ((stream._duplexState & IS_OPENING) === OPENING) {
				stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
				stream._open(afterOpen.bind(this));
			}
		}
		continueUpdate() {
			if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;
			this.stream._duplexState &= READ_NOT_NEXT_TICK;
			return true;
		}
		updateCallback() {
			if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();
else this.updateNextTick();
		}
		updateNextTickIfOpen() {
			if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return;
			this.stream._duplexState |= READ_NEXT_TICK;
			if ((this.stream._duplexState & READ_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick);
		}
		updateNextTick() {
			if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
			this.stream._duplexState |= READ_NEXT_TICK;
			if ((this.stream._duplexState & READ_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick);
		}
	};
	var TransformState = class {
		constructor(stream) {
			this.data = null;
			this.afterTransform = afterTransform.bind(stream);
			this.afterFinal = null;
		}
	};
	var Pipeline = class {
		constructor(src, dst, cb) {
			this.from = src;
			this.to = dst;
			this.afterPipe = cb;
			this.error = null;
			this.pipeToFinished = false;
		}
		finished() {
			this.pipeToFinished = true;
		}
		done(stream, err) {
			if (err) this.error = err;
			if (stream === this.to) {
				this.to = null;
				if (this.from !== null) {
					if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
					return;
				}
			}
			if (stream === this.from) {
				this.from = null;
				if (this.to !== null) {
					if ((stream._duplexState & READ_DONE) === 0) this.to.destroy(this.error || new Error("Readable stream closed before ending"));
					return;
				}
			}
			if (this.afterPipe !== null) this.afterPipe(this.error);
			this.to = this.from = this.afterPipe = null;
		}
	};
	function afterDrain() {
		this.stream._duplexState |= READ_PIPE_DRAINED;
		this.updateCallback();
	}
	function afterFinal(err) {
		const stream = this.stream;
		if (err) stream.destroy(err);
		if ((stream._duplexState & DESTROY_STATUS) === 0) {
			stream._duplexState |= WRITE_DONE;
			stream.emit("finish");
		}
		if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
		stream._duplexState &= WRITE_NOT_FINISHING;
		if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();
else this.updateNextTick();
	}
	function afterDestroy(err) {
		const stream = this.stream;
		if (!err && this.error !== STREAM_DESTROYED) err = this.error;
		if (err) stream.emit("error", err);
		stream._duplexState |= DESTROYED;
		stream.emit("close");
		const rs = stream._readableState;
		const ws = stream._writableState;
		if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);
		if (ws !== null) {
			while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);
			if (ws.pipeline !== null) ws.pipeline.done(stream, err);
		}
	}
	function afterWrite(err) {
		const stream = this.stream;
		if (err) stream.destroy(err);
		stream._duplexState &= WRITE_NOT_ACTIVE;
		if (this.drains !== null) tickDrains(this.drains);
		if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
			stream._duplexState &= WRITE_DRAINED;
			if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) stream.emit("drain");
		}
		this.updateCallback();
	}
	function afterRead(err) {
		if (err) this.stream.destroy(err);
		this.stream._duplexState &= READ_NOT_ACTIVE;
		if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;
		this.updateCallback();
	}
	function updateReadNT() {
		if ((this.stream._duplexState & READ_UPDATING) === 0) {
			this.stream._duplexState &= READ_NOT_NEXT_TICK;
			this.update();
		}
	}
	function updateWriteNT() {
		if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
			this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
			this.update();
		}
	}
	function tickDrains(drains) {
		for (let i = 0; i < drains.length; i++) if (--drains[i].writes === 0) {
			drains.shift().resolve(true);
			i--;
		}
	}
	function afterOpen(err) {
		const stream = this.stream;
		if (err) stream.destroy(err);
		if ((stream._duplexState & DESTROYING) === 0) {
			if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
			if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
			stream.emit("open");
		}
		stream._duplexState &= NOT_ACTIVE;
		if (stream._writableState !== null) stream._writableState.updateCallback();
		if (stream._readableState !== null) stream._readableState.updateCallback();
	}
	function afterTransform(err, data) {
		if (data !== undefined && data !== null) this.push(data);
		this._writableState.afterWrite(err);
	}
	function newListener(name$1) {
		if (this._readableState !== null) {
			if (name$1 === "data") {
				this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
				this._readableState.updateNextTick();
			}
			if (name$1 === "readable") {
				this._duplexState |= READ_EMIT_READABLE;
				this._readableState.updateNextTick();
			}
		}
		if (this._writableState !== null) {
			if (name$1 === "drain") {
				this._duplexState |= WRITE_EMIT_DRAIN;
				this._writableState.updateNextTick();
			}
		}
	}
	var Stream = class extends EventEmitter {
		constructor(opts) {
			super();
			this._duplexState = 0;
			this._readableState = null;
			this._writableState = null;
			if (opts) {
				if (opts.open) this._open = opts.open;
				if (opts.destroy) this._destroy = opts.destroy;
				if (opts.predestroy) this._predestroy = opts.predestroy;
				if (opts.signal) opts.signal.addEventListener("abort", abort.bind(this));
			}
			this.on("newListener", newListener);
		}
		_open(cb) {
			cb(null);
		}
		_destroy(cb) {
			cb(null);
		}
		_predestroy() {}
		get readable() {
			return this._readableState !== null ? true : undefined;
		}
		get writable() {
			return this._writableState !== null ? true : undefined;
		}
		get destroyed() {
			return (this._duplexState & DESTROYED) !== 0;
		}
		get destroying() {
			return (this._duplexState & DESTROY_STATUS) !== 0;
		}
		destroy(err) {
			if ((this._duplexState & DESTROY_STATUS) === 0) {
				if (!err) err = STREAM_DESTROYED;
				this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
				if (this._readableState !== null) {
					this._readableState.highWaterMark = 0;
					this._readableState.error = err;
				}
				if (this._writableState !== null) {
					this._writableState.highWaterMark = 0;
					this._writableState.error = err;
				}
				this._duplexState |= PREDESTROYING;
				this._predestroy();
				this._duplexState &= NOT_PREDESTROYING;
				if (this._readableState !== null) this._readableState.updateNextTick();
				if (this._writableState !== null) this._writableState.updateNextTick();
			}
		}
	};
	var Readable$2 = class Readable$2 extends Stream {
		constructor(opts) {
			super(opts);
			this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
			this._readableState = new ReadableState(this, opts);
			if (opts) {
				if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;
				if (opts.read) this._read = opts.read;
				if (opts.eagerOpen) this._readableState.updateNextTick();
				if (opts.encoding) this.setEncoding(opts.encoding);
			}
		}
		setEncoding(encoding) {
			const dec = new TextDecoder$1(encoding);
			const map = this._readableState.map || echo$1;
			this._readableState.map = mapOrSkip;
			return this;
			function mapOrSkip(data) {
				const next = dec.push(data);
				return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
			}
		}
		_read(cb) {
			cb(null);
		}
		pipe(dest, cb) {
			this._readableState.updateNextTick();
			this._readableState.pipe(dest, cb);
			return dest;
		}
		read() {
			this._readableState.updateNextTick();
			return this._readableState.read();
		}
		push(data) {
			this._readableState.updateNextTickIfOpen();
			return this._readableState.push(data);
		}
		unshift(data) {
			this._readableState.updateNextTickIfOpen();
			return this._readableState.unshift(data);
		}
		resume() {
			this._duplexState |= READ_RESUMED_READ_AHEAD;
			this._readableState.updateNextTick();
			return this;
		}
		pause() {
			this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
			return this;
		}
		static _fromAsyncIterator(ite, opts) {
			let destroy;
			const rs = new Readable$2({
				...opts,
				read(cb) {
					ite.next().then(push).then(cb.bind(null, null)).catch(cb);
				},
				predestroy() {
					destroy = ite.return();
				},
				destroy(cb) {
					if (!destroy) return cb(null);
					destroy.then(cb.bind(null, null)).catch(cb);
				}
			});
			return rs;
			function push(data) {
				if (data.done) rs.push(null);
else rs.push(data.value);
			}
		}
		static from(data, opts) {
			if (isReadStreamx(data)) return data;
			if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
			if (!Array.isArray(data)) data = data === undefined ? [] : [data];
			let i = 0;
			return new Readable$2({
				...opts,
				read(cb) {
					this.push(i === data.length ? null : data[i++]);
					cb(null);
				}
			});
		}
		static isBackpressured(rs) {
			return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
		}
		static isPaused(rs) {
			return (rs._duplexState & READ_RESUMED) === 0;
		}
		[asyncIterator]() {
			const stream = this;
			let error = null;
			let promiseResolve = null;
			let promiseReject = null;
			this.on("error", (err) => {
				error = err;
			});
			this.on("readable", onreadable);
			this.on("close", onclose);
			return {
				[asyncIterator]() {
					return this;
				},
				next() {
					return new Promise(function(resolve$1, reject) {
						promiseResolve = resolve$1;
						promiseReject = reject;
						const data = stream.read();
						if (data !== null) ondata(data);
else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
					});
				},
				return() {
					return destroy(null);
				},
				throw(err) {
					return destroy(err);
				}
			};
			function onreadable() {
				if (promiseResolve !== null) ondata(stream.read());
			}
			function onclose() {
				if (promiseResolve !== null) ondata(null);
			}
			function ondata(data) {
				if (promiseReject === null) return;
				if (error) promiseReject(error);
else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);
else promiseResolve({
					value: data,
					done: data === null
				});
				promiseReject = promiseResolve = null;
			}
			function destroy(err) {
				stream.destroy(err);
				return new Promise((resolve$1, reject) => {
					if (stream._duplexState & DESTROYED) return resolve$1({
						value: undefined,
						done: true
					});
					stream.once("close", function() {
						if (err) reject(err);
else resolve$1({
							value: undefined,
							done: true
						});
					});
				});
			}
		}
	};
	var Writable$2 = class extends Stream {
		constructor(opts) {
			super(opts);
			this._duplexState |= OPENING | READ_DONE;
			this._writableState = new WritableState(this, opts);
			if (opts) {
				if (opts.writev) this._writev = opts.writev;
				if (opts.write) this._write = opts.write;
				if (opts.final) this._final = opts.final;
				if (opts.eagerOpen) this._writableState.updateNextTick();
			}
		}
		cork() {
			this._duplexState |= WRITE_CORKED;
		}
		uncork() {
			this._duplexState &= WRITE_NOT_CORKED;
			this._writableState.updateNextTick();
		}
		_writev(batch, cb) {
			cb(null);
		}
		_write(data, cb) {
			this._writableState.autoBatch(data, cb);
		}
		_final(cb) {
			cb(null);
		}
		static isBackpressured(ws) {
			return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
		}
		static drained(ws) {
			if (ws.destroyed) return Promise.resolve(false);
			const state = ws._writableState;
			const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
			const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
			if (writes === 0) return Promise.resolve(true);
			if (state.drains === null) state.drains = [];
			return new Promise((resolve$1) => {
				state.drains.push({
					writes,
					resolve: resolve$1
				});
			});
		}
		write(data) {
			this._writableState.updateNextTick();
			return this._writableState.push(data);
		}
		end(data) {
			this._writableState.updateNextTick();
			this._writableState.end(data);
			return this;
		}
	};
	var Duplex = class extends Readable$2 {
		constructor(opts) {
			super(opts);
			this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
			this._writableState = new WritableState(this, opts);
			if (opts) {
				if (opts.writev) this._writev = opts.writev;
				if (opts.write) this._write = opts.write;
				if (opts.final) this._final = opts.final;
			}
		}
		cork() {
			this._duplexState |= WRITE_CORKED;
		}
		uncork() {
			this._duplexState &= WRITE_NOT_CORKED;
			this._writableState.updateNextTick();
		}
		_writev(batch, cb) {
			cb(null);
		}
		_write(data, cb) {
			this._writableState.autoBatch(data, cb);
		}
		_final(cb) {
			cb(null);
		}
		write(data) {
			this._writableState.updateNextTick();
			return this._writableState.push(data);
		}
		end(data) {
			this._writableState.updateNextTick();
			this._writableState.end(data);
			return this;
		}
	};
	var Transform = class extends Duplex {
		constructor(opts) {
			super(opts);
			this._transformState = new TransformState(this);
			if (opts) {
				if (opts.transform) this._transform = opts.transform;
				if (opts.flush) this._flush = opts.flush;
			}
		}
		_write(data, cb) {
			if (this._readableState.buffered >= this._readableState.highWaterMark) this._transformState.data = data;
else this._transform(data, this._transformState.afterTransform);
		}
		_read(cb) {
			if (this._transformState.data !== null) {
				const data = this._transformState.data;
				this._transformState.data = null;
				cb(null);
				this._transform(data, this._transformState.afterTransform);
			} else cb(null);
		}
		destroy(err) {
			super.destroy(err);
			if (this._transformState.data !== null) {
				this._transformState.data = null;
				this._transformState.afterTransform();
			}
		}
		_transform(data, cb) {
			cb(null, data);
		}
		_flush(cb) {
			cb(null);
		}
		_final(cb) {
			this._transformState.afterFinal = cb;
			this._flush(transformAfterFlush.bind(this));
		}
	};
	var PassThrough = class extends Transform {};
	function transformAfterFlush(err, data) {
		const cb = this._transformState.afterFinal;
		if (err) return cb(err);
		if (data !== null && data !== undefined) this.push(data);
		this.push(null);
		cb(null);
	}
	function pipelinePromise(...streams) {
		return new Promise((resolve$1, reject) => {
			return pipeline$1(...streams, (err) => {
				if (err) return reject(err);
				resolve$1();
			});
		});
	}
	function pipeline$1(stream, ...streams) {
		const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
		const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
		if (all.length < 2) throw new Error("Pipeline requires at least 2 streams");
		let src = all[0];
		let dest = null;
		let error = null;
		for (let i = 1; i < all.length; i++) {
			dest = all[i];
			if (isStreamx(src)) src.pipe(dest, onerror);
else {
				errorHandle(src, true, i > 1, onerror);
				src.pipe(dest);
			}
			src = dest;
		}
		if (done) {
			let fin = false;
			const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
			dest.on("error", (err) => {
				if (error === null) error = err;
			});
			dest.on("finish", () => {
				fin = true;
				if (!autoDestroy) done(error);
			});
			if (autoDestroy) dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
		}
		return dest;
		function errorHandle(s$1, rd, wr, onerror$1) {
			s$1.on("error", onerror$1);
			s$1.on("close", onclose);
			function onclose() {
				if (rd && s$1._readableState && !s$1._readableState.ended) return onerror$1(PREMATURE_CLOSE);
				if (wr && s$1._writableState && !s$1._writableState.ended) return onerror$1(PREMATURE_CLOSE);
			}
		}
		function onerror(err) {
			if (!err || error) return;
			error = err;
			for (const s$1 of all) s$1.destroy(err);
		}
	}
	function echo$1(s$1) {
		return s$1;
	}
	function isStream(stream) {
		return !!stream._readableState || !!stream._writableState;
	}
	function isStreamx(stream) {
		return typeof stream._duplexState === "number" && isStream(stream);
	}
	function isEnded(stream) {
		return !!stream._readableState && stream._readableState.ended;
	}
	function isFinished(stream) {
		return !!stream._writableState && stream._writableState.ended;
	}
	function getStreamError$2(stream, opts = {}) {
		const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
		return !opts.all && err === STREAM_DESTROYED ? null : err;
	}
	function isReadStreamx(stream) {
		return isStreamx(stream) && stream.readable;
	}
	function isDisturbed(stream) {
		return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
	}
	function isTypedArray(data) {
		return typeof data === "object" && data !== null && typeof data.byteLength === "number";
	}
	function defaultByteLength(data) {
		return isTypedArray(data) ? data.byteLength : 1024;
	}
	function noop$5() {}
	function abort() {
		this.destroy(new Error("Stream aborted."));
	}
	function isWritev(s$1) {
		return s$1._writev !== Writable$2.prototype._writev && s$1._writev !== Duplex.prototype._writev;
	}
	module.exports = {
		pipeline: pipeline$1,
		pipelinePromise,
		isStream,
		isStreamx,
		isEnded,
		isFinished,
		isDisturbed,
		getStreamError: getStreamError$2,
		Stream,
		Writable: Writable$2,
		Readable: Readable$2,
		Duplex,
		Transform,
		PassThrough
	};
} });

//#endregion
//#region node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/headers.js
var require_headers = __commonJS({ "node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/headers.js"(exports) {
	const b4a$2 = require_b4a();
	const ZEROS = "0000000000000000000";
	const SEVENS = "7777777777777777777";
	const ZERO_OFFSET = "0".charCodeAt(0);
	const USTAR_MAGIC = b4a$2.from([
		117,
		115,
		116,
		97,
		114,
		0
	]);
	const USTAR_VER = b4a$2.from([ZERO_OFFSET, ZERO_OFFSET]);
	const GNU_MAGIC = b4a$2.from([
		117,
		115,
		116,
		97,
		114,
		32
	]);
	const GNU_VER = b4a$2.from([32, 0]);
	const MASK = 4095;
	const MAGIC_OFFSET = 257;
	const VERSION_OFFSET = 263;
	exports.decodeLongPath = function decodeLongPath(buf, encoding) {
		return decodeStr(buf, 0, buf.length, encoding);
	};
	exports.encodePax = function encodePax(opts) {
		let result = "";
		if (opts.name) result += addLength(" path=" + opts.name + "\n");
		if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
		const pax = opts.pax;
		if (pax) for (const key in pax) result += addLength(" " + key + "=" + pax[key] + "\n");
		return b4a$2.from(result);
	};
	exports.decodePax = function decodePax(buf) {
		const result = {};
		while (buf.length) {
			let i = 0;
			while (i < buf.length && buf[i] !== 32) i++;
			const len = parseInt(b4a$2.toString(buf.subarray(0, i)), 10);
			if (!len) return result;
			const b = b4a$2.toString(buf.subarray(i + 1, len - 1));
			const keyIndex = b.indexOf("=");
			if (keyIndex === -1) return result;
			result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
			buf = buf.subarray(len);
		}
		return result;
	};
	exports.encode = function encode$1(opts) {
		const buf = b4a$2.alloc(512);
		let name$1 = opts.name;
		let prefix = "";
		if (opts.typeflag === 5 && name$1[name$1.length - 1] !== "/") name$1 += "/";
		if (b4a$2.byteLength(name$1) !== name$1.length) return null;
		while (b4a$2.byteLength(name$1) > 100) {
			const i = name$1.indexOf("/");
			if (i === -1) return null;
			prefix += prefix ? "/" + name$1.slice(0, i) : name$1.slice(0, i);
			name$1 = name$1.slice(i + 1);
		}
		if (b4a$2.byteLength(name$1) > 100 || b4a$2.byteLength(prefix) > 155) return null;
		if (opts.linkname && b4a$2.byteLength(opts.linkname) > 100) return null;
		b4a$2.write(buf, name$1);
		b4a$2.write(buf, encodeOct(opts.mode & MASK, 6), 100);
		b4a$2.write(buf, encodeOct(opts.uid, 6), 108);
		b4a$2.write(buf, encodeOct(opts.gid, 6), 116);
		encodeSize(opts.size, buf, 124);
		b4a$2.write(buf, encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
		buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
		if (opts.linkname) b4a$2.write(buf, opts.linkname, 157);
		b4a$2.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
		b4a$2.copy(USTAR_VER, buf, VERSION_OFFSET);
		if (opts.uname) b4a$2.write(buf, opts.uname, 265);
		if (opts.gname) b4a$2.write(buf, opts.gname, 297);
		b4a$2.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
		b4a$2.write(buf, encodeOct(opts.devminor || 0, 6), 337);
		if (prefix) b4a$2.write(buf, prefix, 345);
		b4a$2.write(buf, encodeOct(cksum(buf), 6), 148);
		return buf;
	};
	exports.decode = function decode(buf, filenameEncoding, allowUnknownFormat) {
		let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
		let name$1 = decodeStr(buf, 0, 100, filenameEncoding);
		const mode = decodeOct(buf, 100, 8);
		const uid = decodeOct(buf, 108, 8);
		const gid = decodeOct(buf, 116, 8);
		const size = decodeOct(buf, 124, 12);
		const mtime = decodeOct(buf, 136, 12);
		const type$1 = toType(typeflag);
		const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
		const uname = decodeStr(buf, 265, 32);
		const gname = decodeStr(buf, 297, 32);
		const devmajor = decodeOct(buf, 329, 8);
		const devminor = decodeOct(buf, 337, 8);
		const c = cksum(buf);
		if (c === 256) return null;
		if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
		if (isUSTAR(buf)) {
			if (buf[345]) name$1 = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name$1;
		} else if (isGNU(buf)) {} else if (!allowUnknownFormat) throw new Error("Invalid tar header: unknown format.");
		if (typeflag === 0 && name$1 && name$1[name$1.length - 1] === "/") typeflag = 5;
		return {
			name: name$1,
			mode,
			uid,
			gid,
			size,
			mtime: new Date(1e3 * mtime),
			type: type$1,
			linkname,
			uname,
			gname,
			devmajor,
			devminor,
			pax: null
		};
	};
	function isUSTAR(buf) {
		return b4a$2.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
	}
	function isGNU(buf) {
		return b4a$2.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a$2.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
	}
	function clamp(index, len, defaultValue) {
		if (typeof index !== "number") return defaultValue;
		index = ~~index;
		if (index >= len) return len;
		if (index >= 0) return index;
		index += len;
		if (index >= 0) return index;
		return 0;
	}
	function toType(flag) {
		switch (flag) {
			case 0: return "file";
			case 1: return "link";
			case 2: return "symlink";
			case 3: return "character-device";
			case 4: return "block-device";
			case 5: return "directory";
			case 6: return "fifo";
			case 7: return "contiguous-file";
			case 72: return "pax-header";
			case 55: return "pax-global-header";
			case 27: return "gnu-long-link-path";
			case 28:
			case 30: return "gnu-long-path";
		}
		return null;
	}
	function toTypeflag(flag) {
		switch (flag) {
			case "file": return 0;
			case "link": return 1;
			case "symlink": return 2;
			case "character-device": return 3;
			case "block-device": return 4;
			case "directory": return 5;
			case "fifo": return 6;
			case "contiguous-file": return 7;
			case "pax-header": return 72;
		}
		return 0;
	}
	function indexOf(block, num, offset, end) {
		for (; offset < end; offset++) if (block[offset] === num) return offset;
		return end;
	}
	function cksum(block) {
		let sum = 256;
		for (let i = 0; i < 148; i++) sum += block[i];
		for (let j = 156; j < 512; j++) sum += block[j];
		return sum;
	}
	function encodeOct(val, n$1) {
		val = val.toString(8);
		if (val.length > n$1) return SEVENS.slice(0, n$1) + " ";
		return ZEROS.slice(0, n$1 - val.length) + val + " ";
	}
	function encodeSizeBin(num, buf, off) {
		buf[off] = 128;
		for (let i = 11; i > 0; i--) {
			buf[off + i] = num & 255;
			num = Math.floor(num / 256);
		}
	}
	function encodeSize(num, buf, off) {
		if (num.toString(8).length > 11) encodeSizeBin(num, buf, off);
else b4a$2.write(buf, encodeOct(num, 11), off);
	}
	function parse256(buf) {
		let positive;
		if (buf[0] === 128) positive = true;
else if (buf[0] === 255) positive = false;
else return null;
		const tuple = [];
		let i;
		for (i = buf.length - 1; i > 0; i--) {
			const byte = buf[i];
			if (positive) tuple.push(byte);
else tuple.push(255 - byte);
		}
		let sum = 0;
		const l = tuple.length;
		for (i = 0; i < l; i++) sum += tuple[i] * Math.pow(256, i);
		return positive ? sum : -1 * sum;
	}
	function decodeOct(val, offset, length) {
		val = val.subarray(offset, offset + length);
		offset = 0;
		if (val[offset] & 128) return parse256(val);
else {
			while (offset < val.length && val[offset] === 32) offset++;
			const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
			while (offset < end && val[offset] === 0) offset++;
			if (end === offset) return 0;
			return parseInt(b4a$2.toString(val.subarray(offset, end)), 8);
		}
	}
	function decodeStr(val, offset, length, encoding) {
		return b4a$2.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
	}
	function addLength(str) {
		const len = b4a$2.byteLength(str);
		let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
		if (len + digits >= Math.pow(10, digits)) digits++;
		return len + digits + str;
	}
} });

//#endregion
//#region node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/extract.js
var require_extract = __commonJS({ "node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/extract.js"(exports, module) {
	const { Writable: Writable$1, Readable: Readable$1, getStreamError: getStreamError$1 } = require_streamx();
	const FIFO = require_fast_fifo();
	const b4a$1 = require_b4a();
	const headers$1 = require_headers();
	const EMPTY = b4a$1.alloc(0);
	var BufferList = class {
		constructor() {
			this.buffered = 0;
			this.shifted = 0;
			this.queue = new FIFO();
			this._offset = 0;
		}
		push(buffer) {
			this.buffered += buffer.byteLength;
			this.queue.push(buffer);
		}
		shiftFirst(size) {
			return this._buffered === 0 ? null : this._next(size);
		}
		shift(size) {
			if (size > this.buffered) return null;
			if (size === 0) return EMPTY;
			let chunk = this._next(size);
			if (size === chunk.byteLength) return chunk;
			const chunks = [chunk];
			while ((size -= chunk.byteLength) > 0) {
				chunk = this._next(size);
				chunks.push(chunk);
			}
			return b4a$1.concat(chunks);
		}
		_next(size) {
			const buf = this.queue.peek();
			const rem = buf.byteLength - this._offset;
			if (size >= rem) {
				const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
				this.queue.shift();
				this._offset = 0;
				this.buffered -= rem;
				this.shifted += rem;
				return sub;
			}
			this.buffered -= size;
			this.shifted += size;
			return buf.subarray(this._offset, this._offset += size);
		}
	};
	var Source = class extends Readable$1 {
		constructor(self, header, offset) {
			super();
			this.header = header;
			this.offset = offset;
			this._parent = self;
		}
		_read(cb) {
			if (this.header.size === 0) this.push(null);
			if (this._parent._stream === this) this._parent._update();
			cb(null);
		}
		_predestroy() {
			this._parent.destroy(getStreamError$1(this));
		}
		_detach() {
			if (this._parent._stream === this) {
				this._parent._stream = null;
				this._parent._missing = overflow$1(this.header.size);
				this._parent._update();
			}
		}
		_destroy(cb) {
			this._detach();
			cb(null);
		}
	};
	var Extract = class extends Writable$1 {
		constructor(opts) {
			super(opts);
			if (!opts) opts = {};
			this._buffer = new BufferList();
			this._offset = 0;
			this._header = null;
			this._stream = null;
			this._missing = 0;
			this._longHeader = false;
			this._callback = noop$4;
			this._locked = false;
			this._finished = false;
			this._pax = null;
			this._paxGlobal = null;
			this._gnuLongPath = null;
			this._gnuLongLinkPath = null;
			this._filenameEncoding = opts.filenameEncoding || "utf-8";
			this._allowUnknownFormat = !!opts.allowUnknownFormat;
			this._unlockBound = this._unlock.bind(this);
		}
		_unlock(err) {
			this._locked = false;
			if (err) {
				this.destroy(err);
				this._continueWrite(err);
				return;
			}
			this._update();
		}
		_consumeHeader() {
			if (this._locked) return false;
			this._offset = this._buffer.shifted;
			try {
				this._header = headers$1.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
			} catch (err) {
				this._continueWrite(err);
				return false;
			}
			if (!this._header) return true;
			switch (this._header.type) {
				case "gnu-long-path":
				case "gnu-long-link-path":
				case "pax-global-header":
				case "pax-header":
					this._longHeader = true;
					this._missing = this._header.size;
					return true;
			}
			this._locked = true;
			this._applyLongHeaders();
			if (this._header.size === 0 || this._header.type === "directory") {
				this.emit("entry", this._header, this._createStream(), this._unlockBound);
				return true;
			}
			this._stream = this._createStream();
			this._missing = this._header.size;
			this.emit("entry", this._header, this._stream, this._unlockBound);
			return true;
		}
		_applyLongHeaders() {
			if (this._gnuLongPath) {
				this._header.name = this._gnuLongPath;
				this._gnuLongPath = null;
			}
			if (this._gnuLongLinkPath) {
				this._header.linkname = this._gnuLongLinkPath;
				this._gnuLongLinkPath = null;
			}
			if (this._pax) {
				if (this._pax.path) this._header.name = this._pax.path;
				if (this._pax.linkpath) this._header.linkname = this._pax.linkpath;
				if (this._pax.size) this._header.size = parseInt(this._pax.size, 10);
				this._header.pax = this._pax;
				this._pax = null;
			}
		}
		_decodeLongHeader(buf) {
			switch (this._header.type) {
				case "gnu-long-path":
					this._gnuLongPath = headers$1.decodeLongPath(buf, this._filenameEncoding);
					break;
				case "gnu-long-link-path":
					this._gnuLongLinkPath = headers$1.decodeLongPath(buf, this._filenameEncoding);
					break;
				case "pax-global-header":
					this._paxGlobal = headers$1.decodePax(buf);
					break;
				case "pax-header":
					this._pax = this._paxGlobal === null ? headers$1.decodePax(buf) : Object.assign({}, this._paxGlobal, headers$1.decodePax(buf));
					break;
			}
		}
		_consumeLongHeader() {
			this._longHeader = false;
			this._missing = overflow$1(this._header.size);
			const buf = this._buffer.shift(this._header.size);
			try {
				this._decodeLongHeader(buf);
			} catch (err) {
				this._continueWrite(err);
				return false;
			}
			return true;
		}
		_consumeStream() {
			const buf = this._buffer.shiftFirst(this._missing);
			if (buf === null) return false;
			this._missing -= buf.byteLength;
			const drained = this._stream.push(buf);
			if (this._missing === 0) {
				this._stream.push(null);
				if (drained) this._stream._detach();
				return drained && this._locked === false;
			}
			return drained;
		}
		_createStream() {
			return new Source(this, this._header, this._offset);
		}
		_update() {
			while (this._buffer.buffered > 0 && !this.destroying) {
				if (this._missing > 0) {
					if (this._stream !== null) {
						if (this._consumeStream() === false) return;
						continue;
					}
					if (this._longHeader === true) {
						if (this._missing > this._buffer.buffered) break;
						if (this._consumeLongHeader() === false) return false;
						continue;
					}
					const ignore = this._buffer.shiftFirst(this._missing);
					if (ignore !== null) this._missing -= ignore.byteLength;
					continue;
				}
				if (this._buffer.buffered < 512) break;
				if (this._stream !== null || this._consumeHeader() === false) return;
			}
			this._continueWrite(null);
		}
		_continueWrite(err) {
			const cb = this._callback;
			this._callback = noop$4;
			cb(err);
		}
		_write(data, cb) {
			this._callback = cb;
			this._buffer.push(data);
			this._update();
		}
		_final(cb) {
			this._finished = this._missing === 0 && this._buffer.buffered === 0;
			cb(this._finished ? null : new Error("Unexpected end of data"));
		}
		_predestroy() {
			this._continueWrite(null);
		}
		_destroy(cb) {
			if (this._stream) this._stream.destroy(getStreamError$1(this));
			cb(null);
		}
		[Symbol.asyncIterator]() {
			let error = null;
			let promiseResolve = null;
			let promiseReject = null;
			let entryStream = null;
			let entryCallback = null;
			const extract$1 = this;
			this.on("entry", onentry);
			this.on("error", (err) => {
				error = err;
			});
			this.on("close", onclose);
			return {
				[Symbol.asyncIterator]() {
					return this;
				},
				next() {
					return new Promise(onnext);
				},
				return() {
					return destroy(null);
				},
				throw(err) {
					return destroy(err);
				}
			};
			function consumeCallback(err) {
				if (!entryCallback) return;
				const cb = entryCallback;
				entryCallback = null;
				cb(err);
			}
			function onnext(resolve$1, reject) {
				if (error) return reject(error);
				if (entryStream) {
					resolve$1({
						value: entryStream,
						done: false
					});
					entryStream = null;
					return;
				}
				promiseResolve = resolve$1;
				promiseReject = reject;
				consumeCallback(null);
				if (extract$1._finished && promiseResolve) {
					promiseResolve({
						value: undefined,
						done: true
					});
					promiseResolve = promiseReject = null;
				}
			}
			function onentry(header, stream, callback) {
				entryCallback = callback;
				stream.on("error", noop$4);
				if (promiseResolve) {
					promiseResolve({
						value: stream,
						done: false
					});
					promiseResolve = promiseReject = null;
				} else entryStream = stream;
			}
			function onclose() {
				consumeCallback(error);
				if (!promiseResolve) return;
				if (error) promiseReject(error);
else promiseResolve({
					value: undefined,
					done: true
				});
				promiseResolve = promiseReject = null;
			}
			function destroy(err) {
				extract$1.destroy(err);
				consumeCallback(err);
				return new Promise((resolve$1, reject) => {
					if (extract$1.destroyed) return resolve$1({
						value: undefined,
						done: true
					});
					extract$1.once("close", function() {
						if (err) reject(err);
else resolve$1({
							value: undefined,
							done: true
						});
					});
				});
			}
		}
	};
	module.exports = function extract$1(opts) {
		return new Extract(opts);
	};
	function noop$4() {}
	function overflow$1(size) {
		size &= 511;
		return size && 512 - size;
	}
} });

//#endregion
//#region node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/constants.js
var require_constants = __commonJS({ "node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/constants.js"(exports, module) {
	const constants$2 = {
		S_IFMT: 61440,
		S_IFDIR: 16384,
		S_IFCHR: 8192,
		S_IFBLK: 24576,
		S_IFIFO: 4096,
		S_IFLNK: 40960
	};
	try {
		module.exports = __require("fs").constants || constants$2;
	} catch {
		module.exports = constants$2;
	}
} });

//#endregion
//#region node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/pack.js
var require_pack = __commonJS({ "node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/pack.js"(exports, module) {
	const { Readable, Writable, getStreamError } = require_streamx();
	const b4a = require_b4a();
	const constants$1 = require_constants();
	const headers = require_headers();
	const DMODE = 493;
	const FMODE = 420;
	const END_OF_TAR = b4a.alloc(1024);
	var Sink = class extends Writable {
		constructor(pack, header, callback) {
			super({
				mapWritable,
				eagerOpen: true
			});
			this.written = 0;
			this.header = header;
			this._callback = callback;
			this._linkname = null;
			this._isLinkname = header.type === "symlink" && !header.linkname;
			this._isVoid = header.type !== "file" && header.type !== "contiguous-file";
			this._finished = false;
			this._pack = pack;
			this._openCallback = null;
			if (this._pack._stream === null) this._pack._stream = this;
else this._pack._pending.push(this);
		}
		_open(cb) {
			this._openCallback = cb;
			if (this._pack._stream === this) this._continueOpen();
		}
		_continuePack(err) {
			if (this._callback === null) return;
			const callback = this._callback;
			this._callback = null;
			callback(err);
		}
		_continueOpen() {
			if (this._pack._stream === null) this._pack._stream = this;
			const cb = this._openCallback;
			this._openCallback = null;
			if (cb === null) return;
			if (this._pack.destroying) return cb(new Error("pack stream destroyed"));
			if (this._pack._finalized) return cb(new Error("pack stream is already finalized"));
			this._pack._stream = this;
			if (!this._isLinkname) this._pack._encode(this.header);
			if (this._isVoid) {
				this._finish();
				this._continuePack(null);
			}
			cb(null);
		}
		_write(data, cb) {
			if (this._isLinkname) {
				this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;
				return cb(null);
			}
			if (this._isVoid) {
				if (data.byteLength > 0) return cb(new Error("No body allowed for this entry"));
				return cb();
			}
			this.written += data.byteLength;
			if (this._pack.push(data)) return cb();
			this._pack._drain = cb;
		}
		_finish() {
			if (this._finished) return;
			this._finished = true;
			if (this._isLinkname) {
				this.header.linkname = this._linkname ? b4a.toString(this._linkname, "utf-8") : "";
				this._pack._encode(this.header);
			}
			overflow(this._pack, this.header.size);
			this._pack._done(this);
		}
		_final(cb) {
			if (this.written !== this.header.size) return cb(new Error("Size mismatch"));
			this._finish();
			cb(null);
		}
		_getError() {
			return getStreamError(this) || new Error("tar entry destroyed");
		}
		_predestroy() {
			this._pack.destroy(this._getError());
		}
		_destroy(cb) {
			this._pack._done(this);
			this._continuePack(this._finished ? null : this._getError());
			cb();
		}
	};
	var Pack = class extends Readable {
		constructor(opts) {
			super(opts);
			this._drain = noop$3;
			this._finalized = false;
			this._finalizing = false;
			this._pending = [];
			this._stream = null;
		}
		entry(header, buffer, callback) {
			if (this._finalized || this.destroying) throw new Error("already finalized or destroyed");
			if (typeof buffer === "function") {
				callback = buffer;
				buffer = null;
			}
			if (!callback) callback = noop$3;
			if (!header.size || header.type === "symlink") header.size = 0;
			if (!header.type) header.type = modeToType(header.mode);
			if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
			if (!header.uid) header.uid = 0;
			if (!header.gid) header.gid = 0;
			if (!header.mtime) header.mtime = new Date();
			if (typeof buffer === "string") buffer = b4a.from(buffer);
			const sink = new Sink(this, header, callback);
			if (b4a.isBuffer(buffer)) {
				header.size = buffer.byteLength;
				sink.write(buffer);
				sink.end();
				return sink;
			}
			if (sink._isVoid) return sink;
			return sink;
		}
		finalize() {
			if (this._stream || this._pending.length > 0) {
				this._finalizing = true;
				return;
			}
			if (this._finalized) return;
			this._finalized = true;
			this.push(END_OF_TAR);
			this.push(null);
		}
		_done(stream) {
			if (stream !== this._stream) return;
			this._stream = null;
			if (this._finalizing) this.finalize();
			if (this._pending.length) this._pending.shift()._continueOpen();
		}
		_encode(header) {
			if (!header.pax) {
				const buf = headers.encode(header);
				if (buf) {
					this.push(buf);
					return;
				}
			}
			this._encodePax(header);
		}
		_encodePax(header) {
			const paxHeader = headers.encodePax({
				name: header.name,
				linkname: header.linkname,
				pax: header.pax
			});
			const newHeader = {
				name: "PaxHeader",
				mode: header.mode,
				uid: header.uid,
				gid: header.gid,
				size: paxHeader.byteLength,
				mtime: header.mtime,
				type: "pax-header",
				linkname: header.linkname && "PaxHeader",
				uname: header.uname,
				gname: header.gname,
				devmajor: header.devmajor,
				devminor: header.devminor
			};
			this.push(headers.encode(newHeader));
			this.push(paxHeader);
			overflow(this, paxHeader.byteLength);
			newHeader.size = header.size;
			newHeader.type = header.type;
			this.push(headers.encode(newHeader));
		}
		_doDrain() {
			const drain = this._drain;
			this._drain = noop$3;
			drain();
		}
		_predestroy() {
			const err = getStreamError(this);
			if (this._stream) this._stream.destroy(err);
			while (this._pending.length) {
				const stream = this._pending.shift();
				stream.destroy(err);
				stream._continueOpen();
			}
			this._doDrain();
		}
		_read(cb) {
			this._doDrain();
			cb();
		}
	};
	module.exports = function pack(opts) {
		return new Pack(opts);
	};
	function modeToType(mode) {
		switch (mode & constants$1.S_IFMT) {
			case constants$1.S_IFBLK: return "block-device";
			case constants$1.S_IFCHR: return "character-device";
			case constants$1.S_IFDIR: return "directory";
			case constants$1.S_IFIFO: return "fifo";
			case constants$1.S_IFLNK: return "symlink";
		}
		return "file";
	}
	function noop$3() {}
	function overflow(self, size) {
		size &= 511;
		if (size) self.push(END_OF_TAR.subarray(0, 512 - size));
	}
	function mapWritable(buf) {
		return b4a.isBuffer(buf) ? buf : b4a.from(buf);
	}
} });

//#endregion
//#region node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({ "node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/index.js"(exports) {
	exports.extract = require_extract();
	exports.pack = require_pack();
} });

//#endregion
//#region node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({ "node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module) {
	module.exports = wrappy$1;
	function wrappy$1(fn, cb) {
		if (fn && cb) return wrappy$1(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
} });

//#endregion
//#region node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS({ "node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module) {
	var wrappy = require_wrappy();
	module.exports = wrappy(once$2);
	module.exports.strict = wrappy(onceStrict);
	once$2.proto = once$2(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once$2(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once$2(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		var name$1 = fn.name || "Function wrapped with `once`";
		f.onceError = name$1 + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
} });

//#endregion
//#region node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({ "node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js"(exports, module) {
	var once$1 = require_once();
	var noop$2 = function() {};
	var isRequest$1 = function(stream) {
		return stream.setHeader && typeof stream.abort === "function";
	};
	var isChildProcess = function(stream) {
		return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
	};
	var eos$1 = function(stream, opts, callback) {
		if (typeof opts === "function") return eos$1(stream, null, opts);
		if (!opts) opts = {};
		callback = once$1(callback || noop$2);
		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || opts.readable !== false && stream.readable;
		var writable = opts.writable || opts.writable !== false && stream.writable;
		var cancelled = false;
		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};
		var onfinish = function() {
			writable = false;
			if (!readable) callback.call(stream);
		};
		var onend = function() {
			readable = false;
			if (!writable) callback.call(stream);
		};
		var onexit = function(exitCode) {
			callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
		};
		var onerror = function(err) {
			callback.call(stream, err);
		};
		var onclose = function() {
			process.nextTick(onclosenexttick);
		};
		var onclosenexttick = function() {
			if (cancelled) return;
			if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error("premature close"));
			if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error("premature close"));
		};
		var onrequest = function() {
			stream.req.on("finish", onfinish);
		};
		if (isRequest$1(stream)) {
			stream.on("complete", onfinish);
			stream.on("abort", onclose);
			if (stream.req) onrequest();
else stream.on("request", onrequest);
		} else if (writable && !ws) {
			stream.on("end", onlegacyfinish);
			stream.on("close", onlegacyfinish);
		}
		if (isChildProcess(stream)) stream.on("exit", onexit);
		stream.on("end", onend);
		stream.on("finish", onfinish);
		if (opts.error !== false) stream.on("error", onerror);
		stream.on("close", onclose);
		return function() {
			cancelled = true;
			stream.removeListener("complete", onfinish);
			stream.removeListener("abort", onclose);
			stream.removeListener("request", onrequest);
			if (stream.req) stream.req.removeListener("finish", onfinish);
			stream.removeListener("end", onlegacyfinish);
			stream.removeListener("close", onlegacyfinish);
			stream.removeListener("finish", onfinish);
			stream.removeListener("exit", onexit);
			stream.removeListener("end", onend);
			stream.removeListener("error", onerror);
			stream.removeListener("close", onclose);
		};
	};
	module.exports = eos$1;
} });

//#endregion
//#region node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js
var require_pump = __commonJS({ "node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js"(exports, module) {
	var once = require_once();
	var eos = require_end_of_stream();
	var fs$2;
	try {
		fs$2 = __require("fs");
	} catch (e) {}
	var noop$1 = function() {};
	var ancient = /^v?\.0/.test(process.version);
	var isFn = function(fn) {
		return typeof fn === "function";
	};
	var isFS = function(stream) {
		if (!ancient) return false;
		if (!fs$2) return false;
		return (stream instanceof (fs$2.ReadStream || noop$1) || stream instanceof (fs$2.WriteStream || noop$1)) && isFn(stream.close);
	};
	var isRequest = function(stream) {
		return stream.setHeader && isFn(stream.abort);
	};
	var destroyer = function(stream, reading, writing, callback) {
		callback = once(callback);
		var closed = false;
		stream.on("close", function() {
			closed = true;
		});
		eos(stream, {
			readable: reading,
			writable: writing
		}, function(err) {
			if (err) return callback(err);
			closed = true;
			callback();
		});
		var destroyed = false;
		return function(err) {
			if (closed) return;
			if (destroyed) return;
			destroyed = true;
			if (isFS(stream)) return stream.close(noop$1);
			if (isRequest(stream)) return stream.abort();
			if (isFn(stream.destroy)) return stream.destroy();
			callback(err || new Error("stream was destroyed"));
		};
	};
	var call = function(fn) {
		fn();
	};
	var pipe = function(from$2, to) {
		return from$2.pipe(to);
	};
	var pump$1 = function() {
		var streams = Array.prototype.slice.call(arguments);
		var callback = isFn(streams[streams.length - 1] || noop$1) && streams.pop() || noop$1;
		if (Array.isArray(streams[0])) streams = streams[0];
		if (streams.length < 2) throw new Error("pump requires two streams per minimum");
		var error;
		var destroys = streams.map(function(stream, i) {
			var reading = i < streams.length - 1;
			var writing = i > 0;
			return destroyer(stream, reading, writing, function(err) {
				if (!error) error = err;
				if (err) destroys.forEach(call);
				if (reading) return;
				destroys.forEach(call);
				callback(error);
			});
		});
		return streams.reduce(pipe);
	};
	module.exports = pump$1;
} });

//#endregion
//#region node_modules/.pnpm/tar-fs@3.0.8/node_modules/tar-fs/index.js
var require_tar_fs = __commonJS({ "node_modules/.pnpm/tar-fs@3.0.8/node_modules/tar-fs/index.js"(exports) {
	const tar = require_tar_stream();
	const pump = require_pump();
	const fs$1 = __require("fs");
	const path$1 = __require("path");
	const win32 = (global.Bare?.platform || process.platform) === "win32";
	exports.pack = function pack(cwd, opts) {
		if (!cwd) cwd = ".";
		if (!opts) opts = {};
		const xfs = opts.fs || fs$1;
		const ignore = opts.ignore || opts.filter || noop;
		const mapStream = opts.mapStream || echo;
		const statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);
		const strict = opts.strict !== false;
		const umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
		const pack = opts.pack || tar.pack();
		const finish = opts.finish || noop;
		let map = opts.map || noop;
		let dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
		let fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
		if (opts.strip) map = strip(map, opts.strip);
		if (opts.readable) {
			dmode |= parseInt(555, 8);
			fmode |= parseInt(444, 8);
		}
		if (opts.writable) {
			dmode |= parseInt(333, 8);
			fmode |= parseInt(222, 8);
		}
		onnextentry();
		function onsymlink(filename, header) {
			xfs.readlink(path$1.join(cwd, filename), function(err, linkname) {
				if (err) return pack.destroy(err);
				header.linkname = normalize(linkname);
				pack.entry(header, onnextentry);
			});
		}
		function onstat(err, filename, stat) {
			if (pack.destroyed) return;
			if (err) return pack.destroy(err);
			if (!filename) {
				if (opts.finalize !== false) pack.finalize();
				return finish(pack);
			}
			if (stat.isSocket()) return onnextentry();
			let header = {
				name: normalize(filename),
				mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
				mtime: stat.mtime,
				size: stat.size,
				type: "file",
				uid: stat.uid,
				gid: stat.gid
			};
			if (stat.isDirectory()) {
				header.size = 0;
				header.type = "directory";
				header = map(header) || header;
				return pack.entry(header, onnextentry);
			}
			if (stat.isSymbolicLink()) {
				header.size = 0;
				header.type = "symlink";
				header = map(header) || header;
				return onsymlink(filename, header);
			}
			header = map(header) || header;
			if (!stat.isFile()) {
				if (strict) return pack.destroy(new Error("unsupported type for " + filename));
				return onnextentry();
			}
			const entry = pack.entry(header, onnextentry);
			const rs = mapStream(xfs.createReadStream(path$1.join(cwd, filename), {
				start: 0,
				end: header.size > 0 ? header.size - 1 : header.size
			}), header);
			rs.on("error", function(err$1) {
				entry.destroy(err$1);
			});
			pump(rs, entry);
		}
		function onnextentry(err) {
			if (err) return pack.destroy(err);
			statNext(onstat);
		}
		return pack;
	};
	function head(list) {
		return list.length ? list[list.length - 1] : null;
	}
	function processGetuid() {
		return process.getuid ? process.getuid() : -1;
	}
	function processUmask() {
		return process.umask ? process.umask() : 0;
	}
	exports.extract = function extract$1(cwd, opts) {
		if (!cwd) cwd = ".";
		if (!opts) opts = {};
		cwd = path$1.resolve(cwd);
		const xfs = opts.fs || fs$1;
		const ignore = opts.ignore || opts.filter || noop;
		const mapStream = opts.mapStream || echo;
		const own = opts.chown !== false && !win32 && processGetuid() === 0;
		const extract$1 = opts.extract || tar.extract();
		const stack = [];
		const now = new Date();
		const umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
		const strict = opts.strict !== false;
		let map = opts.map || noop;
		let dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
		let fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
		if (opts.strip) map = strip(map, opts.strip);
		if (opts.readable) {
			dmode |= parseInt(555, 8);
			fmode |= parseInt(444, 8);
		}
		if (opts.writable) {
			dmode |= parseInt(333, 8);
			fmode |= parseInt(222, 8);
		}
		extract$1.on("entry", onentry);
		if (opts.finish) extract$1.on("finish", opts.finish);
		return extract$1;
		function onentry(header, stream, next) {
			header = map(header) || header;
			header.name = normalize(header.name);
			const name$1 = path$1.join(cwd, path$1.join("/", header.name));
			if (ignore(name$1, header)) {
				stream.resume();
				return next();
			}
			if (header.type === "directory") {
				stack.push([name$1, header.mtime]);
				return mkdirfix(name$1, {
					fs: xfs,
					own,
					uid: header.uid,
					gid: header.gid,
					mode: header.mode
				}, stat);
			}
			const dir = path$1.dirname(name$1);
			validate(xfs, dir, path$1.join(cwd, "."), function(err, valid) {
				if (err) return next(err);
				if (!valid) return next(new Error(dir + " is not a valid path"));
				mkdirfix(dir, {
					fs: xfs,
					own,
					uid: header.uid,
					gid: header.gid,
					mode: 493
				}, function(err$1) {
					if (err$1) return next(err$1);
					switch (header.type) {
						case "file": return onfile();
						case "link": return onlink();
						case "symlink": return onsymlink();
					}
					if (strict) return next(new Error("unsupported type for " + name$1 + " (" + header.type + ")"));
					stream.resume();
					next();
				});
			});
			function stat(err) {
				if (err) return next(err);
				utimes(name$1, header, function(err$1) {
					if (err$1) return next(err$1);
					if (win32) return next();
					chperm(name$1, header, next);
				});
			}
			function onsymlink() {
				if (win32) return next();
				xfs.unlink(name$1, function() {
					const dst = path$1.resolve(path$1.dirname(name$1), header.linkname);
					if (!inCwd(dst)) return next(new Error(name$1 + " is not a valid symlink"));
					xfs.symlink(header.linkname, name$1, stat);
				});
			}
			function onlink() {
				if (win32) return next();
				xfs.unlink(name$1, function() {
					const dst = path$1.join(cwd, path$1.join("/", header.linkname));
					xfs.link(dst, name$1, function(err) {
						if (err && err.code === "EPERM" && opts.hardlinkAsFilesFallback) {
							stream = xfs.createReadStream(dst);
							return onfile();
						}
						stat(err);
					});
				});
			}
			function inCwd(dst) {
				return dst.startsWith(cwd);
			}
			function onfile() {
				const ws = xfs.createWriteStream(name$1);
				const rs = mapStream(stream, header);
				ws.on("error", function(err) {
					rs.destroy(err);
				});
				pump(rs, ws, function(err) {
					if (err) return next(err);
					ws.on("close", stat);
				});
			}
		}
		function utimesParent(name$1, cb) {
			let top;
			while ((top = head(stack)) && name$1.slice(0, top[0].length) !== top[0]) stack.pop();
			if (!top) return cb();
			xfs.utimes(top[0], now, top[1], cb);
		}
		function utimes(name$1, header, cb) {
			if (opts.utimes === false) return cb();
			if (header.type === "directory") return xfs.utimes(name$1, now, header.mtime, cb);
			if (header.type === "symlink") return utimesParent(name$1, cb);
			xfs.utimes(name$1, now, header.mtime, function(err) {
				if (err) return cb(err);
				utimesParent(name$1, cb);
			});
		}
		function chperm(name$1, header, cb) {
			const link = header.type === "symlink";
			const chmod = link ? xfs.lchmod : xfs.chmod;
			const chown = link ? xfs.lchown : xfs.chown;
			if (!chmod) return cb();
			const mode = (header.mode | (header.type === "directory" ? dmode : fmode)) & umask;
			if (chown && own) chown.call(xfs, name$1, header.uid, header.gid, onchown);
else onchown(null);
			function onchown(err) {
				if (err) return cb(err);
				if (!chmod) return cb();
				chmod.call(xfs, name$1, mode, cb);
			}
		}
		function mkdirfix(name$1, opts$1, cb) {
			xfs.stat(name$1, function(err) {
				if (!err) return cb(null);
				if (err.code !== "ENOENT") return cb(err);
				xfs.mkdir(name$1, {
					mode: opts$1.mode,
					recursive: true
				}, function(err$1, made) {
					if (err$1) return cb(err$1);
					chperm(name$1, opts$1, cb);
				});
			});
		}
	};
	function validate(fs$3, name$1, root, cb) {
		if (name$1 === root) return cb(null, true);
		fs$3.lstat(name$1, function(err, st) {
			if (err && err.code === "ENOENT") return validate(fs$3, path$1.join(name$1, ".."), root, cb);
else if (err) return cb(err);
			cb(null, st.isDirectory());
		});
	}
	function noop() {}
	function echo(name$1) {
		return name$1;
	}
	function normalize(name$1) {
		return win32 ? name$1.replace(/\\/g, "/").replace(/[:?<>|]/g, "_") : name$1;
	}
	function statAll(fs$3, stat, cwd, ignore, entries, sort) {
		if (!entries) entries = ["."];
		const queue = entries.slice(0);
		return function loop(callback) {
			if (!queue.length) return callback(null);
			const next = queue.shift();
			const nextAbs = path$1.join(cwd, next);
			stat.call(fs$3, nextAbs, function(err, stat$1) {
				if (err) return callback(entries.indexOf(next) === -1 && err.code === "ENOENT" ? null : err);
				if (!stat$1.isDirectory()) return callback(null, next, stat$1);
				fs$3.readdir(nextAbs, function(err$1, files$1) {
					if (err$1) return callback(err$1);
					if (sort) files$1.sort();
					for (let i = 0; i < files$1.length; i++) if (!ignore(path$1.join(cwd, next, files$1[i]))) queue.push(path$1.join(next, files$1[i]));
					callback(null, next, stat$1);
				});
			});
		};
	}
	function strip(map, level) {
		return function(header) {
			header.name = header.name.split("/").slice(level).join("/");
			const linkname = header.linkname;
			if (linkname && (header.type === "link" || path$1.isAbsolute(linkname))) header.linkname = linkname.split("/").slice(level).join("/");
			return map(header);
		};
	}
} });

//#endregion
//#region packages/cli/commands/add/fetch-packages.ts
var import_tar_fs = __toESM(require_tar_fs(), 1);
const NODE_MODULES = fileURLToPath(new URL("../node_modules", import.meta.url));
const REGISTRY = "https://registry.npmjs.org";
const Directive = {
	file: "file:",
	npm: "npm:"
};
function verifyPackage(pkg, specifier) {
	const deps = {
		...pkg.dependencies,
		...pkg.peerDependencies
	};
	if (!deps["@sveltejs/cli-core"]) throw new Error(`Invalid add-on package specified: '${specifier}' is missing a dependency on '@sveltejs/cli-core' in its 'package.json'`);
	for (const dep of Object.keys(deps)) {
		if (dep === "@sveltejs/cli-core") continue;
		throw new Error(`Invalid add-on package detected: '${specifier}'\nCommunity addons should not have any external 'dependencies' besides '@sveltejs/cli-core'. Consider bundling your dependencies if they are necessary`);
	}
}
async function downloadPackage(options$6) {
	const { pkg } = options$6;
	if (options$6.path) {
		const dest = path.join(NODE_MODULES, pkg.name.split("/").join(path.sep));
		if (fs.existsSync(dest)) fs.rmSync(dest);
		const dir = path.dirname(dest);
		if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
		fs.symlinkSync(options$6.path, dest);
		const { default: details$1 } = await import(pkg.name);
		return details$1;
	}
	const tarballUrl = pkg.dist.tarball;
	const data = await fetch(tarballUrl);
	if (!data.body) throw new Error(`Unexpected response: '${tarballUrl}' responded with no body`);
	await pipeline(data.body, createGunzip(), (0, import_tar_fs.extract)(NODE_MODULES, { map: (header) => {
		header.name = header.name.replace("package", pkg.name);
		return header;
	} }));
	const { default: details } = await import(pkg.name);
	return details;
}
async function getPackageJSON({ cwd, packageName }) {
	let npm = packageName;
	if (packageName.startsWith(Directive.file)) {
		const pkgPath = path.resolve(cwd, packageName.slice(Directive.file.length));
		const pkgJSONPath = path.resolve(pkgPath, "package.json");
		const json = fs.readFileSync(pkgJSONPath, "utf8");
		const pkg$1 = JSON.parse(json);
		verifyPackage(pkg$1, packageName);
		return {
			path: pkgPath,
			pkg: pkg$1,
			repo: pkgPath
		};
	}
	if (packageName.startsWith(Directive.npm)) npm = packageName.slice(Directive.npm.length);
	const pkg = await fetchPackageJSON(npm);
	verifyPackage(pkg, packageName);
	return {
		pkg,
		repo: pkg.repository?.url ?? `https://www.npmjs.com/package/${npm}`
	};
}
async function fetchPackageJSON(packageName) {
	let pkgName = packageName;
	let scope = "";
	if (packageName.startsWith("@")) {
		const [org, name$2] = pkgName.split("/", 2);
		scope = `${org}/`;
		pkgName = name$2;
	}
	const [name$1, tag = "latest"] = pkgName.split("@");
	const pkgUrl = `${REGISTRY}/${scope + name$1}/${tag}`;
	const resp = await fetch(pkgUrl);
	if (resp.status === 404) throw new Error(`Package '${packageName}' doesn't exist in the registry: '${pkgUrl}'`);
	if (resp.status < 200 && resp.status >= 300) throw new Error(`Failed to fetch '${pkgUrl}' - GET ${resp.status}`);
	return await resp.json();
}

//#endregion
//#region packages/cli/commands/add/preconditions.ts
function getGlobalPreconditions(cwd, addons, addonSetupResult) {
	return {
		name: "global checks",
		preconditions: [{
			name: "clean working directory",
			run: async () => {
				try {
					const asyncExec = promisify(exec);
					const { stdout: stdout$1 } = await asyncExec("git status --short", { cwd });
					if (stdout$1) return {
						success: false,
						message: "Found modified files"
					};
					return {
						success: true,
						message: undefined
					};
				} catch {
					return {
						success: true,
						message: "Not a git repository"
					};
				}
			}
		}, {
			name: "unsupported add-ons",
			run: () => {
				const reasons = addons.flatMap((a) => addonSetupResult[a.id].unsupported.map((reason) => ({
					id: a.id,
					reason
				})));
				if (reasons.length === 0) return {
					success: true,
					message: undefined
				};
				throw new UnsupportedError(reasons);
			}
		}]
	};
}

//#endregion
//#region packages/cli/commands/add/index.ts
var import_picocolors$2 = __toESM(require_picocolors$1(), 1);
const aliases = officialAddons.map((c) => c.alias).filter((v) => v !== undefined);
const addonsOptions = getAddonOptionFlags();
const communityDetails = [];
const OptionFlagSchema = optional(array(string()));
const addonOptionFlags = addonsOptions.reduce((flags, opt) => Object.assign(flags, { [opt.attributeName()]: OptionFlagSchema }), {});
const AddonsSchema = array(string());
const AddonOptionFlagsSchema = object(addonOptionFlags);
const OptionsSchema$1 = strictObject({
	cwd: string(),
	install: union([boolean(), picklist(AGENT_NAMES)]),
	preconditions: boolean(),
	community: optional(union([AddonsSchema, boolean()])),
	...AddonOptionFlagsSchema.entries
});
const defaultPkgPath = up$1();
const defaultCwd = defaultPkgPath ? path.dirname(defaultPkgPath) : undefined;
const add = new Command("add").description("applies specified add-ons into a project").argument("[add-on...]", "add-ons to install").option("-C, --cwd <path>", "path to working directory", defaultCwd).option("--no-preconditions", "skip validating preconditions").option("--no-install", "skip installing dependencies").addOption(installOption).configureHelp(helpConfig).action((addonArgs, opts) => {
	if (opts.cwd === undefined) {
		console.error("Invalid workspace: Please verify that you are inside of a Svelte project. You can also specify the working directory with `--cwd <path>`");
		process$1.exit(1);
	} else if (!fs.existsSync(path.resolve(opts.cwd, "package.json"))) {
		console.error(`Invalid workspace: Path '${path.resolve(opts.cwd)}' is not a valid workspace.`);
		process$1.exit(1);
	}
	const specifiedAddons = parse(AddonsSchema, addonArgs);
	const options$6 = parse(OptionsSchema$1, opts);
	const addonIds = officialAddons.map((addon) => addon.id);
	const invalidAddons = specifiedAddons.filter((a) => !addonIds.includes(a) && !aliases.includes(a));
	if (invalidAddons.length > 0) {
		console.error(`Invalid add-ons specified: ${invalidAddons.join(", ")}`);
		process$1.exit(1);
	}
	const selectedAddons = transformAliases(specifiedAddons);
	runCommand(async () => {
		const { nextSteps } = await runAddCommand(options$6, selectedAddons);
		if (nextSteps) box(nextSteps, "Next steps");
	});
});
for (const option of addonsOptions) add.addOption(option);
async function runAddCommand(options$6, selectedAddonIds) {
	const selectedAddons = selectedAddonIds.map((id) => ({
		type: "official",
		addon: getAddonDetails(id)
	}));
	const official = {};
	const community = {};
	for (const addonOption of addonsOptions) {
		const addonId = addonOption.name();
		const aliased = addonOption.attributeName();
		const specifiedOptions = options$6[addonId] || options$6[aliased];
		if (!specifiedOptions) continue;
		const details$1 = getAddonDetails(addonId);
		if (!selectedAddons.find((d) => d.addon === details$1)) selectedAddons.push({
			type: "official",
			addon: details$1
		});
		official[addonId] ??= {};
		const optionEntries = Object.entries(details$1.options);
		for (const specifiedOption of specifiedOptions) {
			if (!specifiedOption || specifiedOption === "none") continue;
			const optionEntry = optionEntries.find(([id, question$1]) => {
				if (question$1.type === "boolean") return id === specifiedOption || `no-${id}` === specifiedOption;
				if (question$1.type === "select" || question$1.type === "multiselect") return question$1.options.some((o) => o.value === specifiedOption);
			});
			if (!optionEntry) {
				const { choices } = getOptionChoices(details$1);
				throw new Error(`Invalid '--${addonId}' option: '${specifiedOption}'\nAvailable options: ${choices.join(", ")}`);
			}
			const [questionId, question] = optionEntry;
			let existingOption = official[addonId][questionId];
			if (existingOption !== undefined) {
				if (typeof existingOption === "boolean") existingOption = existingOption ? questionId : `no-${questionId}`;
				throw new Error(`Conflicting '--${addonId}' option: '${specifiedOption}' conflicts with '${existingOption}'`);
			}
			official[addonId][questionId] = question.type === "boolean" ? !specifiedOption.startsWith("no-") : specifiedOption;
		}
		for (const [id, question] of Object.entries(details$1.options)) if (question.condition?.(official[addonId]) !== false) official[addonId][id] ??= question.default;
else if (official[addonId][id] !== undefined) throw new Error(`Incompatible '--${addonId}' option specified: '${official[addonId][id]}'`);
	}
	if (options$6.community === true) {
		const communityAddons = await Promise.all(communityAddonIds.map(async (id) => await getCommunityAddon(id)));
		const promptOptions = communityAddons.map((addon) => ({
			value: addon.id,
			label: addon.id,
			hint: "https://www.npmjs.com/package/" + addon.id
		}));
		const selected = await multiselect({
			message: "Which community tools would you like to add to your project?",
			options: promptOptions,
			required: false
		});
		if (isCancel(selected)) {
			cancel("Operation cancelled.");
			process$1.exit(1);
		} else if (selected.length === 0) {
			cancel("No add-ons selected. Exiting.");
			process$1.exit(1);
		}
		options$6.community = selected;
	}
	if (Array.isArray(options$6.community) && options$6.community.length > 0) {
		const addons = options$6.community.map((id) => {
			const hasDirective = Object.values(Directive).some((directive) => id.startsWith(directive));
			if (hasDirective) return id;
			const validAddon = communityAddonIds.includes(id);
			if (!validAddon) throw new Error(`Invalid community add-on specified: '${id}'\nAvailable options: ${communityAddonIds.join(", ")}`);
			return id;
		});
		const { start, stop } = spinner();
		try {
			start("Resolving community add-on packages");
			const pkgs = await Promise.all(addons.map(async (id) => {
				return await getPackageJSON({
					cwd: options$6.cwd,
					packageName: id
				});
			}));
			stop("Resolved community add-on packages");
			log.warn("The Svelte maintainers have not reviewed community add-ons for malicious code. Use at your discretion.");
			const paddingName = getPadding(pkgs.map(({ pkg }) => pkg.name));
			const paddingVersion = getPadding(pkgs.map(({ pkg }) => `(v${pkg.version})`));
			const packageInfos = pkgs.map(({ pkg, repo: _repo }) => {
				const name$1 = import_picocolors$2.default.yellowBright(pkg.name.padEnd(paddingName));
				const version$1 = import_picocolors$2.default.dim(`(v${pkg.version})`.padEnd(paddingVersion));
				const repo = import_picocolors$2.default.dim(`(${_repo})`);
				return `${name$1} ${version$1} ${repo}`;
			});
			log.message(packageInfos.join("\n"));
			const confirm$1 = await confirm({ message: "Would you like to continue?" });
			if (confirm$1 !== true) {
				cancel("Operation cancelled.");
				process$1.exit(1);
			}
			start("Downloading community add-on packages");
			const details$1 = await Promise.all(pkgs.map(async (opts) => downloadPackage(opts)));
			for (const addon of details$1) {
				const id = addon.id;
				community[id] ??= {};
				communityDetails.push(addon);
				selectedAddons.push({
					type: "community",
					addon
				});
			}
			stop("Downloaded community add-on packages");
		} catch (err) {
			stop("Failed to resolve community add-on packages", 1);
			throw err;
		}
	}
	let workspace = await createWorkspace({ cwd: options$6.cwd });
	const addonSetupResults = setupAddons(officialAddons, workspace);
	if (selectedAddons.length === 0) {
		const addonOptions = officialAddons.filter(({ id }) => addonSetupResults[id].unsupported.length === 0).map(({ id, homepage: homepage$1, shortDescription }) => ({
			label: id,
			value: id,
			hint: `${shortDescription} - ${homepage$1}`
		}));
		const selected = await multiselect({
			message: `What would you like to add to your project? ${import_picocolors$2.default.dim("(use arrow keys / space bar)")}`,
			options: addonOptions,
			required: false
		});
		if (isCancel(selected)) {
			cancel("Operation cancelled.");
			process$1.exit(1);
		}
		for (const id of selected) {
			const addon = officialAddons.find((addon$1) => addon$1.id === id);
			selectedAddons.push({
				type: "official",
				addon
			});
		}
	}
	for (const { addon } of selectedAddons) {
		workspace = await createWorkspace(workspace);
		const setupResult = addonSetupResults[addon.id];
		const missingDependencies = setupResult.dependsOn.filter((depId) => !selectedAddons.some((a) => a.addon.id === depId));
		for (const depId of missingDependencies) {
			const dependency = officialAddons.find((a) => a.id === depId);
			if (!dependency) throw new Error(`'${addon.id}' depends on an invalid add-on: '${depId}'`);
			const install = await confirm({ message: `The ${import_picocolors$2.default.bold(import_picocolors$2.default.cyan(addon.id))} add-on requires ${import_picocolors$2.default.bold(import_picocolors$2.default.cyan(depId))} to also be setup. ${import_picocolors$2.default.green("Include it?")}` });
			if (install !== true) {
				cancel("Operation cancelled.");
				process$1.exit(1);
			}
			selectedAddons.push({
				type: "official",
				addon: dependency
			});
		}
	}
	if (options$6.preconditions && selectedAddons.length > 0) {
		const addons = selectedAddons.map(({ addon }) => addon);
		const { preconditions } = getGlobalPreconditions(options$6.cwd, addons, addonSetupResults);
		const fails = [];
		for (const condition of preconditions) {
			const { message, success } = await condition.run();
			if (!success) fails.push({
				name: condition.name,
				message
			});
		}
		if (fails.length > 0) {
			const message = fails.map(({ name: name$1, message: message$1 }) => import_picocolors$2.default.yellow(`${name$1} (${message$1})`)).join("\n- ");
			note(`- ${message}`, "Preconditions not met");
			const force = await confirm({
				message: "Preconditions failed. Do you wish to continue?",
				initialValue: false
			});
			if (isCancel(force) || !force) {
				cancel("Operation cancelled.");
				process$1.exit(1);
			}
		}
	}
	for (const { addon, type: type$1 } of selectedAddons) {
		const addonId = addon.id;
		const questionPrefix = selectedAddons.length > 1 ? `${addon.id}: ` : "";
		let values = {};
		if (type$1 === "official") {
			official[addonId] ??= {};
			values = official[addonId];
		}
		if (type$1 === "community") {
			community[addonId] ??= {};
			values = community[addonId];
		}
		for (const [questionId, question] of Object.entries(addon.options)) {
			const shouldAsk = question.condition?.(values);
			if (shouldAsk === false || values[questionId] !== undefined) continue;
			let answer;
			const message = questionPrefix + question.question;
			if (question.type === "boolean") answer = await confirm({
				message,
				initialValue: question.default
			});
			if (question.type === "select") answer = await select({
				message,
				initialValue: question.default,
				options: question.options
			});
			if (question.type === "multiselect") answer = await multiselect({
				message,
				initialValues: question.default,
				required: false,
				options: question.options
			});
			if (question.type === "string" || question.type === "number") {
				answer = await text({
					message,
					initialValue: question.default.toString(),
					placeholder: question.placeholder,
					validate: question.validate
				});
				if (question.type === "number") answer = Number(answer);
			}
			if (isCancel(answer)) {
				cancel("Operation cancelled.");
				process$1.exit(1);
			}
			values[questionId] = answer;
		}
	}
	if (selectedAddons.length === 0) return { packageManager: null };
	const officialDetails = Object.keys(official).map((id) => getAddonDetails(id));
	const commDetails = Object.keys(community).map((id) => communityDetails.find((a) => a.id === id));
	const details = officialDetails.concat(commDetails);
	const addonMap = Object.assign({}, ...details.map((a) => ({ [a.id]: a })));
	const { filesToFormat, pnpmBuildDependencies: addonPnpmBuildDependencies } = await applyAddons({
		workspace,
		addonSetupResults,
		addons: addonMap,
		options: official
	});
	log.success("Successfully setup add-ons");
	let packageManager;
	if (options$6.install) {
		packageManager = options$6.install === true ? await packageManagerPrompt(options$6.cwd) : options$6.install;
		if (packageManager) {
			workspace.packageManager = packageManager;
			addPnpmBuildDependencies(workspace.cwd, packageManager, ["esbuild", ...addonPnpmBuildDependencies]);
			await installDependencies(packageManager, options$6.cwd);
		}
	}
	workspace = await createWorkspace(workspace);
	if (filesToFormat.length > 0 && packageManager && !!workspace.dependencyVersion("prettier")) {
		const { start, stop } = spinner();
		start("Formatting modified files");
		try {
			await formatFiles({
				packageManager,
				cwd: options$6.cwd,
				paths: filesToFormat
			});
			stop("Successfully formatted modified files");
		} catch (e) {
			stop("Failed to format files");
			if (e instanceof Error) log.error(e.message);
		}
	}
	const highlighter = getHighlighter();
	const nextSteps = selectedAddons.filter(({ addon }) => addon.nextSteps).map(({ addon }) => {
		let addonMessage = "";
		if (selectedAddons.length > 1) addonMessage = `${import_picocolors$2.default.green(addon.id)}:\n`;
		const addonNextSteps = addon.nextSteps({
			...workspace,
			options: official[addon.id],
			highlighter
		});
		addonMessage += `- ${addonNextSteps.join("\n- ")}`;
		return addonMessage;
	}).join("\n\n") || undefined;
	return {
		nextSteps,
		packageManager
	};
}
/**
* Dedupes and transforms aliases into their respective addon id
*/
function transformAliases(ids) {
	const set = new Set();
	for (const id of ids) if (aliases.includes(id)) {
		const addon = officialAddons.find((a) => a.alias === id);
		set.add(addon.id);
	} else set.add(id);
	return Array.from(set);
}
function getAddonOptionFlags() {
	const options$6 = [];
	for (const addon of officialAddons) {
		const id = addon.id;
		const details = getAddonDetails(id);
		if (Object.values(details.options).length === 0) continue;
		const { defaults, groups } = getOptionChoices(details);
		const choices = Object.entries(groups).map(([group$1, choices$1]) => `${import_picocolors$2.default.dim(`${group$1}:`)} ${choices$1.join(", ")}`).join("\n");
		const preset = defaults.join(", ") || "none";
		const option = new Option(`--${id} [options...]`, `${id} add-on options ${import_picocolors$2.default.dim(`(preset: ${preset})`)}\n${choices}`).preset(preset).argParser((value, prev) => {
			prev ??= [];
			prev = prev.concat(value.split(/\s|,/));
			return prev;
		});
		options$6.push(option);
	}
	return options$6;
}
function getOptionChoices(details) {
	const choices = [];
	const defaults = [];
	const groups = {};
	const options$6 = {};
	for (const [id, question] of Object.entries(details.options)) {
		let values = [];
		const applyDefault = question.condition?.(options$6) !== false;
		if (question.type === "boolean") {
			values = [id, `no-${id}`];
			if (applyDefault) {
				options$6[id] = question.default;
				defaults.push(question.default ? values[0] : values[1]);
			}
		}
		if (question.type === "select") {
			values = question.options.map((o) => o.value);
			if (applyDefault) {
				options$6[id] = question.default;
				defaults.push(question.default);
			}
		}
		if (question.type === "multiselect") {
			values = question.options.map((o) => o.value);
			if (applyDefault) {
				options$6[id] = question.default;
				defaults.push(...question.default);
			}
		}
		choices.push(...values);
		const groupId = question.group ?? id;
		groups[groupId] ??= [];
		groups[groupId].push(...values);
	}
	return {
		choices,
		defaults,
		groups
	};
}

//#endregion
//#region packages/cli/commands/create.ts
var import_picocolors$1 = __toESM(require_picocolors$1(), 1);
const langs = ["ts", "jsdoc"];
const langMap = {
	ts: "typescript",
	jsdoc: "checkjs",
	false: "none"
};
const templateChoices = templates.map((t) => t.name);
const langOption = new Option("--types <lang>", "add type checking").choices(langs);
const templateOption = new Option("--template <type>", "template to scaffold").choices(templateChoices);
const ProjectPathSchema = optional(string());
const OptionsSchema = strictObject({
	types: pipe$1(optional(union([picklist(langs), boolean()])), transform((lang) => langMap[String(lang)])),
	addOns: boolean(),
	install: union([boolean(), picklist(AGENT_NAMES)]),
	template: optional(picklist(templateChoices))
});
const create$1 = new Command("create").description("scaffolds a new SvelteKit project").argument("[path]", "where the project will be created").addOption(templateOption).addOption(langOption).option("--no-types").option("--no-add-ons", "skips interactive add-on installer").option("--no-install", "skip installing dependencies").addOption(installOption).configureHelp(helpConfig).action((projectPath, opts) => {
	const cwd = parse(ProjectPathSchema, projectPath);
	const options$6 = parse(OptionsSchema, opts);
	runCommand(async () => {
		const { directory, addOnNextSteps, packageManager } = await createProject(cwd, options$6);
		const highlight = (str) => import_picocolors$1.default.bold(import_picocolors$1.default.cyan(str));
		let i = 1;
		const initialSteps = [];
		const relative = path.relative(process$1.cwd(), directory);
		const pm = packageManager ?? (await detect({ cwd: directory }))?.name ?? getUserAgent() ?? "npm";
		if (relative !== "") {
			const pathHasSpaces = relative.includes(" ");
			initialSteps.push(`${i++}: ${highlight(`cd ${pathHasSpaces ? `"${relative}"` : relative}`)}`);
		}
		if (!packageManager) {
			const { args: args$1, command: command$1 } = resolveCommand(pm, "install", []);
			initialSteps.push(`${i++}: ${highlight(`${command$1} ${args$1.join(" ")}`)}`);
		}
		const { args, command } = resolveCommand(pm, "run", ["dev", "--open"]);
		const pmRunCmd = `${command} ${args.join(" ")}`;
		const steps = [
			...initialSteps,
			`${i++}: ${highlight("git init && git add -A && git commit -m \"Initial commit\"")} (optional)`,
			`${i++}: ${highlight(pmRunCmd)}`,
			"",
			`To close the dev server, hit ${highlight("Ctrl-C")}`,
			"",
			`Stuck? Visit us at ${import_picocolors$1.default.cyan("https://svelte.dev/chat")}`
		];
		box(steps.join("\n"), "Project next steps");
		if (addOnNextSteps) box(addOnNextSteps, "Add-on next steps");
	});
});
async function createProject(cwd, options$6) {
	const { directory, template, language } = await group({
		directory: () => {
			if (cwd) return Promise.resolve(path.resolve(cwd));
			const defaultPath = "./";
			return text({
				message: "Where would you like your project to be created?",
				placeholder: `  (hit Enter to use '${defaultPath}')`,
				defaultValue: defaultPath
			});
		},
		force: async ({ results: { directory: directory$1 } }) => {
			if (fs.existsSync(directory$1) && fs.readdirSync(directory$1).filter((x) => !x.startsWith(".git")).length > 0) {
				const force = await confirm({
					message: "Directory not empty. Continue?",
					initialValue: false
				});
				if (isCancel(force) || !force) {
					cancel("Exiting.");
					process$1.exit(0);
				}
			}
		},
		template: () => {
			if (options$6.template) return Promise.resolve(options$6.template);
			return select({
				message: "Which template would you like?",
				initialValue: "minimal",
				options: templates.map((t) => ({
					label: t.title,
					value: t.name,
					hint: t.description
				}))
			});
		},
		language: () => {
			if (options$6.types) return Promise.resolve(options$6.types);
			return select({
				message: "Add type checking with TypeScript?",
				initialValue: "typescript",
				options: [
					{
						label: "Yes, using TypeScript syntax",
						value: "typescript"
					},
					{
						label: "Yes, using JavaScript with JSDoc comments",
						value: "checkjs"
					},
					{
						label: "No",
						value: "none"
					}
				]
			});
		}
	}, { onCancel: () => {
		cancel("Operation cancelled.");
		process$1.exit(0);
	} });
	const projectPath = path.resolve(directory);
	create(projectPath, {
		name: path.basename(projectPath),
		template,
		types: language
	});
	log.success("Project created");
	let packageManager;
	let addOnNextSteps;
	const installDeps = async (install) => {
		packageManager = install === true ? await packageManagerPrompt(projectPath) : install;
		addPnpmBuildDependencies(projectPath, packageManager, ["esbuild"]);
		if (packageManager) await installDependencies(packageManager, projectPath);
	};
	if (options$6.addOns) {
		const { nextSteps, packageManager: pm } = await runAddCommand({
			cwd: projectPath,
			install: options$6.install,
			preconditions: false,
			community: []
		}, []);
		packageManager = pm;
		addOnNextSteps = nextSteps;
	} else if (options$6.install) await installDeps(options$6.install);
	if (packageManager === null && options$6.install) await installDeps(options$6.install);
	return {
		directory: projectPath,
		addOnNextSteps,
		packageManager
	};
}

//#endregion
//#region packages/cli/commands/migrate.ts
const migrate = new Command("migrate").description("a CLI for migrating Svelte(Kit) codebases").argument("<migration>", "migration to run").option("-C, --cwd <path>", "path to working directory", process$1.cwd()).configureHelp({ formatHelp() {
	runMigrate(process$1.cwd(), ["--help"]);
	return "";
} }).action((migration, options$6) => {
	runMigrate(options$6.cwd, [migration]);
});
function runMigrate(cwd, args) {
	const pm = getUserAgent() ?? "npm";
	try {
		const cmdArgs = ["svelte-migrate@latest", ...args];
		if (pm === "npm") cmdArgs.unshift("--yes");
		const cmd = resolveCommand(pm, "execute", cmdArgs);
		execSync(`${cmd.command} ${cmd.args.join(" ")}`, {
			stdio: "inherit",
			cwd
		});
	} catch (error) {
		forwardExitCode(error);
	}
}

//#endregion
//#region packages/cli/commands/check.ts
var import_picocolors = __toESM(require_picocolors$1(), 1);
const check = new Command("check").description("a CLI for checking your Svelte code").allowUnknownOption(true).allowExcessArguments(true).option("-C, --cwd <path>", "path to working directory", process$1.cwd()).configureHelp({ formatHelp() {
	runCheck(process$1.cwd(), ["--help"]);
	return "";
} }).action((options$6, check$1) => {
	const cwd = options$6.cwd;
	const args = check$1.args;
	runCheck(cwd, args);
});
function runCheck(cwd, args) {
	const pm = getUserAgent() ?? "npm";
	const resolved = from(cwd, "svelte-check", true);
	if (!resolved) {
		const cmd = resolveCommand(pm, "add", ["-D", "svelte-check"]);
		console.error(`'svelte-check' is not installed locally. Install it with: ${import_picocolors.default.bold(`${cmd.command} ${cmd.args.join(" ")}`)}`);
		process$1.exit(1);
	}
	try {
		const cmd = resolveCommand(pm, "execute-local", ["svelte-check", ...args]);
		execSync(`${cmd.command} ${cmd.args.join(" ")}`, {
			stdio: "inherit",
			cwd
		});
	} catch (error) {
		forwardExitCode(error);
	}
}

//#endregion
//#region packages/cli/bin.ts
program.name(package_default.name).version(package_default.version, "-v, --version").configureHelp(helpConfig);
program.addCommand(create$1).addCommand(add).addCommand(migrate).addCommand(check);
program.parse();

//#endregion